-- MySQL dump 10.13  Distrib 5.7.11, for linux-glibc2.5 (x86_64)
--
-- Host: localhost    Database: dbblog
-- ------------------------------------------------------
-- Server version	5.7.11

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(50) NOT NULL COMMENT '文章标题',
  `description` varchar(255) DEFAULT NULL COMMENT '文章描述',
  `author` varchar(50) DEFAULT NULL COMMENT '文章作者',
  `content` longtext COMMENT '文章内容',
  `content_format` longtext COMMENT 'html的content',
  `read_num` int(11) DEFAULT '0' COMMENT '阅读量',
  `comment_num` int(11) DEFAULT '0' COMMENT '评论量',
  `like_num` int(11) DEFAULT '0' COMMENT '点赞量',
  `cover_type` int(11) DEFAULT NULL COMMENT '文章展示类别,1:普通，2：大图片，3：无图片',
  `cover` text COMMENT '封面',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  `recommend` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否推荐文章',
  `category_id` varchar(50) DEFAULT NULL COMMENT '分类类别存在多级分类，用逗号隔开',
  `publish` tinyint(4) DEFAULT '0' COMMENT '发布状态',
  `top` tinyint(1) DEFAULT '0' COMMENT '是否置顶',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8 COMMENT='文章';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (1,'本站相关','我又岂是孤岛，来往航船不曾停泊，触礁沉没皆是心防。我只是孤岛，羊皮纸上不曾有过的坐标，唯风吹万里，白云相知。我盛满胜欲者的孤独，自负放在胸前，云雨来便慷慨赠予。','Viote','### 简介\n一只有梦想的咸鱼，幻想着有一天能暴富  \n一个传说中的计算机程序猿，捞钱大法保平安  \n一个站在域名投资领域最底端的米农  \n目前在上海，可约不可撩๑乛◡乛๑  \nSize：1.75M...60KG...18CM ๑乛◡乛๑\n\n### 兴趣\n业余爱好嘛，喜欢听听歌，爬爬山，打打羽毛球球  \n计算机相关的呢，喜欢做做网站，做做开发  \n嗯，还喜欢新媒体运营（做过微信/QQ 公众号）\n\n### 擅长\n前端设计？ H5、Js、Jq、Vue、React...  \n后端开发？ Java、Nodejs、Mysql、Postgresql...  \n计算机&互联网相关的各种黑科技\n\n### 书籍\n《人工智能革命：超级智能时代的人类命运》  \n《天才在左，疯子在右》  \n《异类的天赋：天才、疯子和内向人格的成功密码》\n\n### 目标\n曾经想成为一个：全桟工程师  \n现在只想攒够可以实现目标的Money  \nemmm......  \n自问：最终想成为什么？  \n自答：????????????\n\n### 联系\n邮箱：me@osalien.com  \n','<h3 id=\"简介\">简介</h3>\n<p>一只有梦想的咸鱼，幻想着有一天能暴富<br>一个传说中的计算机程序猿，捞钱大法保平安<br>一个站在域名投资领域最底端的米农<br>目前在上海，可约不可撩๑乛◡乛๑<br>Size：1.75M...60KG...18CM ๑乛◡乛๑</p>\n<h3 id=\"兴趣\">兴趣</h3>\n<p>业余爱好嘛，喜欢听听歌，爬爬山，打打羽毛球球<br>计算机相关的呢，喜欢做做网站，做做开发<br>嗯，还喜欢新媒体运营（做过微信/QQ 公众号）</p>\n<h3 id=\"擅长\">擅长</h3>\n<p>前端设计？ H5、Js、Jq、Vue、React...<br>后端开发？ Java、Nodejs、Mysql、Postgresql...<br>计算机&amp;互联网相关的各种黑科技</p>\n<h3 id=\"书籍\">书籍</h3>\n<p>《人工智能革命：超级智能时代的人类命运》<br>《天才在左，疯子在右》<br>《异类的天赋：天才、疯子和内向人格的成功密码》</p>\n<h3 id=\"目标\">目标</h3>\n<p>曾经想成为一个：全桟工程师<br>现在只想攒够可以实现目标的Money<br>emmm......<br>自问：最终想成为什么？<br>自答：????????????</p>\n<h3 id=\"联系\">联系</h3>\n<p>邮箱：<a href=\"mailto:me@osalien.com\">me@osalien.com</a>  </p>\n',739,0,35,2,NULL,'2017-12-31 16:00:00','2020-09-30 00:49:29',1,'1',1,1),(7,'Mysql双机热备','热备份指的是：High Available（HA）即高可用，而备份指的是Backup，数据备份的一种。这是两种不同的概念，应对的产品也是两种功能上完全不同的产品。热备份主要保障业务的连续性，实现的方法是故障点的转移。而备份，主要目的是为了防止数据丢失，而做的一份拷贝，所以备份强调的是数据恢复而不是应用的故障转移。','Viote','### 一、概念\n\n#### 1、热备份和备份的区别\n\n&emsp;&emsp;热备份指的是：High Available（HA）即高可用，而备份指的是Backup，数据备份的一种。这是两种不同的概念，应对的产品也是两种功能上完全不同的产品。热备份主要保障业务的连续性，实现的方法是故障点的转移。而备份，主要目的是为了防止数据丢失，而做的一份拷贝，所以备份强调的是数据恢复而不是应用的故障转移。\n\n#### 2、什么是双机热备?　\n\n&emsp;&emsp;双机热备从广义上讲，就是对于重要的服务，使用两台服务器，互相备份，共同执行同一服务。当一台服务器出现故障时，可以由另一台服务器承担服务任务，从而在不需要人工干预的情况下，自动保证系统能持续提供服务。\n\n&emsp;&emsp;从狭义上讲，双机热备就是使用互为备份的两台服务器共同执行同一服务，其中一台主机为工作机（Primary Server），另一台主机为备份主机（Standby Server）。在系统正常情况下，工作机为应用系统提供服务，备份机监视工作机的运行情况（一般是通过心跳诊断，工作机同时也在检测备份机是否正常），当工作机出现异常，不能支持应用系统运营时，备份机主动接管工作机的工作，继续支持关键应用服务，保证系统不间断的运行。双机热备针对的是IT核心服务器、存储、网络路由交换的故障的高可用性解决方案。\n\n### 二、环境描述\n#### 1、master\n\n&emsp;系统：centos 7 \n\n&emsp;数据库：mysql 5.7.30\n\n&emsp;ip：192.168.0.123\n\n#### 2、slave\n\n&emsp;系统：centos 7  \n\n&emsp;数据库：mysql 5.7.30\n\n&emsp;ip：192.168.0.105\n\n    （注：主服务器的版本不能高于从服务器版本 ，两台服务器须处于同一局域网）\n\n### 三、主从热备实现\n\n#### 1、账户准备\n\n&emsp;①在master服务器上为从服务器建立一个连接帐户，该帐户必须授予REPLICATION SLAVE权限。进入mysql操作界面，输入以下SQL：\n\n```\ngrant replication slave on *.* to \'replicate\'@\'192.168.0.105\' identified by \'123456\';\n\nflush privileges;\n```\n&emsp;操作如图：　\n\n　![image.png](http://oss.osalien.com/dbblog/20200518/a55c974deb1b463c945c6a43205d055a.png)\n\n&emsp;②验证连接账户\n\n&emsp;在从服务器（slave）上用replicat帐户对主服务器（master）数据库进行访问，看是否可以连接成功。\n\n&emsp;在从服务器打开命令提示符，输入以下命令：\n\n```\nmysql -h192.168.0.123 -ureplicate -p123456\n```\n&emsp;如果出现下面的结果，则表示能登录成功，说明可以对这两台服务器进行双机热备进行操作。  \n\n![image.png](http://oss.osalien.com/dbblog/20200518/7da093a7d1b541e8aec90f5da63f6b8f.png)\n#### 2、master配置\n\n&emsp;①修改mysql配置文件。找到my.cnf配置文件打开后，在[mysqld]下修改即可：\n```\n[mysqld]\n\nserver-id = 123 #主ID，与从ID不能相同\n\nlog-bin=mysql-bin # 设定生成log文件名\n\nbinlog-do-db = test_db #设置同步数据库名\n\nreplicate-do-db=test_db   # 从服务器同步数据库名\n\nbinlog-ignore-db = mysql  #避免同步mysql用户配置\n```\n&emsp;②重启mysql服务\n\n&emsp;打开命令提示符，输入以下两条命令完成重启：\n```\nservice mysql stop\nservice mysql start\n```\n&emsp;③查看master服务器状态\n```\nshow master status;\n```\n&emsp;④锁表\n\n&emsp;目的是为了产生环境中不让进新的数据，好让从服务器定位同步位置，初次同步完成后，记得解锁\n```\nflush tables with read lock;\n```\n&emsp;步骤③④操作如图：  \n\n![image.png](http://oss.osalien.com/dbblog/20200518/ef398346fe4349fa8b60cd8ca28c26c0.png)\n#### 3、slave配置\n\n&emsp;①修改my.cnf配置文件\n```\nlog-bin=mysql-bin #设定生成log文件名\nserver-id=105 # 从ID，与主ID不能相同\nbinlog-do-db=test_db #设置同步数据库名\nbinlog-ignore-db=mysql #避免同步mysql用户配置\nreplicate-do-db=test_db # 从服务器同步数据库名\nreplicate-ignore-db = mysql,information_schema,performance_schema\n```\n&emsp;②重启mysql服务\n\n&emsp;③用change mster 语句指定同步位置\n\n&emsp;进入mysql操作界面后，输入如下指令：\n```\nstop slave;\nreset slave;\nchange master to master_host=\'192.168.0.123\',master_user=\'replicate\',master_password=\'123456\',master_log_file=\'mysql-bin.000124\',master_log_pos=107;\nstart slave;\n``` \n&emsp;\n```\n注：这里的master_log_file、master_log_pos必须和前面show master status查询结果保持一致\n```\n\n&emsp;操作如图：  \n![image.png](http://oss.osalien.com/dbblog/20200518/76da426c28094d8aaa0b7401c4b5ac0e.png)\n#### 4、解锁master表\n```\nunlock tables;\n```  \n\n至此，主从热备实现完成，可进行测试操作。','<h3 id=\"一、概念\">一、概念</h3>\n<h4 id=\"1、热备份和备份的区别\">1、热备份和备份的区别</h4>\n<p>&emsp;&emsp;热备份指的是：High Available（HA）即高可用，而备份指的是Backup，数据备份的一种。这是两种不同的概念，应对的产品也是两种功能上完全不同的产品。热备份主要保障业务的连续性，实现的方法是故障点的转移。而备份，主要目的是为了防止数据丢失，而做的一份拷贝，所以备份强调的是数据恢复而不是应用的故障转移。</p>\n<h4 id=\"2、什么是双机热备\">2、什么是双机热备?　</h4>\n<p>&emsp;&emsp;双机热备从广义上讲，就是对于重要的服务，使用两台服务器，互相备份，共同执行同一服务。当一台服务器出现故障时，可以由另一台服务器承担服务任务，从而在不需要人工干预的情况下，自动保证系统能持续提供服务。</p>\n<p>&emsp;&emsp;从狭义上讲，双机热备就是使用互为备份的两台服务器共同执行同一服务，其中一台主机为工作机（Primary Server），另一台主机为备份主机（Standby Server）。在系统正常情况下，工作机为应用系统提供服务，备份机监视工作机的运行情况（一般是通过心跳诊断，工作机同时也在检测备份机是否正常），当工作机出现异常，不能支持应用系统运营时，备份机主动接管工作机的工作，继续支持关键应用服务，保证系统不间断的运行。双机热备针对的是IT核心服务器、存储、网络路由交换的故障的高可用性解决方案。</p>\n<h3 id=\"二、环境描述\">二、环境描述</h3>\n<h4 id=\"1、master\">1、master</h4>\n<p>&emsp;系统：centos 7 </p>\n<p>&emsp;数据库：mysql 5.7.30</p>\n<p>&emsp;ip：192.168.0.123</p>\n<h4 id=\"2、slave\">2、slave</h4>\n<p>&emsp;系统：centos 7  </p>\n<p>&emsp;数据库：mysql 5.7.30</p>\n<p>&emsp;ip：192.168.0.105</p>\n<pre><code>（注：主服务器的版本不能高于从服务器版本 ，两台服务器须处于同一局域网）</code></pre><h3 id=\"三、主从热备实现\">三、主从热备实现</h3>\n<h4 id=\"1、账户准备\">1、账户准备</h4>\n<p>&emsp;①在master服务器上为从服务器建立一个连接帐户，该帐户必须授予REPLICATION SLAVE权限。进入mysql操作界面，输入以下SQL：</p>\n<pre><code>grant replication slave on *.* to &#39;replicate&#39;@&#39;192.168.0.105&#39; identified by &#39;123456&#39;;\n\nflush privileges;</code></pre><p>&emsp;操作如图：　</p>\n<p>　<img src=\"http://oss.osalien.com/dbblog/20200518/a55c974deb1b463c945c6a43205d055a.png\" alt=\"image.png\"></p>\n<p>&emsp;②验证连接账户</p>\n<p>&emsp;在从服务器（slave）上用replicat帐户对主服务器（master）数据库进行访问，看是否可以连接成功。</p>\n<p>&emsp;在从服务器打开命令提示符，输入以下命令：</p>\n<pre><code>mysql -h192.168.0.123 -ureplicate -p123456</code></pre><p>&emsp;如果出现下面的结果，则表示能登录成功，说明可以对这两台服务器进行双机热备进行操作。  </p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200518/7da093a7d1b541e8aec90f5da63f6b8f.png\" alt=\"image.png\"></p>\n<h4 id=\"2、master配置\">2、master配置</h4>\n<p>&emsp;①修改mysql配置文件。找到my.cnf配置文件打开后，在[mysqld]下修改即可：</p>\n<pre><code>[mysqld]\n\nserver-id = 123 #主ID，与从ID不能相同\n\nlog-bin=mysql-bin # 设定生成log文件名\n\nbinlog-do-db = test_db #设置同步数据库名\n\nreplicate-do-db=test_db   # 从服务器同步数据库名\n\nbinlog-ignore-db = mysql  #避免同步mysql用户配置</code></pre><p>&emsp;②重启mysql服务</p>\n<p>&emsp;打开命令提示符，输入以下两条命令完成重启：</p>\n<pre><code>service mysql stop\nservice mysql start</code></pre><p>&emsp;③查看master服务器状态</p>\n<pre><code>show master status;</code></pre><p>&emsp;④锁表</p>\n<p>&emsp;目的是为了产生环境中不让进新的数据，好让从服务器定位同步位置，初次同步完成后，记得解锁</p>\n<pre><code>flush tables with read lock;</code></pre><p>&emsp;步骤③④操作如图：  </p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200518/ef398346fe4349fa8b60cd8ca28c26c0.png\" alt=\"image.png\"></p>\n<h4 id=\"3、slave配置\">3、slave配置</h4>\n<p>&emsp;①修改my.cnf配置文件</p>\n<pre><code>log-bin=mysql-bin #设定生成log文件名\nserver-id=105 # 从ID，与主ID不能相同\nbinlog-do-db=test_db #设置同步数据库名\nbinlog-ignore-db=mysql #避免同步mysql用户配置\nreplicate-do-db=test_db # 从服务器同步数据库名\nreplicate-ignore-db = mysql,information_schema,performance_schema</code></pre><p>&emsp;②重启mysql服务</p>\n<p>&emsp;③用change mster 语句指定同步位置</p>\n<p>&emsp;进入mysql操作界面后，输入如下指令：</p>\n<pre><code>stop slave;\nreset slave;\nchange master to master_host=&#39;192.168.0.123&#39;,master_user=&#39;replicate&#39;,master_password=&#39;123456&#39;,master_log_file=&#39;mysql-bin.000124&#39;,master_log_pos=107;\nstart slave;</code></pre><p>&emsp;</p>\n<pre><code>注：这里的master_log_file、master_log_pos必须和前面show master status查询结果保持一致</code></pre><p>&emsp;操作如图：<br><img src=\"http://oss.osalien.com/dbblog/20200518/76da426c28094d8aaa0b7401c4b5ac0e.png\" alt=\"image.png\"></p>\n<h4 id=\"4、解锁master表\">4、解锁master表</h4>\n<pre><code>unlock tables;</code></pre><p>至此，主从热备实现完成，可进行测试操作。</p>\n',237,0,38,2,NULL,'2019-01-18 00:49:23','2020-09-30 00:49:04',1,'45,17,19',1,0),(8,'Spring IOC 容器源码分析','Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。','javadoop','Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。\n\n本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。\n\n阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。\n\n希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。\n\n\n## 引言\n\n先看下最基本的启动 Spring 容器的例子：\n\n```java\npublic static void main(String[] args) {\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationfile.xml\");\n}\n```\n\n以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。\n\n```java\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-context</artifactId>\n  <version>4.3.11.RELEASE</version>\n</dependency>\n```\n\n> spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。\n\n多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。\n\n废话说完，我们继续。`ApplicationContext context = new ClassPathXmlApplicationContext(...)` 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：\n\n![image.png](http://oss.osalien.com/dbblog/20200520/967eae0f814441f6ae52d3b8d1e6116d.png)\n\n> 读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。\n>\n> 当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。\n\n我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 **FileSystemXmlApplicationContext** 和 **AnnotationConfigApplicationContext** 这两个类。\n\n**1、FileSystemXmlApplicationContext** 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。\n\n**2、AnnotationConfigApplicationContext** 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。\n\n不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。\n\n我们先来一个简单的例子来看看怎么实例化 ApplicationContext。\n\n首先，定义一个接口：\n\n```java\npublic interface MessageService {\n    String getMessage();\n}\n```\n\n定义接口实现类：\n\n```java\npublic class MessageServiceImpl implements MessageService {\n\n    public String getMessage() {\n        return \"hello world\";\n    }\n}\n```\n\n接下来，我们在 **resources** 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\">\n\n    <bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"/>\n</beans>\n```\n\n这样，我们就可以跑起来了：\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        // 用我们的配置文件来启动一个 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\");\n      \n        System.out.println(\"context 启动成功\");\n      \n        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式\n        MessageService messageService = context.getBean(MessageService.class);\n        // 这句将输出: hello world\n        System.out.println(messageService.getMessage());\n    }\n}\n```\n\n以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。\n\n## BeanFactory 简介\n\nBeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。\n\n初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：\n\n![image.png](http://oss.osalien.com/dbblog/20200520/2de3ac3554d84c9eabff1d50eed3e5c8.png)\n\n我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。\n\n1. ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。\n2. ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。\n3. AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。\n4. ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。\n5. 请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。\n\n\n然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。\n\n## 启动过程分析\n\n下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。\n\n第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。\n\n```java\npublic class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {\n  private Resource[] configResources;\n  \n  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法\n  public ClassPathXmlApplicationContext(ApplicationContext parent) {\n    super(parent);\n  }\n  ...\n  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)\n      throws BeansException {\n\n    super(parent);\n    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)\n    setConfigLocations(configLocations);\n    if (refresh) {\n      refresh(); // 核心方法\n    }\n  }\n    ...\n}\n```\n\n接下来，就是 `refresh()`，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。\n\n往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n     \n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n        \n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset \'active\' flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring\'s core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n下面，我们开始一步步来肢解这个 refresh() 方法。\n\n### 创建 Bean 容器前的准备工作\n\n这个比较简单，直接看代码中的几个注释即可。\n\n```java\nprotected void prepareRefresh() {\n   // 记录启动时间，\n   // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型\n   this.startupDate = System.currentTimeMillis();\n   this.closed.set(false);\n   this.active.set(true);\n\n   if (logger.isInfoEnabled()) {\n      logger.info(\"Refreshing \" + this);\n   }\n\n   // Initialize any placeholder property sources in the context environment\n   initPropertySources();\n\n   // 校验 xml 配置文件\n   getEnvironment().validateRequiredProperties();\n\n   this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();\n}\n```\n\n### 创建 Bean 容器，加载并注册 Bean\n\n我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。\n\n注意，**这个方法是全文最重要的部分之一**，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。\n\n当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。\n\n// AbstractApplicationContext.java\n\n```java\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等\n   refreshBeanFactory();\n  \n   // 返回刚刚创建的 BeanFactory\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n   }\n   return beanFactory;\n}\n```\n\n// AbstractRefreshableApplicationContext.java 120\n\n```java\n@Override\nprotected final void refreshBeanFactory() throws BeansException {\n   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory\n   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前\n   // ApplicationContext 是否有 BeanFactory\n   if (hasBeanFactory()) {\n      destroyBeans();\n      closeBeanFactory();\n   }\n   try {\n      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。\n      DefaultListableBeanFactory beanFactory = createBeanFactory();\n      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到\n      beanFactory.setSerializationId(getId());\n     \n      // 下面这两个方法很重要，别跟丢了，具体细节之后说\n      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用\n      customizeBeanFactory(beanFactory);\n     \n      // 加载 Bean 到 BeanFactory 中\n      loadBeanDefinitions(beanFactory);\n      synchronized (this.beanFactoryMonitor) {\n         this.beanFactory = beanFactory;\n      }\n   }\n   catch (IOException ex) {\n      throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex);\n   }\n}\n```\n\n> 看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。\n\n我们说说为什么选择实例化 **DefaultListableBeanFactory** ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：\n\n![image.png](http://oss.osalien.com/dbblog/20200520/cbfc0b05edac444098b395de90f5e463.png)\n\n我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。\n\n> 如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？\n>\n> 之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。\n>\n> 那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。\n\n在继续往下之前，我们需要先了解 BeanDefinition。**我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？**\n\n这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。\n\n所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。\n\n> BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。\n\n#### BeanDefinition 接口定义\n\n我们来看下 BeanDefinition 的接口定义：\n\n```java\npublic interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {\n\n   // 我们可以看到，默认只提供 sington 和 prototype 两种，\n   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，\n   // 不过，它们属于基于 web 的扩展。\n   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;\n   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;\n\n   // 比较不重要，直接跳过吧\n   int ROLE_APPLICATION = 0;\n   int ROLE_SUPPORT = 1;\n   int ROLE_INFRASTRUCTURE = 2;\n\n   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍\n   // 一句话就是：继承父 Bean 的配置信息而已\n   void setParentName(String parentName);\n  \n   // 获取父 Bean\n   String getParentName();\n  \n   // 设置 Bean 的类名称，将来是要通过反射来生成实例的\n   void setBeanClassName(String beanClassName);\n   \n   // 获取 Bean 的类名称\n   String getBeanClassName();\n\n \n   // 设置 bean 的 scope\n   void setScope(String scope);\n\n   String getScope();\n\n   // 设置是否懒加载\n   void setLazyInit(boolean lazyInit);\n   \n   boolean isLazyInit();\n\n   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，\n   // 是 depends-on=\"\" 属性设置的值。\n   void setDependsOn(String... dependsOn);\n\n   // 返回该 Bean 的所有依赖\n   String[] getDependsOn();\n\n   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，\n   // 如果根据名称注入，即使这边设置了 false，也是可以的\n   void setAutowireCandidate(boolean autowireCandidate);\n\n   // 该 Bean 是否可以注入到其他 Bean 中\n   boolean isAutowireCandidate();\n\n   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean\n   void setPrimary(boolean primary);\n\n   // 是否是 primary 的\n   boolean isPrimary();\n\n   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录\n   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的\n   void setFactoryBeanName(String factoryBeanName);\n   // 获取工厂名称\n   String getFactoryBeanName();\n   // 指定工厂类中的 工厂方法名称\n   void setFactoryMethodName(String factoryMethodName);\n   // 获取工厂类中的 工厂方法名称\n   String getFactoryMethodName();\n\n   // 构造器参数\n   ConstructorArgumentValues getConstructorArgumentValues();\n\n   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到\n   MutablePropertyValues getPropertyValues();\n\n   // 是否 singleton\n   boolean isSingleton();\n\n   // 是否 prototype\n   boolean isPrototype();\n\n   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，\n   // 常用于作为 父bean 用于继承，其实也很少用......\n   boolean isAbstract();\n\n   int getRole();\n   String getDescription();\n   String getResourceDescription();\n   BeanDefinition getOriginatingBeanDefinition();\n}\n```\n\n> 这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。\n>\n> 这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。\n\n有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：\n\n```java\ncustomizeBeanFactory(beanFactory);\nloadBeanDefinitions(beanFactory);\n```\n\n虽然只有两个方法，但路还很长啊。。。\n\n#### customizeBeanFactory\n\ncustomizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。\n\n```java\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n   if (this.allowBeanDefinitionOverriding != null) {\n      // 是否允许 Bean 定义覆盖\n      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n   }\n   if (this.allowCircularReferences != null) {\n      // 是否允许 Bean 间的循环依赖\n      beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n   }\n}\n```\n\nBeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\n循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。\n\n默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。\n\n至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。\n\n之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。\n\n#### 加载 Bean: loadBeanDefinitions\n\n接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。\n\n读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。\n\n// AbstractXmlApplicationContext.java 80\n\n```java\n/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/\n@Override\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader\n   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\n   // Configure the bean definition reader with this context\'s\n   // resource loading environment.\n   beanDefinitionReader.setEnvironment(this.getEnvironment());\n   beanDefinitionReader.setResourceLoader(this);\n   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，\n   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧\n   initBeanDefinitionReader(beanDefinitionReader);\n   // 重点来了，继续往下\n   loadBeanDefinitions(beanDefinitionReader);\n}\n```\n\n现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。\n\n// AbstractXmlApplicationContext.java 120\n\n```java\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n   Resource[] configResources = getConfigResources();\n   if (configResources != null) {\n      // 往下看\n      reader.loadBeanDefinitions(configResources);\n   }\n   String[] configLocations = getConfigLocations();\n   if (configLocations != null) {\n      // 2\n      reader.loadBeanDefinitions(configLocations);\n   }\n}\n\n// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里\n@Override\npublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {\n   Assert.notNull(resources, \"Resource array must not be null\");\n   int counter = 0;\n   // 注意这里是个 for 循环，也就是每个文件是一个 resource\n   for (Resource resource : resources) {\n      // 继续往下看\n      counter += loadBeanDefinitions(resource);\n   }\n   // 最后返回 counter，表示总共加载了多少的 BeanDefinition\n   return counter;\n}\n\n// XmlBeanDefinitionReader 303\n@Override\npublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n   return loadBeanDefinitions(new EncodedResource(resource));\n}\n\n// XmlBeanDefinitionReader 314\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n   Assert.notNull(encodedResource, \"EncodedResource must not be null\");\n   if (logger.isInfoEnabled()) {\n      logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource());\n   }\n   // 用一个 ThreadLocal 来存放配置文件资源\n   Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();\n   if (currentResources == null) {\n      currentResources = new HashSet<EncodedResource>(4);\n      this.resourcesCurrentlyBeingLoaded.set(currentResources);\n   }\n   if (!currentResources.add(encodedResource)) {\n      throw new BeanDefinitionStoreException(\n            \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\");\n   }\n   try {\n      InputStream inputStream = encodedResource.getResource().getInputStream();\n      try {\n         InputSource inputSource = new InputSource(inputStream);\n         if (encodedResource.getEncoding() != null) {\n            inputSource.setEncoding(encodedResource.getEncoding());\n         }\n         // 核心部分是这里，往下面看\n         return doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n      }\n      finally {\n         inputStream.close();\n      }\n   }\n   catch (IOException ex) {\n      throw new BeanDefinitionStoreException(\n            \"IOException parsing XML document from \" + encodedResource.getResource(), ex);\n   }\n   finally {\n      currentResources.remove(encodedResource);\n      if (currentResources.isEmpty()) {\n         this.resourcesCurrentlyBeingLoaded.remove();\n      }\n   }\n}\n\n// 还在这个文件中，第 388 行\nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n      throws BeanDefinitionStoreException {\n   try {\n      // 这里就不看了，将 xml 文件转换为 Document 对象\n      Document doc = doLoadDocument(inputSource, resource);\n      // 继续\n      return registerBeanDefinitions(doc, resource);\n   }\n   catch (...\n}\n// 还在这个文件中，第 505 行\n// 返回值：返回从当前配置文件加载了多少数量的 Bean\npublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n   int countBefore = getRegistry().getBeanDefinitionCount();\n   // 这里\n   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n   return getRegistry().getBeanDefinitionCount() - countBefore;\n}\n// DefaultBeanDefinitionDocumentReader 90\n@Override\npublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n   this.readerContext = readerContext;\n   logger.debug(\"Loading bean definitions\");\n   Element root = doc.getDocumentElement();\n   // 从 xml 根节点开始解析文件\n   doRegisterBeanDefinitions(root);\n}         \n```\n\n经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：\n\n##### doRegisterBeanDefinitions：\n\n```java\n// DefaultBeanDefinitionDocumentReader 116\nprotected void doRegisterBeanDefinitions(Element root) {\n   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，\n   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，\n   // 因为 <beans /> 内部是可以定义 <beans /> 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 <beans /> 节点，从源码分析的角度，我们当做根节点就好了\n   BeanDefinitionParserDelegate parent = this.delegate;\n   this.delegate = createDelegate(getReaderContext(), root, parent);\n\n   if (this.delegate.isDefaultNamespace(root)) {\n      // 这块说的是根节点 <beans ... profile=\"dev\" /> 中的 profile 是否是当前环境需要的，\n      // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 <beans /> 解析\n      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区\n      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n      if (StringUtils.hasText(profileSpec)) {\n         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n         if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n            if (logger.isInfoEnabled()) {\n               logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec +\n                     \"] not matching: \" + getReaderContext().getResource());\n            }\n            return;\n         }\n      }\n   }\n\n   preProcessXml(root); // 钩子\n   // 往下看\n   parseBeanDefinitions(root, this.delegate);\n   postProcessXml(root); // 钩子\n\n   this.delegate = parent;\n}\n```\n\npreProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。\n\n这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。\n\n接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :\n\n```java\n// default namespace 涉及到的就四个标签 <import />、<alias />、<bean /> 和 <beans />，\n// 其他的属于 custom 的\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n   if (delegate.isDefaultNamespace(root)) {\n      NodeList nl = root.getChildNodes();\n      for (int i = 0; i < nl.getLength(); i++) {\n         Node node = nl.item(i);\n         if (node instanceof Element) {\n            Element ele = (Element) node;\n            if (delegate.isDefaultNamespace(ele)) {\n               // 解析 default namespace 下面的几个元素\n               parseDefaultElement(ele, delegate);\n            }\n            else {\n               // 解析其他 namespace 的元素\n               delegate.parseCustomElement(ele);\n            }\n         }\n      }\n   }\n   else {\n      delegate.parseCustomElement(root);\n   }\n}\n```\n\n从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。\n\nparseDefaultElement(ele, delegate) 代表解析的节点是 `<import />`、`<alias />`、`<bean />`、`<beans />` 这几个。\n\n> 这里的四个标签之所以是 **default** 的，是因为它们是处于这个 namespace 下定义的：\n>\n> ```\n> http://www.springframework.org/schema/beans\n> ```\n>\n> 又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 **xmlns** 就是咯。\n>\n> ```xml\n> <beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n>        xmlns=\"http://www.springframework.org/schema/beans\"\n>        xsi:schemaLocation=\"\n>             http://www.springframework.org/schema/beans\n>           http://www.springframework.org/schema/beans/spring-beans.xsd\"\n>        default-autowire=\"byName\">\n> ```\n>\n> 而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 `<mvc />`、`<task />`、`<context />`、`<aop />`等。\n>\n> 这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。\n>\n> 假如读者想分析 `<context:property-placeholder location=\"classpath:xx.properties\" />` 的实现原理，就应该到 ContextNamespaceHandler 中找答案。\n>\n> ```xml\n> <beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n>       xmlns=\"http://www.springframework.org/schema/beans\"\n>       xmlns:context=\"http://www.springframework.org/schema/context\"\n>       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n>       xsi:schemaLocation=\"\n>            http://www.springframework.org/schema/beans \n>            http://www.springframework.org/schema/beans/spring-beans.xsd\n>            http://www.springframework.org/schema/context\n>            http://www.springframework.org/schema/context/spring-context.xsd\n>            http://www.springframework.org/schema/mvc   \n>            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \n>        \"\n>       default-autowire=\"byName\">\n> ```\n> 同理，以后你要是碰到 `<dubbo />` 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。\n\n回过神来，看看处理 default 标签的方法：\n\n```java\nprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n      // 处理 <import /> 标签\n      importBeanDefinitionResource(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n      // 处理 <alias /> 标签定义\n      // <alias name=\"fromName\" alias=\"toName\"/>\n      processAliasRegistration(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n      // 处理 <bean /> 标签定义，这也算是我们的重点吧\n      processBeanDefinition(ele, delegate);\n   }\n   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n      // 如果碰到的是嵌套的 <beans /> 标签，需要递归\n      doRegisterBeanDefinitions(ele);\n   }\n}\n```\n\n如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 `<bean />` 标签出来说。\n\n##### processBeanDefinition 解析 bean 标签\n\n下面是 processBeanDefinition 解析 `<bean />` 标签：\n\n// DefaultBeanDefinitionDocumentReader 298\n\n```java\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 <bean /> 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n  \n   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的\n  \n   if (bdHolder != null) {\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // Register the final decorated instance.\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(\"Failed to register bean definition with name \'\" +\n               bdHolder.getBeanName() + \"\'\", ele, ex);\n      }\n      // Send registration event.\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}\n```\n\n继续往下看怎么解析之前，我们先看下 **`<bean />`** 标签中可以定义哪些属性：\n\n| Property                 |                                    |\n| ------------------------ | ---------------------------------- |\n| class                    | 类的全限定名                             |\n| name                     | 可指定 id、name(用逗号、分号、空格分隔)           |\n| scope                    | 作用域                                |\n| constructor arguments    | 指定构造参数                             |\n| properties               | 设置属性的值                             |\n| autowiring mode          | no(默认值)、byName、byType、 constructor |\n| lazy-initialization mode | 是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了) |\n| initialization method    | bean 属性设置完成后，会调用这个方法               |\n| destruction method       | bean 销毁后的回调方法                      |\n\n上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。\n\n简单地说就是像下面这样子：\n\n```xml\n<bean id=\"exampleBean\" name=\"name1, name2, name3\" class=\"com.javadoop.ExampleBean\"\n      scope=\"singleton\" lazy-init=\"true\" init-method=\"init\" destroy-method=\"cleanup\">\n  \n    <!-- 可以用下面三种形式指定构造参数 -->\n    <constructor-arg type=\"int\" value=\"7500000\"/>\n    <constructor-arg name=\"years\" value=\"7500000\"/>\n    <constructor-arg index=\"0\" value=\"7500000\"/>\n  \n    <!-- property 的几种情况 -->\n    <property name=\"beanOne\">\n        <ref bean=\"anotherExampleBean\"/>\n    </property>\n    <property name=\"beanTwo\" ref=\"yetAnotherBean\"/>\n    <property name=\"integerProperty\" value=\"1\"/>\n</bean>\n```\n\n当然，除了上面举例出来的这些，还有 factory-bean、factory-method、`<lockup-method />`、`<replaced-method />`、`<meta />`、`<qualifier />` 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。\n\n有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。\n\n// BeanDefinitionParserDelegate 428\n\n```java\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {\n    return parseBeanDefinitionElement(ele, null);\n}\n\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {\n   String id = ele.getAttribute(ID_ATTRIBUTE);\n   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n   List<String> aliases = new ArrayList<String>();\n      \n   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，\n   // 当然，如果你不定义 name 属性的话，就是空的了\n   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了\n   if (StringUtils.hasLength(nameAttr)) {\n      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n      aliases.addAll(Arrays.asList(nameArr));\n   }\n\n   String beanName = id;\n   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName\n   if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n      beanName = aliases.remove(0);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"No XML \'id\' specified - using \'\" + beanName +\n               \"\' as bean name and \" + aliases + \" as aliases\");\n      }\n   }\n\n   if (containingBean == null) {\n      checkNameUniqueness(beanName, aliases, ele);\n   }\n  \n   // 根据 <bean ...>...</bean> 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,\n   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。\n   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n   \n   // 到这里，整个 <bean /> 标签就算解析结束了，一个 BeanDefinition 就形成了。\n   if (beanDefinition != null) {\n      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生\n      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要\n      if (!StringUtils.hasText(beanName)) {\n         try {\n            if (containingBean != null) {// 按照我们的思路，这里 containingBean 是 null 的\n               beanName = BeanDefinitionReaderUtils.generateBeanName(\n                     beanDefinition, this.readerContext.getRegistry(), true);\n            }\n            else {\n               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：\n               //   1. beanName 为：com.javadoop.example.MessageServiceImpl#0\n               //   2. beanClassName 为：com.javadoop.example.MessageServiceImpl\n              \n               beanName = this.readerContext.generateBeanName(beanDefinition);\n               \n               String beanClassName = beanDefinition.getBeanClassName();\n               if (beanClassName != null &&\n                     beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&\n                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n                  // 把 beanClassName 设置为 Bean 的别名\n                  aliases.add(beanClassName);\n               }\n            }\n            if (logger.isDebugEnabled()) {\n               logger.debug(\"Neither XML \'id\' nor \'name\' specified - \" +\n                     \"using generated bean name [\" + beanName + \"]\");\n            }\n         }\n         catch (Exception ex) {\n            error(ex.getMessage(), ele);\n            return null;\n         }\n      }\n      String[] aliasesArray = StringUtils.toStringArray(aliases);\n      // 返回 BeanDefinitionHolder\n      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n   }\n\n   return null;\n}\n```\n\n然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：\n\n```java\npublic AbstractBeanDefinition parseBeanDefinitionElement(\n      Element ele, String beanName, BeanDefinition containingBean) {\n\n   this.parseState.push(new BeanEntry(beanName));\n\n   String className = null;\n   if (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n   }\n\n   try {\n      String parent = null;\n      if (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n         parent = ele.getAttribute(PARENT_ATTRIBUTE);\n      }\n      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了\n      AbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中\n      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n    \n      /**\n       * 下面的一堆是解析 <bean>......</bean> 内部的子元素，\n       * 解析出来以后的信息都放到 bd 的属性中\n       */\n     \n      // 解析 <meta />\n      parseMetaElements(ele, bd);\n      // 解析 <lookup-method />\n      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n      // 解析 <replaced-method />\n      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n    // 解析 <constructor-arg />\n      parseConstructorArgElements(ele, bd);\n      // 解析 <property />\n      parsePropertyElements(ele, bd);\n      // 解析 <qualifier />\n      parseQualifierElements(ele, bd);\n\n      bd.setResource(this.readerContext.getResource());\n      bd.setSource(extractSource(ele));\n\n      return bd;\n   }\n   catch (ClassNotFoundException ex) {\n      error(\"Bean class [\" + className + \"] not found\", ele, ex);\n   }\n   catch (NoClassDefFoundError err) {\n      error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n   }\n   catch (Throwable ex) {\n      error(\"Unexpected failure during bean definition parsing\", ele, ex);\n   }\n   finally {\n      this.parseState.pop();\n   }\n\n   return null;\n}\n```\n\n到这里，我们已经完成了根据 `<bean />` 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。\n\n我们回到解析 `<bean />` 的入口方法:\n\n```java\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 <bean /> 节点转换为 BeanDefinitionHolder，就是上面说的一堆\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n   if (bdHolder != null) {\n      // 如果有自定义属性的话，进行相应的解析，先忽略\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // 我们把这步叫做 注册Bean 吧\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(\"Failed to register bean definition with name \'\" +\n               bdHolder.getBeanName() + \"\'\", ele, ex);\n      }\n      // 注册完成后，发送事件，本文不展开说这个\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}\n```\n\n大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 `<bean />` 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：\n\n```java\npublic class BeanDefinitionHolder implements BeanMetadataElement {\n\n  private final BeanDefinition beanDefinition;\n\n  private final String beanName;\n\n  private final String[] aliases;\n...\n```\n\n然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。\n\n下面，我们开始说说注册 Bean 吧。\n\n##### 注册 Bean\n\n// BeanDefinitionReaderUtils 143\n\n```java\npublic static void registerBeanDefinition(\n      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n      throws BeanDefinitionStoreException {\n\n   String beanName = definitionHolder.getBeanName();\n   // 注册这个 Bean\n   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n\n   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了\n   String[] aliases = definitionHolder.getAliases();\n   if (aliases != null) {\n      for (String alias : aliases) {\n         // alias -> beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，\n         // 获取的时候，会先将 alias 转换为 beanName，然后再查找\n         registry.registerAlias(beanName, alias);\n      }\n   }\n}\n```\n\n别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。\n\n// DefaultListableBeanFactory 793\n\n```java\n@Override\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n      throws BeanDefinitionStoreException {\n\n   Assert.hasText(beanName, \"Bean name must not be empty\");\n   Assert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n   if (beanDefinition instanceof AbstractBeanDefinition) {\n      try {\n         ((AbstractBeanDefinition) beanDefinition).validate();\n      }\n      catch (BeanDefinitionValidationException ex) {\n         throw new BeanDefinitionStoreException(...);\n      }\n   }\n\n   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding\n   BeanDefinition oldBeanDefinition;\n  \n   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中\n   oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n  \n   // 处理重复名称的 Bean 定义的情况\n   if (oldBeanDefinition != null) {\n      if (!isAllowBeanDefinitionOverriding()) {\n         // 如果不允许覆盖的话，抛异常\n         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...\n      }\n      else if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {\n         // log...用框架定义的 Bean 覆盖用户自定义的 Bean \n      }\n      else if (!beanDefinition.equals(oldBeanDefinition)) {\n         // log...用新的 Bean 覆盖旧的 Bean\n      }\n      else {\n         // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean\n      }\n      // 覆盖\n      this.beanDefinitionMap.put(beanName, beanDefinition);\n   }\n   else {\n      // 判断是否已经有其他的 Bean 开始初始化了.\n      // 注意，\"注册Bean\" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，\n      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans\n      if (hasBeanCreationStarted()) {\n         // Cannot modify startup-time collection elements anymore (for stable iteration)\n         synchronized (this.beanDefinitionMap) {\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n            List<String> updatedDefinitions = new ArrayList<String>(this.beanDefinitionNames.size() + 1);\n            updatedDefinitions.addAll(this.beanDefinitionNames);\n            updatedDefinitions.add(beanName);\n            this.beanDefinitionNames = updatedDefinitions;\n            if (this.manualSingletonNames.contains(beanName)) {\n               Set<String> updatedSingletons = new LinkedHashSet<String>(this.manualSingletonNames);\n               updatedSingletons.remove(beanName);\n               this.manualSingletonNames = updatedSingletons;\n            }\n         }\n      }\n      else {\n         // 最正常的应该是进到这个分支。\n        \n         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition\n         this.beanDefinitionMap.put(beanName, beanDefinition);\n         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字\n         this.beanDefinitionNames.add(beanName);\n         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，\n         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的\n         // 手动指的是通过调用以下方法注册的 bean ：\n         //     registerSingleton(String beanName, Object singletonObject)\n         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面\"手动\"注册一些 Bean，\n         // 如 \"environment\"、\"systemProperties\" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的\n         this.manualSingletonNames.remove(beanName);\n      }\n      // 这个不重要，在预初始化的时候会用到，不必管它。\n      this.frozenBeanDefinitionNames = null;\n   }\n\n   if (oldBeanDefinition != null || containsSingleton(beanName)) {\n      resetBeanDefinition(beanName);\n   }\n}\n```\n\n总结一下，到这里已经初始化了 Bean 容器，`<bean />` 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。\n\n--------- 分割线 ---------\n\n到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。\n\n### Bean 容器实例化完成后\n\n说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。\n\n考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n     \n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n        \n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法\n         invokeBeanFactoryPostProcessors(beanFactory);          \n         \n          \n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成，不展开\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset \'active\' flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring\'s core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n### 准备 Bean 容器: prepareBeanFactory\n\n之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会\"手动\"注册一些特殊的 bean。\n\n这里简单介绍下 prepareBeanFactory(factory) 方法：\n\n```java\n/**\n * Configure the factory\'s standard context characteristics,\n * such as the context\'s ClassLoader and post-processors.\n * @param beanFactory the BeanFactory to configure\n */\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，\n   // 这里设置为加载当前 ApplicationContext 类的类加载器\n   beanFactory.setBeanClassLoader(getClassLoader());\n    \n   // 设置 BeanExpressionResolver\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n   // \n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // 添加一个 BeanPostProcessor，这个 processor 比较简单：\n   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，\n   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware\n   // 注意：它不仅仅回调 ApplicationContextAware，\n   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n  \n   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，\n   // Spring 会通过其他方式来处理这些依赖。\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   /**\n    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，\n    * 之前我们说过，\"当前 ApplicationContext 持有一个 BeanFactory\"，这里解释了第一行。\n    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource\n    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext\n    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean\n    */\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，\n   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器\n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它\n   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，\n   //    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj\n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   /**\n    * 从下面几行代码我们可以知道，Spring 往往很 \"智能\" 就是因为它会帮我们默认注册一些有用的 bean，\n    * 我们也可以选择覆盖\n    */\n  \n   // 如果没有定义 \"environment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n   // 如果没有定义 \"systemProperties\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n   // 如果没有定义 \"systemEnvironment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}\n```\n\n在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。\n\n### 初始化所有的 singleton beans\n\n我们的重点当然是 `finishBeanFactoryInitialization(beanFactory);` 这个巨头了，这里会负责初始化所有的 singleton beans。\n\n注意，后面的描述中，我都会使用**初始化**或**预初始化**来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。\n\n我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 `environment`、`systemProperties` 等。\n\n剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。\n\n// AbstractApplicationContext.java 834\n\n```java\n// 初始化剩余的 singleton beans\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n\n   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了\n   // 什么，看代码这里没有初始化 Bean 啊！\n   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧\n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n\n   // Register a default embedded value resolver if no bean post-processor\n   // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n   // at this point, primarily for resolution in annotation attribute values.\n   if (!beanFactory.hasEmbeddedValueResolver()) {\n      beanFactory.addEmbeddedValueResolver(new StringValueResolver() {\n         @Override\n         public String resolveStringValue(String strVal) {\n            return getEnvironment().resolvePlaceholders(strVal);\n         }\n      });\n   }\n\n   // 先初始化 LoadTimeWeaverAware 类型的 Bean\n   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧\n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n   for (String weaverAwareName : weaverAwareNames) {\n      getBean(weaverAwareName);\n   }\n\n   // Stop using the temporary ClassLoader for type matching.\n   beanFactory.setTempClassLoader(null);\n\n   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，\n   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。\n   beanFactory.freezeConfiguration();\n\n   // 开始初始化\n   beanFactory.preInstantiateSingletons();\n}\n```\n\n从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。\n\n#### preInstantiateSingletons\n\n// DefaultListableBeanFactory 728\n\n```java\n@Override\npublic void preInstantiateSingletons() throws BeansException {\n   if (this.logger.isDebugEnabled()) {\n      this.logger.debug(\"Pre-instantiating singletons in \" + this);\n   }\n   // this.beanDefinitionNames 保存了所有的 beanNames\n   List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);\n\n   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作\n   for (String beanName : beanNames) {\n     \n      // 合并父 Bean 中的配置，注意 <bean id=\"\" class=\"\" parent=\"\" /> 中的 parent，用的不多吧，\n      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 \"Bean 继承\"，不了解的请到附录中看一下\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n     \n      // 非抽象、非懒加载的 singletons。如果配置了 \'abstract = true\'，那是不需要初始化的\n      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)\n         if (isFactoryBean(beanName)) {\n            // FactoryBean 的话，在 beanName 前面加上 ‘&’ 符号。再调用 getBean，getBean 方法别急\n            final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);\n            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过\n            boolean isEagerInit;\n            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n               isEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n                  @Override\n                  public Boolean run() {\n                     return ((SmartFactoryBean<?>) factory).isEagerInit();\n                  }\n               }, getAccessControlContext());\n            }\n            else {\n               isEagerInit = (factory instanceof SmartFactoryBean &&\n                     ((SmartFactoryBean<?>) factory).isEagerInit());\n            }\n            if (isEagerInit) {\n               \n               getBean(beanName);\n            }\n         }\n         else {\n            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了\n            getBean(beanName);\n         }\n      }\n   }\n\n   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化\n   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略\n   for (String beanName : beanNames) {\n      Object singletonInstance = getSingleton(beanName);\n      if (singletonInstance instanceof SmartInitializingSingleton) {\n         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n         if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged(new PrivilegedAction<Object>() {\n               @Override\n               public Object run() {\n                  smartSingleton.afterSingletonsInstantiated();\n                  return null;\n               }\n            }, getAccessControlContext());\n         }\n         else {\n            smartSingleton.afterSingletonsInstantiated();\n         }\n      }\n   }\n}\n```\n\n接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。\n\n#### getBean\n\n在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。\n\n// AbstractBeanFactory 196\n\n```java\n@Override\npublic Object getBean(String name) throws BeansException {\n   return doGetBean(name, null, null, false);\n}\n\n// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，\n// 已经初始化过了就从容器中直接返回，否则就先初始化再返回\n@SuppressWarnings(\"unchecked\")\nprotected <T> T doGetBean(\n      final String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly)\n      throws BeansException {\n   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&’)，\n   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的\n   final String beanName = transformedBeanName(name);\n  \n   // 注意跟着这个，这个是返回值\n   Object bean; \n\n   // 检查下是不是已经创建过了\n   Object sharedInstance = getSingleton(beanName);\n  \n   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，\n   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean\n   if (sharedInstance != null && args == null) {\n      if (logger.isDebugEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.debug(\"...\");\n         }\n         else {\n            logger.debug(\"Returning cached instance of singleton bean \'\" + beanName + \"\'\");\n         }\n      }\n      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，\n      // 如果是 FactoryBean 的话，返回它创建的那个实例对象\n      // (FactoryBean 知识，读者若不清楚请移步附录)\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   }\n\n   else {\n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，\n         // 往往是因为陷入了循环引用\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // 检查一下这个 BeanDefinition 在容器中是否存在\n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有\n         String nameToLookup = originalBeanName(name);\n         if (args != null) {\n            // 返回父容器的查询结果\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         }\n         else {\n            // No args -> delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         }\n      }\n\n      if (!typeCheckOnly) {\n         // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。\n         markBeanAsCreated(beanName);\n      }\n\n      /*\n       * 稍稍总结一下：\n       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；\n       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。\n       */\n      try {\n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n         checkMergedBeanDefinition(mbd, beanName, args);\n\n         // 先初始化依赖的所有 Bean，这个很好理解。\n         // 注意，这里的依赖指的是 depends-on 中定义的依赖\n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Circular depends-on relationship between \'\" + beanName + \"\' and \'\" + dep + \"\'\");\n               }\n               // 注册一下依赖关系\n               registerDependentBean(dep, beanName);\n               // 先初始化被依赖项\n               getBean(dep);\n            }\n         }\n\n         // 如果是 singleton scope 的，创建 singleton 的实例\n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {\n               @Override\n               public Object getObject() throws BeansException {\n                  try {\n                     // 执行创建 Bean，详情后面再说\n                     return createBean(beanName, mbd, args);\n                  }\n                  catch (BeansException ex) {\n                     destroySingleton(beanName);\n                     throw ex;\n                  }\n               }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         }\n\n         // 如果是 prototype scope 的，创建 prototype 的实例\n         else if (mbd.isPrototype()) {\n            // It\'s a prototype -> create a new instance.\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               // 执行创建 Bean\n               prototypeInstance = createBean(beanName, mbd, args);\n            }\n            finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         }\n\n         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理\n         else {\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(\"No Scope registered for scope name \'\" + scopeName + \"\'\");\n            }\n            try {\n               Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n                  @Override\n                  public Object getObject() throws BeansException {\n                     beforePrototypeCreation(beanName);\n                     try {\n                        // 执行创建 Bean\n                        return createBean(beanName, mbd, args);\n                     }\n                     finally {\n                        afterPrototypeCreation(beanName);\n                     }\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            }\n            catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     \"Scope \'\" + scopeName + \"\' is not active for the current thread; consider \" +\n                     \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n                     ex);\n            }\n         }\n      }\n      catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n\n   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了\n   if (requiredType != null && bean != null && !requiredType.isInstance(bean)) {\n      try {\n         return getTypeConverter().convertIfNecessary(bean, requiredType);\n      }\n      catch (TypeMismatchException ex) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Failed to convert bean \'\" + name + \"\' to required type \'\" +\n                  ClassUtils.getQualifiedName(requiredType) + \"\'\", ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n      }\n   }\n   return (T) bean;\n}\n```\n\n大家应该也猜到了，接下来当然是分析 createBean 方法：\n\n```java\nprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;\n```\n\n第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。\n\n这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。\n\n主要是为了以下场景，采用 @Autowired 注解注入属性值：\n\n```java\npublic class MessageServiceImpl implements MessageService {\n    @Autowired\n    private UserService userService;\n  \n    public String getMessage() {\n        return userService.getMessage();\n    }\n}\n```\n\n```xml\n<bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\" />\n```\n\n以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。\n\n好了，读者要知道这么回事就可以了，继续向前。\n\n// AbstractAutowireCapableBeanFactory 447\n\n```java\n/**\n * Central method of this class: creates a bean instance,\n * populates the bean instance, applies post-processors, etc.\n * @see #doCreateBean\n */\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating instance of bean \'\" + beanName + \"\'\");\n   }\n   RootBeanDefinition mbdToUse = mbd;\n\n   // 确保 BeanDefinition 中的 Class 被加载\n   Class<?> resolvedClass = resolveBeanClass(mbd, beanName);\n   if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n      mbdToUse = new RootBeanDefinition(mbd);\n      mbdToUse.setBeanClass(resolvedClass);\n   }\n\n   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 <lookup-method /> \n   // 和 <replaced-method />，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。\n   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看\n   try {\n      mbdToUse.prepareMethodOverrides();\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n            beanName, \"Validation of method overrides failed\", ex);\n   }\n\n   try {\n      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，\n      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过\n      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n      if (bean != null) {\n         return bean; \n      }\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n            \"BeanPostProcessor before instantiation of bean failed\", ex);\n   }\n   // 重头戏，创建 bean\n   Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Finished creating instance of bean \'\" + beanName + \"\'\");\n   }\n   return beanInstance;\n}\n```\n\n#### 创建 Bean\n\n我们继续往里看 doCreateBean 这个方法：\n\n```java\n/**\n * Actually create the specified bean. Pre-creation processing has already happened\n * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n * <p>Differentiates between default bean instantiation, use of a\n * factory method, and autowiring a constructor.\n * @param beanName the name of the bean\n * @param mbd the merged bean definition for the bean\n * @param args explicit arguments to use for constructor or factory method invocation\n * @return a new instance of the bean\n * @throws BeanCreationException if the bean could not be created\n * @see #instantiateBean\n * @see #instantiateUsingFactoryMethod\n * @see #autowireConstructor\n */\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)\n      throws BeanCreationException {\n\n   // Instantiate the bean.\n   BeanWrapper instanceWrapper = null;\n   if (mbd.isSingleton()) {\n      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n   }\n   if (instanceWrapper == null) {\n      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说\n      instanceWrapper = createBeanInstance(beanName, mbd, args);\n   }\n   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 \"bean 实例\"\n   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);\n   // 类型\n   Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);\n   mbd.resolvedTargetType = beanType;\n\n   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor\n   synchronized (mbd.postProcessingLock) {\n      if (!mbd.postProcessed) {\n         try {\n            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的\n            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n         }\n         catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                  \"Post-processing of merged bean definition failed\", ex);\n         }\n         mbd.postProcessed = true;\n      }\n   }\n\n   // Eagerly cache singletons to be able to resolve circular references\n   // even when triggered by lifecycle interfaces like BeanFactoryAware.\n   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧\n   boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n         isSingletonCurrentlyInCreation(beanName));\n   if (earlySingletonExposure) {\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Eagerly caching bean \'\" + beanName +\n               \"\' to allow for resolving potential circular references\");\n      }\n      addSingletonFactory(beanName, new ObjectFactory<Object>() {\n         @Override\n         public Object getObject() throws BeansException {\n            return getEarlyBeanReference(beanName, mbd, bean);\n         }\n      });\n   }\n\n   // Initialize the bean instance.\n   Object exposedObject = bean;\n   try {\n      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值\n      populateBean(beanName, mbd, instanceWrapper);\n      if (exposedObject != null) {\n         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？\n         // 这里就是处理 bean 初始化完成后的各种回调\n         exposedObject = initializeBean(beanName, exposedObject, mbd);\n      }\n   }\n   catch (Throwable ex) {\n      if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n         throw (BeanCreationException) ex;\n      }\n      else {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n      }\n   }\n\n   if (earlySingletonExposure) {\n      // \n      Object earlySingletonReference = getSingleton(beanName, false);\n      if (earlySingletonReference != null) {\n         if (exposedObject == bean) {\n            exposedObject = earlySingletonReference;\n         }\n         else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n            String[] dependentBeans = getDependentBeans(beanName);\n            Set<String> actualDependentBeans = new LinkedHashSet<String>(dependentBeans.length);\n            for (String dependentBean : dependentBeans) {\n               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                  actualDependentBeans.add(dependentBean);\n               }\n            }\n            if (!actualDependentBeans.isEmpty()) {\n               throw new BeanCurrentlyInCreationException(beanName,\n                     \"Bean with name \'\" + beanName + \"\' has been injected into other beans [\" +\n                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                     \"] in its raw version as part of a circular reference, but has eventually been \" +\n                     \"wrapped. This means that said other beans do not use the final version of the \" +\n                     \"bean. This is often the result of over-eager type matching - consider using \" +\n                     \"\'getBeanNamesOfType\' with the \'allowEagerInit\' flag turned off, for example.\");\n            }\n         }\n      }\n   }\n\n   // Register bean as disposable.\n   try {\n      registerDisposableBeanIfNecessary(beanName, bean, mbd);\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n   }\n\n   return exposedObject;\n}\n```\n\n到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。\n\n接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 \n\n注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。\n\n##### 创建 Bean 实例\n\n我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。\n\n```java\nprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {\n   // 确保已经加载了此 class\n   Class<?> beanClass = resolveBeanClass(mbd, beanName);\n\n   // 校验一下这个类的访问权限\n   if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {\n      throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n            \"Bean class isn\'t public, and non-public access not allowed: \" + beanClass.getName());\n   }\n\n   if (mbd.getFactoryMethodName() != null)  {\n      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean\n      return instantiateUsingFactoryMethod(beanName, mbd, args);\n   }\n\n   // 如果不是第一次创建，比如第二次创建 prototype bean。\n   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化\n   boolean resolved = false;\n   boolean autowireNecessary = false;\n   if (args == null) {\n      synchronized (mbd.constructorArgumentLock) {\n         if (mbd.resolvedConstructorOrFactoryMethod != null) {\n            resolved = true;\n            autowireNecessary = mbd.constructorArgumentsResolved;\n         }\n      }\n   }\n   if (resolved) {\n      if (autowireNecessary) {\n         // 构造函数依赖注入\n         return autowireConstructor(beanName, mbd, null, null);\n      }\n      else {\n         // 无参构造函数\n         return instantiateBean(beanName, mbd);\n      }\n   }\n\n   // 判断是否采用有参构造函数\n   Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n   if (ctors != null ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n      // 构造函数依赖注入\n      return autowireConstructor(beanName, mbd, ctors, args);\n   }\n\n   // 调用无参构造函数\n   return instantiateBean(beanName, mbd);\n}\n```\n\n挑个简单的**无参构造函数**构造实例来看看：\n\n```java\nprotected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n   try {\n      Object beanInstance;\n      final BeanFactory parent = this;\n      if (System.getSecurityManager() != null) {\n         beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n               \n               return getInstantiationStrategy().instantiate(mbd, beanName, parent);\n            }\n         }, getAccessControlContext());\n      }\n      else {\n         // 实例化\n         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);\n      }\n      // 包装一下，返回\n      BeanWrapper bw = new BeanWrapperImpl(beanInstance);\n      initBeanWrapper(bw);\n      return bw;\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n   }\n}\n```\n\n我们可以看到，关键的地方在于：\n\n```java\nbeanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);\n```\n\n这里会进行实际的实例化过程，我们进去看看:\n\n// SimpleInstantiationStrategy 59\n\n```java\n@Override\npublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {\n\n   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,\n   // 方法覆写 请参见附录\"方法注入\"中对 lookup-method 和 replaced-method 的介绍\n   if (bd.getMethodOverrides().isEmpty()) {\n      Constructor<?> constructorToUse;\n      synchronized (bd.constructorArgumentLock) {\n         constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;\n         if (constructorToUse == null) {\n            final Class<?> clazz = bd.getBeanClass();\n            if (clazz.isInterface()) {\n               throw new BeanInstantiationException(clazz, \"Specified class is an interface\");\n            }\n            try {\n               if (System.getSecurityManager() != null) {\n                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction<Constructor<?>>() {\n                     @Override\n                     public Constructor<?> run() throws Exception {\n                        return clazz.getDeclaredConstructor((Class[]) null);\n                     }\n                  });\n               }\n               else {\n                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);\n               }\n               bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n            }\n            catch (Throwable ex) {\n               throw new BeanInstantiationException(clazz, \"No default constructor found\", ex);\n            }\n         }\n      }\n      // 利用构造方法进行实例化\n      return BeanUtils.instantiateClass(constructorToUse);\n   }\n   else {\n      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。\n      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持\n      return instantiateWithMethodInjection(bd, beanName, owner);\n   }\n}\n```\n\n到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。\n\n##### bean 属性注入\n\n看完了 createBeanInstance(...) 方法，我们来看看 populateBean(...) 方法，该方法负责进行属性设值，处理依赖。\n\n// AbstractAutowireCapableBeanFactory 1203\n\n```java\nprotected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {\n   // bean 实例的所有属性都在这里了\n   PropertyValues pvs = mbd.getPropertyValues();\n\n   if (bw == null) {\n      if (!pvs.isEmpty()) {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n      }\n      else {\n         // Skip property population phase for null instance.\n         return;\n      }\n   }\n\n   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，\n   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，\n   // 我也没找到有实际的使用，所以我们暂且忽略这块吧\n   boolean continueWithPropertyPopulation = true;\n   if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n      for (BeanPostProcessor bp : getBeanPostProcessors()) {\n         if (bp instanceof InstantiationAwareBeanPostProcessor) {\n            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n            // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理\n            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n               continueWithPropertyPopulation = false;\n               break;\n            }\n         }\n      }\n   }\n\n   if (!continueWithPropertyPopulation) {\n      return;\n   }\n\n   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n         autowireByName(beanName, mbd, bw, newPvs);\n      }\n\n      // 通过类型装配。复杂一些\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n         autowireByType(beanName, mbd, bw, newPvs);\n      }\n\n      pvs = newPvs;\n   }\n\n   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n   if (hasInstAwareBpps || needsDepCheck) {\n      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n      if (hasInstAwareBpps) {\n         for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor\n               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究\n               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n               if (pvs == null) {\n                  return;\n               }\n            }\n         }\n      }\n      if (needsDepCheck) {\n         checkDependencies(beanName, mbd, filteredPds, pvs);\n      }\n   }\n   // 设置 bean 实例的属性值\n   applyPropertyValues(beanName, mbd, bw, pvs);\n}\n```\n\n##### initializeBean\n\n属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。\n\n```java\nprotected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n   if (System.getSecurityManager() != null) {\n      AccessController.doPrivileged(new PrivilegedAction<Object>() {\n         @Override\n         public Object run() {\n            invokeAwareMethods(beanName, bean);\n            return null;\n         }\n      }, getAccessControlContext());\n   }\n   else {\n      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调\n      invokeAwareMethods(beanName, bean);\n   }\n\n   Object wrappedBean = bean;\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessBeforeInitialization 回调\n      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n   }\n\n   try {\n      // 处理 bean 中定义的 init-method，\n      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法\n      invokeInitMethods(beanName, wrappedBean, mbd);\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            (mbd != null ? mbd.getResourceDescription() : null),\n            beanName, \"Invocation of init method failed\", ex);\n   }\n\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessAfterInitialization 回调\n      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n   }\n   return wrappedBean;\n}\n```\n\n大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？\n\n## 附录\n\n### id 和 name\n\n每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。\n\n我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。\n\n```java\nbeanFactory.getBean(\"beanName or alias\");\n```\n\n在配置 `<bean />` 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。\n\n```xml\n<bean id=\"messageService\" name=\"m1, m2, m3\" class=\"com.javadoop.example.MessageServiceImpl\">\n```\n\n以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。\n\n```xml\n<bean name=\"m1, m2, m3\" class=\"com.javadoop.example.MessageServiceImpl\" />\n```\n\n以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。\n\n```xml\n<bean class=\"com.javadoop.example.MessageServiceImpl\">\n```\n\nbeanName 为：com.javadoop.example.MessageServiceImpl#0，\n\n别名 1 个，为： com.javadoop.example.MessageServiceImpl\n\n```xml\n<bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\">\n```\n\n以上配置的结果就是：beanName 为 messageService，没有别名。\n\n### 配置是否允许 Bean 覆盖、是否允许循环依赖\n\n我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\n可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。\n\n循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。\n\n它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。\n\n添加这两个属性的作者 Juergen Hoeller 在这个 [jira](https://jira.spring.io/browse/SPR-4374) 的讨论中说明了怎么配置这两个属性。\n\n```java\npublic class NoBeanOverridingContextLoader extends ContextLoader {\n \n  @Override\n  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) {\n    super.customizeContext(servletContext, applicationContext);\n    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;\n    arac.setAllowBeanDefinitionOverriding(false);\n  }\n}\n```\n\n```java\npublic class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener {\n \n  @Override\n  protected ContextLoader createContextLoader() {\n    return new NoBeanOverridingContextLoader();\n  }\n  \n}\n```\n\n```xml\n<listener>\n    <listener-class>com.javadoop.MyContextLoaderListener</listener-class>  \n</listener>\n```\n\n如果以上方式不能满足你的需求，请参考这个链接：[解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题](http://blog.csdn.net/zgmzyr/article/details/39380477)\n\n### profile\n\n我们可以把不同环境的配置分别配置到单独的文件中，举个例子：\n\n```xml\n<beans profile=\"development\"\n    xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n    xsi:schemaLocation=\"...\">\n\n    <jdbc:embedded-database id=\"dataSource\">\n        <jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/>\n        <jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n    </jdbc:embedded-database>\n</beans>\n```\n```xml\n<beans profile=\"production\"\n    xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xsi:schemaLocation=\"...\">\n\n    <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n</beans>\n```\n\n应该不必做过多解释了吧，看每个文件第一行的 profile=\"\"。\n\n当然，我们也可以在一个配置文件中使用：\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xsi:schemaLocation=\"...\">\n\n    <beans profile=\"development\">\n        <jdbc:embedded-database id=\"dataSource\">\n            <jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/>\n            <jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n        </jdbc:embedded-database>\n    </beans>\n\n    <beans profile=\"production\">\n        <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n    </beans>\n</beans>\n```\n\n理解起来也很简单吧。\n\n接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？\n\nSpring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。\n\n最简单的方式莫过于在程序启动的时候指定：\n\n```shell\n-Dspring.profiles.active=\"profile1,profile2\"\n```\n\n> profile 可以激活多个\n\n当然，我们也可以通过代码的形式从 Environment 中设置 profile：\n\n```java\nAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles(\"development\");\nctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\nctx.refresh(); // 重启\n```\n\n如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：\n\n```shell\njava -Dspring.profiles.active=prod -jar JavaDoop.jar\n```\n\n如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。\n\n### 工厂模式生成 Bean\n\n请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。\n\n设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。\n\n静态工厂：\n\n```xml\n<bean id=\"clientService\"\n    class=\"examples.ClientService\"\n    factory-method=\"createInstance\"/>\n```\n\n```java\npublic class ClientService {\n    private static ClientService clientService = new ClientService();\n    private ClientService() {}\n\n    // 静态方法\n    public static ClientService createInstance() {\n        return clientService;\n    }\n}\n```\n\n实例工厂：\n\n```xml\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n    <!-- inject any dependencies required by this locator bean -->\n</bean>\n\n<bean id=\"clientService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createClientServiceInstance\"/>\n\n<bean id=\"accountService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createAccountServiceInstance\"/>\n```\n\n```java\npublic class DefaultServiceLocator {\n\n    private static ClientService clientService = new ClientServiceImpl();\n\n    private static AccountService accountService = new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() {\n        return clientService;\n    }\n\n    public AccountService createAccountServiceInstance() {\n        return accountService;\n    }\n}\n```\n### FactoryBean\n\nFactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。\n\n```java\npublic interface FactoryBean<T> {\n    T getObject() throws Exception;\n    Class<T> getObjectType();\n    boolean isSingleton();\n}\n```\n\n```java\npublic class Person { \n    private Car car ;\n    private void setCar(Car car){ this.car = car;  }  \n}\n```\n\n我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：\n\n```java\npublic class MyCarFactoryBean implements FactoryBean<Car>{\n    private String make; \n    private int year ;\n    \n    public void setMake(String m){ this.make =m ; }\n    \n    public void setYear(int y){ this.year = y; }\n    \n    public Car getObject(){ \n      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种\n      CarBuilder cb = CarBuilder.car();\n      \n      if(year!=0) cb.setYear(this.year);\n      if(StringUtils.hasText(this.make)) cb.setMake( this.make ); \n      return cb.factory(); \n    }\n    \n    public Class<Car> getObjectType() { return Car.class ; } \n    \n    public boolean isSingleton() { return false; }\n}\n```\n\n我们看看装配的时候是怎么配置的：\n\n```xml\n<bean class = \"com.javadoop.MyCarFactoryBean\" id = \"car\">\n  <property name = \"make\" value =\"Honda\"/>\n  <property name = \"year\" value =\"1984\"/>\n</bean>\n<bean class = \"com.javadoop.Person\" id = \"josh\">\n  <property name = \"car\" ref = \"car\"/>\n</bean>\n```\n\n看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。\n\n说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？\n\n```java\n@Configuration \npublic class CarConfiguration { \n\n    @Bean \n    public MyCarFactoryBean carFactoryBean(){ \n      MyCarFactoryBean cfb = new MyCarFactoryBean();\n      cfb.setMake(\"Honda\");\n      cfb.setYear(1984);\n      return cfb;\n    }\n\n    @Bean\n    public Person aPerson(){ \n    Person person = new Person();\n      // 注意这里的不同\n    person.setCar(carFactoryBean().getObject());\n    return person; \n    } \n}\n```\n\n这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。\n\n### 初始化 Bean 的回调\n\n有以下四种方案：\n\n```xml\n<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/>\n```\n\n```java\npublic class AnotherExampleBean implements InitializingBean {\n\n    public void afterPropertiesSet() {\n        // do some initialization work\n    }\n}\n```\n\n```java\n@Bean(initMethod = \"init\")\npublic Foo foo() {\n    return new Foo();\n}\n```\n\n```java\n@PostConstruct\npublic void init() {\n    \n}\n```\n\n### 销毁 Bean 的回调\n\n```xml\n<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/>\n```\n\n```java\npublic class AnotherExampleBean implements DisposableBean {\n\n    public void destroy() {\n        // do some destruction work (like releasing pooled connections)\n    }\n}\n```\n\n```java\n@Bean(destroyMethod = \"cleanup\")\npublic Bar bar() {\n    return new Bar();\n}\n```\n\n```java\n@PreDestroy\npublic void cleanup() {\n    \n}\n```\n\n### ConversionService\n\n既然文中说到了这个，顺便提一下好了。\n\n最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。\n\n像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。\n\n```xml\n<bean id=\"conversionService\"\n  class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n  <property name=\"converters\">\n    <list>\n      <bean class=\"com.javadoop.learning.utils.StringToEnumConverterFactory\"/>\n    </list>\n  </property>\n</bean>\n```\n\nConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。\n\n下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。\n\n来看一个很简单的例子，这样比什么都管用。\n\n```java\npublic class StringToDateConverter implements Converter<String, Date> {\n\n    @Override\n    public Date convert(String source) {\n        try {\n            return DateUtils.parseDate(source, \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"HH:mm:ss\", \"HH:mm\");\n        } catch (ParseException e) {\n            return null;\n        }\n    }\n}\n```\n\n只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。\n\n### Bean 继承\n\n在初始化 Bean 的地方，我们说过了这个：\n\n```java\nRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n```\n\n这里涉及到的就是 `<bean parent=\"\" />` 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。\n\n首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。\n\nSpring 中提供了继承自 AbstractBeanDefinition 的 `ChildBeanDefinition` 来表示 child bean。\n\n看如下一个例子:\n\n```java\n<bean id=\"inheritedTestBean\" abstract=\"true\" class=\"org.springframework.beans.TestBean\">\n    <property name=\"name\" value=\"parent\"/>\n    <property name=\"age\" value=\"1\"/>\n</bean>\n\n<bean id=\"inheritsWithDifferentClass\" class=\"org.springframework.beans.DerivedTestBean\"\n        parent=\"inheritedTestBean\" init-method=\"initialize\">\n        \n    <property name=\"name\" value=\"override\"/>\n</bean>\n```\n\nparent bean 设置了 `abstract=\"true\"` 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。\n\nchild bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。\n\n当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。\n\n比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。\n\n```java\n<bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\">\n    <property name=\"name\" value=\"parent\"/>\n    <property name=\"age\" value=\"1\"/>\n</bean>\n```\n### 方法注入\n\n一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。\n\n但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。\n\n一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。\n\n另一种解决方案就是这里要介绍的通过使用 Lookup method。\n\n#### lookup-method\n\n我们来看一下 Spring Reference 中提供的一个例子：\n\n```java\npackage fiona.apple;\n\n// no more Spring imports!\n\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        // grab a new instance of the appropriate Command interface\n        Command command = createCommand();\n        // set the state on the (hopefully brand new) Command instance\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    // okay... but where is the implementation of this method?\n    protected abstract Command createCommand();\n}\n```\n\nxml 配置 `<lookup-method />`：\n\n```xml\n<!-- a stateful bean deployed as a prototype (non-singleton) -->\n<bean id=\"myCommand\" class=\"fiona.apple.AsyncCommand\" scope=\"prototype\">\n    <!-- inject dependencies here as required -->\n</bean>\n\n<!-- commandProcessor uses statefulCommandHelper -->\n<bean id=\"commandManager\" class=\"fiona.apple.CommandManager\">\n    <lookup-method name=\"createCommand\" bean=\"myCommand\"/>\n</bean>\n```\n\nSpring 采用 **CGLIB 生成字节码**的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。\n\nlookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 `<lookup-method />` 了，其他不变：\n\n```java\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup(\"myCommand\")\n    protected abstract Command createCommand();\n}\n```\n\n> 注意，既然用了注解，要配置注解扫描：`<context:component-scan base-package=\"com.javadoop\" />`\n\n甚至，我们可以像下面这样：\n\n```java\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup\n    protected abstract MyCommand createCommand();\n}\n```\n\n> 上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。\n\n#### replaced-method\n\n记住它的功能，就是替换掉 bean 中的一些方法。\n\n```java\npublic class MyValueCalculator {\n\n    public String computeValue(String input) {\n        // some real code...\n    }\n\n    // some other methods...\n}\n```\n\n方法覆写，注意要实现 MethodReplacer 接口：\n\n```java\npublic class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer {\n\n    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {\n        // get the input value, work with it, and return a computed result\n        String input = (String) args[0];\n        ...\n        return ...;\n    }\n}\n```\n\n配置也很简单：\n\n```xml\n<bean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\">\n    <!-- 定义 computeValue 这个方法要被替换掉 -->\n    <replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\">\n        <arg-type>String</arg-type>\n    </replaced-method>\n</bean>\n\n<bean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/>\n```\n\n> arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。\n\n### BeanPostProcessor\n\n应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：\n\n```java\npublic interface BeanPostProcessor {\n\n   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\n   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n\n}\n```\n\n看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。\n\n首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。\n\n我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。\n\n那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。\n\n最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？\n\n如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。\n\n首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。\n\n## 总结\n\n按理说，总结应该写在附录前面，我就不讲究了。\n\n在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。\n\n本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。\n\n（全文完）\n','<p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。</p>\n<p>本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。</p>\n<p>阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。</p>\n<p>希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。</p>\n<h2 id=\"引言\">引言</h2>\n<p>先看下最基本的启动 Spring 容器的例子：</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationfile.xml&quot;);\n}</code></pre>\n<p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n  &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<blockquote>\n<p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>\n</blockquote>\n<p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。</p>\n<p>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code> 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200520/967eae0f814441f6ae52d3b8d1e6116d.png\" alt=\"image.png\"></p>\n<blockquote>\n<p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。</p>\n<p>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p>\n</blockquote>\n<p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 <strong>FileSystemXmlApplicationContext</strong> 和 <strong>AnnotationConfigApplicationContext</strong> 这两个类。</p>\n<p><strong>1、FileSystemXmlApplicationContext</strong> 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p>\n<p><strong>2、AnnotationConfigApplicationContext</strong> 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p>\n<p>不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p>\n<p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p>\n<p>首先，定义一个接口：</p>\n<pre><code class=\"language-java\">public interface MessageService {\n    String getMessage();\n}</code></pre>\n<p>定义接口实现类：</p>\n<pre><code class=\"language-java\">public class MessageServiceImpl implements MessageService {\n\n    public String getMessage() {\n        return &quot;hello world&quot;;\n    }\n}</code></pre>\n<p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; default-autowire=&quot;byName&quot;&gt;\n\n    &lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;/&gt;\n&lt;/beans&gt;</code></pre>\n<p>这样，我们就可以跑起来了：</p>\n<pre><code class=\"language-java\">public class App {\n    public static void main(String[] args) {\n        // 用我们的配置文件来启动一个 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);\n\n        System.out.println(&quot;context 启动成功&quot;);\n\n        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式\n        MessageService messageService = context.getBean(MessageService.class);\n        // 这句将输出: hello world\n        System.out.println(messageService.getMessage());\n    }\n}</code></pre>\n<p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p>\n<h2 id=\"beanfactory-简介\">BeanFactory 简介</h2>\n<p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p>\n<p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200520/2de3ac3554d84c9eabff1d50eed3e5c8.png\" alt=\"image.png\"></p>\n<p>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p>\n<ol>\n<li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li>\n<li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li>\n<li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li>\n<li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li>\n<li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。</li>\n</ol>\n<p>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</p>\n<h2 id=\"启动过程分析\">启动过程分析</h2>\n<p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p>\n<p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p>\n<pre><code class=\"language-java\">public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {\n  private Resource[] configResources;\n\n  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法\n  public ClassPathXmlApplicationContext(ApplicationContext parent) {\n    super(parent);\n  }\n  ...\n  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)\n      throws BeansException {\n\n    super(parent);\n    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)\n    setConfigLocations(configLocations);\n    if (refresh) {\n      refresh(); // 核心方法\n    }\n  }\n    ...\n}</code></pre>\n<p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p>\n<p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p>\n<pre><code class=\"language-java\">@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n\n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n\n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(&quot;Exception encountered during context initialization - &quot; +\n                  &quot;cancelling refresh attempt: &quot; + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset &#39;active&#39; flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring&#39;s core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}</code></pre>\n<p>下面，我们开始一步步来肢解这个 refresh() 方法。</p>\n<h3 id=\"创建-bean-容器前的准备工作\">创建 Bean 容器前的准备工作</h3>\n<p>这个比较简单，直接看代码中的几个注释即可。</p>\n<pre><code class=\"language-java\">protected void prepareRefresh() {\n   // 记录启动时间，\n   // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型\n   this.startupDate = System.currentTimeMillis();\n   this.closed.set(false);\n   this.active.set(true);\n\n   if (logger.isInfoEnabled()) {\n      logger.info(&quot;Refreshing &quot; + this);\n   }\n\n   // Initialize any placeholder property sources in the context environment\n   initPropertySources();\n\n   // 校验 xml 配置文件\n   getEnvironment().validateRequiredProperties();\n\n   this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();\n}</code></pre>\n<h3 id=\"创建-bean-容器，加载并注册-bean\">创建 Bean 容器，加载并注册 Bean</h3>\n<p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p>\n<p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p>\n<p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p>\n<p>// AbstractApplicationContext.java</p>\n<pre><code class=\"language-java\">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等\n   refreshBeanFactory();\n\n   // 返回刚刚创建的 BeanFactory\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (logger.isDebugEnabled()) {\n      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);\n   }\n   return beanFactory;\n}</code></pre>\n<p>// AbstractRefreshableApplicationContext.java 120</p>\n<pre><code class=\"language-java\">@Override\nprotected final void refreshBeanFactory() throws BeansException {\n   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory\n   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前\n   // ApplicationContext 是否有 BeanFactory\n   if (hasBeanFactory()) {\n      destroyBeans();\n      closeBeanFactory();\n   }\n   try {\n      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。\n      DefaultListableBeanFactory beanFactory = createBeanFactory();\n      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到\n      beanFactory.setSerializationId(getId());\n\n      // 下面这两个方法很重要，别跟丢了，具体细节之后说\n      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用\n      customizeBeanFactory(beanFactory);\n\n      // 加载 Bean 到 BeanFactory 中\n      loadBeanDefinitions(beanFactory);\n      synchronized (this.beanFactoryMonitor) {\n         this.beanFactory = beanFactory;\n      }\n   }\n   catch (IOException ex) {\n      throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);\n   }\n}</code></pre>\n<blockquote>\n<p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>\n</blockquote>\n<p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200520/cbfc0b05edac444098b395de90f5e463.png\" alt=\"image.png\"></p>\n<p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p>\n<blockquote>\n<p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？</p>\n<p>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。</p>\n<p>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。</p>\n</blockquote>\n<p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p>\n<p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p>\n<p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p>\n<blockquote>\n<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>\n</blockquote>\n<h4 id=\"beandefinition-接口定义\">BeanDefinition 接口定义</h4>\n<p>我们来看下 BeanDefinition 的接口定义：</p>\n<pre><code class=\"language-java\">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {\n\n   // 我们可以看到，默认只提供 sington 和 prototype 两种，\n   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，\n   // 不过，它们属于基于 web 的扩展。\n   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;\n   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;\n\n   // 比较不重要，直接跳过吧\n   int ROLE_APPLICATION = 0;\n   int ROLE_SUPPORT = 1;\n   int ROLE_INFRASTRUCTURE = 2;\n\n   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍\n   // 一句话就是：继承父 Bean 的配置信息而已\n   void setParentName(String parentName);\n\n   // 获取父 Bean\n   String getParentName();\n\n   // 设置 Bean 的类名称，将来是要通过反射来生成实例的\n   void setBeanClassName(String beanClassName);\n\n   // 获取 Bean 的类名称\n   String getBeanClassName();\n\n\n   // 设置 bean 的 scope\n   void setScope(String scope);\n\n   String getScope();\n\n   // 设置是否懒加载\n   void setLazyInit(boolean lazyInit);\n\n   boolean isLazyInit();\n\n   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，\n   // 是 depends-on=&quot;&quot; 属性设置的值。\n   void setDependsOn(String... dependsOn);\n\n   // 返回该 Bean 的所有依赖\n   String[] getDependsOn();\n\n   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，\n   // 如果根据名称注入，即使这边设置了 false，也是可以的\n   void setAutowireCandidate(boolean autowireCandidate);\n\n   // 该 Bean 是否可以注入到其他 Bean 中\n   boolean isAutowireCandidate();\n\n   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean\n   void setPrimary(boolean primary);\n\n   // 是否是 primary 的\n   boolean isPrimary();\n\n   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录\n   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的\n   void setFactoryBeanName(String factoryBeanName);\n   // 获取工厂名称\n   String getFactoryBeanName();\n   // 指定工厂类中的 工厂方法名称\n   void setFactoryMethodName(String factoryMethodName);\n   // 获取工厂类中的 工厂方法名称\n   String getFactoryMethodName();\n\n   // 构造器参数\n   ConstructorArgumentValues getConstructorArgumentValues();\n\n   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到\n   MutablePropertyValues getPropertyValues();\n\n   // 是否 singleton\n   boolean isSingleton();\n\n   // 是否 prototype\n   boolean isPrototype();\n\n   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，\n   // 常用于作为 父bean 用于继承，其实也很少用......\n   boolean isAbstract();\n\n   int getRole();\n   String getDescription();\n   String getResourceDescription();\n   BeanDefinition getOriginatingBeanDefinition();\n}</code></pre>\n<blockquote>\n<p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。</p>\n<p>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p>\n</blockquote>\n<p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p>\n<pre><code class=\"language-java\">customizeBeanFactory(beanFactory);\nloadBeanDefinitions(beanFactory);</code></pre>\n<p>虽然只有两个方法，但路还很长啊。。。</p>\n<h4 id=\"customizebeanfactory\">customizeBeanFactory</h4>\n<p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p>\n<pre><code class=\"language-java\">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n   if (this.allowBeanDefinitionOverriding != null) {\n      // 是否允许 Bean 定义覆盖\n      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n   }\n   if (this.allowCircularReferences != null) {\n      // 是否允许 Bean 间的循环依赖\n      beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n   }\n}</code></pre>\n<p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>\n<p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>\n<p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p>\n<p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p>\n<p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p>\n<h4 id=\"加载-bean-loadbeandefinitions\">加载 Bean: loadBeanDefinitions</h4>\n<p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p>\n<p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p>\n<p>// AbstractXmlApplicationContext.java 80</p>\n<pre><code class=\"language-java\">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/\n@Override\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader\n   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\n   // Configure the bean definition reader with this context&#39;s\n   // resource loading environment.\n   beanDefinitionReader.setEnvironment(this.getEnvironment());\n   beanDefinitionReader.setResourceLoader(this);\n   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，\n   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧\n   initBeanDefinitionReader(beanDefinitionReader);\n   // 重点来了，继续往下\n   loadBeanDefinitions(beanDefinitionReader);\n}</code></pre>\n<p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p>\n<p>// AbstractXmlApplicationContext.java 120</p>\n<pre><code class=\"language-java\">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n   Resource[] configResources = getConfigResources();\n   if (configResources != null) {\n      // 往下看\n      reader.loadBeanDefinitions(configResources);\n   }\n   String[] configLocations = getConfigLocations();\n   if (configLocations != null) {\n      // 2\n      reader.loadBeanDefinitions(configLocations);\n   }\n}\n\n// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里\n@Override\npublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {\n   Assert.notNull(resources, &quot;Resource array must not be null&quot;);\n   int counter = 0;\n   // 注意这里是个 for 循环，也就是每个文件是一个 resource\n   for (Resource resource : resources) {\n      // 继续往下看\n      counter += loadBeanDefinitions(resource);\n   }\n   // 最后返回 counter，表示总共加载了多少的 BeanDefinition\n   return counter;\n}\n\n// XmlBeanDefinitionReader 303\n@Override\npublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n   return loadBeanDefinitions(new EncodedResource(resource));\n}\n\n// XmlBeanDefinitionReader 314\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n   Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);\n   if (logger.isInfoEnabled()) {\n      logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());\n   }\n   // 用一个 ThreadLocal 来存放配置文件资源\n   Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();\n   if (currentResources == null) {\n      currentResources = new HashSet&lt;EncodedResource&gt;(4);\n      this.resourcesCurrentlyBeingLoaded.set(currentResources);\n   }\n   if (!currentResources.add(encodedResource)) {\n      throw new BeanDefinitionStoreException(\n            &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);\n   }\n   try {\n      InputStream inputStream = encodedResource.getResource().getInputStream();\n      try {\n         InputSource inputSource = new InputSource(inputStream);\n         if (encodedResource.getEncoding() != null) {\n            inputSource.setEncoding(encodedResource.getEncoding());\n         }\n         // 核心部分是这里，往下面看\n         return doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n      }\n      finally {\n         inputStream.close();\n      }\n   }\n   catch (IOException ex) {\n      throw new BeanDefinitionStoreException(\n            &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);\n   }\n   finally {\n      currentResources.remove(encodedResource);\n      if (currentResources.isEmpty()) {\n         this.resourcesCurrentlyBeingLoaded.remove();\n      }\n   }\n}\n\n// 还在这个文件中，第 388 行\nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n      throws BeanDefinitionStoreException {\n   try {\n      // 这里就不看了，将 xml 文件转换为 Document 对象\n      Document doc = doLoadDocument(inputSource, resource);\n      // 继续\n      return registerBeanDefinitions(doc, resource);\n   }\n   catch (...\n}\n// 还在这个文件中，第 505 行\n// 返回值：返回从当前配置文件加载了多少数量的 Bean\npublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n   int countBefore = getRegistry().getBeanDefinitionCount();\n   // 这里\n   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n   return getRegistry().getBeanDefinitionCount() - countBefore;\n}\n// DefaultBeanDefinitionDocumentReader 90\n@Override\npublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n   this.readerContext = readerContext;\n   logger.debug(&quot;Loading bean definitions&quot;);\n   Element root = doc.getDocumentElement();\n   // 从 xml 根节点开始解析文件\n   doRegisterBeanDefinitions(root);\n}         </code></pre>\n<p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p>\n<h5 id=\"doregisterbeandefinitions：\">doRegisterBeanDefinitions：</h5>\n<pre><code class=\"language-java\">// DefaultBeanDefinitionDocumentReader 116\nprotected void doRegisterBeanDefinitions(Element root) {\n   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，\n   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，\n   // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了\n   BeanDefinitionParserDelegate parent = this.delegate;\n   this.delegate = createDelegate(getReaderContext(), root, parent);\n\n   if (this.delegate.isDefaultNamespace(root)) {\n      // 这块说的是根节点 &lt;beans ... profile=&quot;dev&quot; /&gt; 中的 profile 是否是当前环境需要的，\n      // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析\n      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区\n      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n      if (StringUtils.hasText(profileSpec)) {\n         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n         if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n            if (logger.isInfoEnabled()) {\n               logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +\n                     &quot;] not matching: &quot; + getReaderContext().getResource());\n            }\n            return;\n         }\n      }\n   }\n\n   preProcessXml(root); // 钩子\n   // 往下看\n   parseBeanDefinitions(root, this.delegate);\n   postProcessXml(root); // 钩子\n\n   this.delegate = parent;\n}</code></pre>\n<p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p>\n<p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p>\n<p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p>\n<pre><code class=\"language-java\">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，\n// 其他的属于 custom 的\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n   if (delegate.isDefaultNamespace(root)) {\n      NodeList nl = root.getChildNodes();\n      for (int i = 0; i &lt; nl.getLength(); i++) {\n         Node node = nl.item(i);\n         if (node instanceof Element) {\n            Element ele = (Element) node;\n            if (delegate.isDefaultNamespace(ele)) {\n               // 解析 default namespace 下面的几个元素\n               parseDefaultElement(ele, delegate);\n            }\n            else {\n               // 解析其他 namespace 的元素\n               delegate.parseCustomElement(ele);\n            }\n         }\n      }\n   }\n   else {\n      delegate.parseCustomElement(root);\n   }\n}</code></pre>\n<p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p>\n<p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;beans /&gt;</code> 这几个。</p>\n<blockquote>\n<p>这里的四个标签之所以是 <strong>default</strong> 的，是因为它们是处于这个 namespace 下定义的：</p>\n<pre><code>http://www.springframework.org/schema/beans</code></pre><p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 <strong>xmlns</strong> 就是咯。</p>\n<pre><code class=\"language-xml\">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xsi:schemaLocation=&quot;\n            http://www.springframework.org/schema/beans\n          http://www.springframework.org/schema/beans/spring-beans.xsd&quot;\n       default-autowire=&quot;byName&quot;&gt;</code></pre>\n<p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code>&lt;mvc /&gt;</code>、<code>&lt;task /&gt;</code>、<code>&lt;context /&gt;</code>、<code>&lt;aop /&gt;</code>等。</p>\n<p>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。</p>\n<p>假如读者想分析 <code>&lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt;</code> 的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p>\n<pre><code class=\"language-xml\">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n      xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n      xsi:schemaLocation=&quot;\n           http://www.springframework.org/schema/beans \n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/context\n           http://www.springframework.org/schema/context/spring-context.xsd\n           http://www.springframework.org/schema/mvc   \n           http://www.springframework.org/schema/mvc/spring-mvc.xsd  \n       &quot;\n      default-autowire=&quot;byName&quot;&gt;</code></pre>\n<p>同理，以后你要是碰到 <code>&lt;dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。</p>\n</blockquote>\n<p>回过神来，看看处理 default 标签的方法：</p>\n<pre><code class=\"language-java\">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n      // 处理 &lt;import /&gt; 标签\n      importBeanDefinitionResource(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n      // 处理 &lt;alias /&gt; 标签定义\n      // &lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;\n      processAliasRegistration(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n      // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧\n      processBeanDefinition(ele, delegate);\n   }\n   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n      // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归\n      doRegisterBeanDefinitions(ele);\n   }\n}</code></pre>\n<p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <code>&lt;bean /&gt;</code> 标签出来说。</p>\n<h5 id=\"processbeandefinition-解析-bean-标签\">processBeanDefinition 解析 bean 标签</h5>\n<p>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p>\n<p>// DefaultBeanDefinitionDocumentReader 298</p>\n<pre><code class=\"language-java\">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\n   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的\n\n   if (bdHolder != null) {\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // Register the final decorated instance.\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +\n               bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n      }\n      // Send registration event.\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}</code></pre>\n<p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>class</td>\n<td>类的全限定名</td>\n</tr>\n<tr>\n<td>name</td>\n<td>可指定 id、name(用逗号、分号、空格分隔)</td>\n</tr>\n<tr>\n<td>scope</td>\n<td>作用域</td>\n</tr>\n<tr>\n<td>constructor arguments</td>\n<td>指定构造参数</td>\n</tr>\n<tr>\n<td>properties</td>\n<td>设置属性的值</td>\n</tr>\n<tr>\n<td>autowiring mode</td>\n<td>no(默认值)、byName、byType、 constructor</td>\n</tr>\n<tr>\n<td>lazy-initialization mode</td>\n<td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td>\n</tr>\n<tr>\n<td>initialization method</td>\n<td>bean 属性设置完成后，会调用这个方法</td>\n</tr>\n<tr>\n<td>destruction method</td>\n<td>bean 销毁后的回调方法</td>\n</tr>\n</tbody></table>\n<p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p>\n<p>简单地说就是像下面这样子：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;exampleBean&quot; name=&quot;name1, name2, name3&quot; class=&quot;com.javadoop.ExampleBean&quot;\n      scope=&quot;singleton&quot; lazy-init=&quot;true&quot; init-method=&quot;init&quot; destroy-method=&quot;cleanup&quot;&gt;\n\n    &lt;!-- 可以用下面三种形式指定构造参数 --&gt;\n    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;\n    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;\n    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;\n\n    &lt;!-- property 的几种情况 --&gt;\n    &lt;property name=&quot;beanOne&quot;&gt;\n        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt;\n    &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;</code>、<code>&lt;replaced-method /&gt;</code>、<code>&lt;meta /&gt;</code>、<code>&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p>\n<p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p>\n<p>// BeanDefinitionParserDelegate 428</p>\n<pre><code class=\"language-java\">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {\n    return parseBeanDefinitionElement(ele, null);\n}\n\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {\n   String id = ele.getAttribute(ID_ATTRIBUTE);\n   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n   List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();\n\n   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，\n   // 当然，如果你不定义 name 属性的话，就是空的了\n   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了\n   if (StringUtils.hasLength(nameAttr)) {\n      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n      aliases.addAll(Arrays.asList(nameArr));\n   }\n\n   String beanName = id;\n   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName\n   if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {\n      beanName = aliases.remove(0);\n      if (logger.isDebugEnabled()) {\n         logger.debug(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +\n               &quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);\n      }\n   }\n\n   if (containingBean == null) {\n      checkNameUniqueness(beanName, aliases, ele);\n   }\n\n   // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,\n   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。\n   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n\n   // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。\n   if (beanDefinition != null) {\n      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生\n      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要\n      if (!StringUtils.hasText(beanName)) {\n         try {\n            if (containingBean != null) {// 按照我们的思路，这里 containingBean 是 null 的\n               beanName = BeanDefinitionReaderUtils.generateBeanName(\n                     beanDefinition, this.readerContext.getRegistry(), true);\n            }\n            else {\n               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：\n               //   1. beanName 为：com.javadoop.example.MessageServiceImpl#0\n               //   2. beanClassName 为：com.javadoop.example.MessageServiceImpl\n\n               beanName = this.readerContext.generateBeanName(beanDefinition);\n\n               String beanClassName = beanDefinition.getBeanClassName();\n               if (beanClassName != null &amp;&amp;\n                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;\n                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n                  // 把 beanClassName 设置为 Bean 的别名\n                  aliases.add(beanClassName);\n               }\n            }\n            if (logger.isDebugEnabled()) {\n               logger.debug(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +\n                     &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);\n            }\n         }\n         catch (Exception ex) {\n            error(ex.getMessage(), ele);\n            return null;\n         }\n      }\n      String[] aliasesArray = StringUtils.toStringArray(aliases);\n      // 返回 BeanDefinitionHolder\n      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n   }\n\n   return null;\n}</code></pre>\n<p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p>\n<pre><code class=\"language-java\">public AbstractBeanDefinition parseBeanDefinitionElement(\n      Element ele, String beanName, BeanDefinition containingBean) {\n\n   this.parseState.push(new BeanEntry(beanName));\n\n   String className = null;\n   if (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n   }\n\n   try {\n      String parent = null;\n      if (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n         parent = ele.getAttribute(PARENT_ATTRIBUTE);\n      }\n      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了\n      AbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中\n      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n      /**\n       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，\n       * 解析出来以后的信息都放到 bd 的属性中\n       */\n\n      // 解析 &lt;meta /&gt;\n      parseMetaElements(ele, bd);\n      // 解析 &lt;lookup-method /&gt;\n      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n      // 解析 &lt;replaced-method /&gt;\n      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n    // 解析 &lt;constructor-arg /&gt;\n      parseConstructorArgElements(ele, bd);\n      // 解析 &lt;property /&gt;\n      parsePropertyElements(ele, bd);\n      // 解析 &lt;qualifier /&gt;\n      parseQualifierElements(ele, bd);\n\n      bd.setResource(this.readerContext.getResource());\n      bd.setSource(extractSource(ele));\n\n      return bd;\n   }\n   catch (ClassNotFoundException ex) {\n      error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);\n   }\n   catch (NoClassDefFoundError err) {\n      error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);\n   }\n   catch (Throwable ex) {\n      error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);\n   }\n   finally {\n      this.parseState.pop();\n   }\n\n   return null;\n}</code></pre>\n<p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p>\n<p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p>\n<pre><code class=\"language-java\">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n   if (bdHolder != null) {\n      // 如果有自定义属性的话，进行相应的解析，先忽略\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // 我们把这步叫做 注册Bean 吧\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +\n               bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n      }\n      // 注册完成后，发送事件，本文不展开说这个\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}</code></pre>\n<p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p>\n<pre><code class=\"language-java\">public class BeanDefinitionHolder implements BeanMetadataElement {\n\n  private final BeanDefinition beanDefinition;\n\n  private final String beanName;\n\n  private final String[] aliases;\n...</code></pre>\n<p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p>\n<p>下面，我们开始说说注册 Bean 吧。</p>\n<h5 id=\"注册-bean\">注册 Bean</h5>\n<p>// BeanDefinitionReaderUtils 143</p>\n<pre><code class=\"language-java\">public static void registerBeanDefinition(\n      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n      throws BeanDefinitionStoreException {\n\n   String beanName = definitionHolder.getBeanName();\n   // 注册这个 Bean\n   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n\n   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了\n   String[] aliases = definitionHolder.getAliases();\n   if (aliases != null) {\n      for (String alias : aliases) {\n         // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，\n         // 获取的时候，会先将 alias 转换为 beanName，然后再查找\n         registry.registerAlias(beanName, alias);\n      }\n   }\n}</code></pre>\n<p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p>\n<p>// DefaultListableBeanFactory 793</p>\n<pre><code class=\"language-java\">@Override\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n      throws BeanDefinitionStoreException {\n\n   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);\n   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);\n\n   if (beanDefinition instanceof AbstractBeanDefinition) {\n      try {\n         ((AbstractBeanDefinition) beanDefinition).validate();\n      }\n      catch (BeanDefinitionValidationException ex) {\n         throw new BeanDefinitionStoreException(...);\n      }\n   }\n\n   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding\n   BeanDefinition oldBeanDefinition;\n\n   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中\n   oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n\n   // 处理重复名称的 Bean 定义的情况\n   if (oldBeanDefinition != null) {\n      if (!isAllowBeanDefinitionOverriding()) {\n         // 如果不允许覆盖的话，抛异常\n         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...\n      }\n      else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) {\n         // log...用框架定义的 Bean 覆盖用户自定义的 Bean \n      }\n      else if (!beanDefinition.equals(oldBeanDefinition)) {\n         // log...用新的 Bean 覆盖旧的 Bean\n      }\n      else {\n         // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean\n      }\n      // 覆盖\n      this.beanDefinitionMap.put(beanName, beanDefinition);\n   }\n   else {\n      // 判断是否已经有其他的 Bean 开始初始化了.\n      // 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，\n      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans\n      if (hasBeanCreationStarted()) {\n         // Cannot modify startup-time collection elements anymore (for stable iteration)\n         synchronized (this.beanDefinitionMap) {\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);\n            updatedDefinitions.addAll(this.beanDefinitionNames);\n            updatedDefinitions.add(beanName);\n            this.beanDefinitionNames = updatedDefinitions;\n            if (this.manualSingletonNames.contains(beanName)) {\n               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);\n               updatedSingletons.remove(beanName);\n               this.manualSingletonNames = updatedSingletons;\n            }\n         }\n      }\n      else {\n         // 最正常的应该是进到这个分支。\n\n         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition\n         this.beanDefinitionMap.put(beanName, beanDefinition);\n         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字\n         this.beanDefinitionNames.add(beanName);\n         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，\n         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的\n         // 手动指的是通过调用以下方法注册的 bean ：\n         //     registerSingleton(String beanName, Object singletonObject)\n         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，\n         // 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的\n         this.manualSingletonNames.remove(beanName);\n      }\n      // 这个不重要，在预初始化的时候会用到，不必管它。\n      this.frozenBeanDefinitionNames = null;\n   }\n\n   if (oldBeanDefinition != null || containsSingleton(beanName)) {\n      resetBeanDefinition(beanName);\n   }\n}</code></pre>\n<p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>\n<p>--------- 分割线 ---------</p>\n<p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p>\n<h3 id=\"bean-容器实例化完成后\">Bean 容器实例化完成后</h3>\n<p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p>\n<p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p>\n<pre><code class=\"language-java\">@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n\n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n\n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法\n         invokeBeanFactoryPostProcessors(beanFactory);          \n\n\n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成，不展开\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(&quot;Exception encountered during context initialization - &quot; +\n                  &quot;cancelling refresh attempt: &quot; + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset &#39;active&#39; flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring&#39;s core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}</code></pre>\n<h3 id=\"准备-bean-容器-preparebeanfactory\">准备 Bean 容器: prepareBeanFactory</h3>\n<p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会&quot;手动&quot;注册一些特殊的 bean。</p>\n<p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p>\n<pre><code class=\"language-java\">/**\n * Configure the factory&#39;s standard context characteristics,\n * such as the context&#39;s ClassLoader and post-processors.\n * @param beanFactory the BeanFactory to configure\n */\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，\n   // 这里设置为加载当前 ApplicationContext 类的类加载器\n   beanFactory.setBeanClassLoader(getClassLoader());\n\n   // 设置 BeanExpressionResolver\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n   // \n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // 添加一个 BeanPostProcessor，这个 processor 比较简单：\n   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，\n   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware\n   // 注意：它不仅仅回调 ApplicationContextAware，\n   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\n   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，\n   // Spring 会通过其他方式来处理这些依赖。\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   /**\n    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，\n    * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行。\n    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource\n    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext\n    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean\n    */\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，\n   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器\n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它\n   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，\n   //    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj\n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   /**\n    * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean，\n    * 我们也可以选择覆盖\n    */\n\n   // 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个\n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n   // 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n   // 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}</code></pre>\n<p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p>\n<h3 id=\"初始化所有的-singleton-beans\">初始化所有的 singleton beans</h3>\n<p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p>\n<p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p>\n<p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p>\n<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p>\n<p>// AbstractApplicationContext.java 834</p>\n<pre><code class=\"language-java\">// 初始化剩余的 singleton beans\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n\n   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了\n   // 什么，看代码这里没有初始化 Bean 啊！\n   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧\n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n\n   // Register a default embedded value resolver if no bean post-processor\n   // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n   // at this point, primarily for resolution in annotation attribute values.\n   if (!beanFactory.hasEmbeddedValueResolver()) {\n      beanFactory.addEmbeddedValueResolver(new StringValueResolver() {\n         @Override\n         public String resolveStringValue(String strVal) {\n            return getEnvironment().resolvePlaceholders(strVal);\n         }\n      });\n   }\n\n   // 先初始化 LoadTimeWeaverAware 类型的 Bean\n   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧\n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n   for (String weaverAwareName : weaverAwareNames) {\n      getBean(weaverAwareName);\n   }\n\n   // Stop using the temporary ClassLoader for type matching.\n   beanFactory.setTempClassLoader(null);\n\n   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，\n   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。\n   beanFactory.freezeConfiguration();\n\n   // 开始初始化\n   beanFactory.preInstantiateSingletons();\n}</code></pre>\n<p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p>\n<h4 id=\"preinstantiatesingletons\">preInstantiateSingletons</h4>\n<p>// DefaultListableBeanFactory 728</p>\n<pre><code class=\"language-java\">@Override\npublic void preInstantiateSingletons() throws BeansException {\n   if (this.logger.isDebugEnabled()) {\n      this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);\n   }\n   // this.beanDefinitionNames 保存了所有的 beanNames\n   List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);\n\n   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作\n   for (String beanName : beanNames) {\n\n      // 合并父 Bean 中的配置，注意 &lt;bean id=&quot;&quot; class=&quot;&quot; parent=&quot;&quot; /&gt; 中的 parent，用的不多吧，\n      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 &quot;Bean 继承&quot;，不了解的请到附录中看一下\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\n      // 非抽象、非懒加载的 singletons。如果配置了 &#39;abstract = true&#39;，那是不需要初始化的\n      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {\n         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)\n         if (isFactoryBean(beanName)) {\n            // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急\n            final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);\n            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过\n            boolean isEagerInit;\n            if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {\n               isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {\n                  @Override\n                  public Boolean run() {\n                     return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();\n                  }\n               }, getAccessControlContext());\n            }\n            else {\n               isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;\n                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());\n            }\n            if (isEagerInit) {\n\n               getBean(beanName);\n            }\n         }\n         else {\n            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了\n            getBean(beanName);\n         }\n      }\n   }\n\n   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化\n   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略\n   for (String beanName : beanNames) {\n      Object singletonInstance = getSingleton(beanName);\n      if (singletonInstance instanceof SmartInitializingSingleton) {\n         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n         if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {\n               @Override\n               public Object run() {\n                  smartSingleton.afterSingletonsInstantiated();\n                  return null;\n               }\n            }, getAccessControlContext());\n         }\n         else {\n            smartSingleton.afterSingletonsInstantiated();\n         }\n      }\n   }\n}</code></pre>\n<p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p>\n<h4 id=\"getbean\">getBean</h4>\n<p>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p>\n<p>// AbstractBeanFactory 196</p>\n<pre><code class=\"language-java\">@Override\npublic Object getBean(String name) throws BeansException {\n   return doGetBean(name, null, null, false);\n}\n\n// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，\n// 已经初始化过了就从容器中直接返回，否则就先初始化再返回\n@SuppressWarnings(&quot;unchecked&quot;)\nprotected &lt;T&gt; T doGetBean(\n      final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)\n      throws BeansException {\n   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，\n   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的\n   final String beanName = transformedBeanName(name);\n\n   // 注意跟着这个，这个是返回值\n   Object bean; \n\n   // 检查下是不是已经创建过了\n   Object sharedInstance = getSingleton(beanName);\n\n   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，\n   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean\n   if (sharedInstance != null &amp;&amp; args == null) {\n      if (logger.isDebugEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.debug(&quot;...&quot;);\n         }\n         else {\n            logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n         }\n      }\n      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，\n      // 如果是 FactoryBean 的话，返回它创建的那个实例对象\n      // (FactoryBean 知识，读者若不清楚请移步附录)\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   }\n\n   else {\n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，\n         // 往往是因为陷入了循环引用\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // 检查一下这个 BeanDefinition 在容器中是否存在\n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有\n         String nameToLookup = originalBeanName(name);\n         if (args != null) {\n            // 返回父容器的查询结果\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         }\n         else {\n            // No args -&gt; delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         }\n      }\n\n      if (!typeCheckOnly) {\n         // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。\n         markBeanAsCreated(beanName);\n      }\n\n      /*\n       * 稍稍总结一下：\n       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；\n       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。\n       */\n      try {\n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n         checkMergedBeanDefinition(mbd, beanName, args);\n\n         // 先初始化依赖的所有 Bean，这个很好理解。\n         // 注意，这里的依赖指的是 depends-on 中定义的依赖\n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\n               }\n               // 注册一下依赖关系\n               registerDependentBean(dep, beanName);\n               // 先初始化被依赖项\n               getBean(dep);\n            }\n         }\n\n         // 如果是 singleton scope 的，创建 singleton 的实例\n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {\n               @Override\n               public Object getObject() throws BeansException {\n                  try {\n                     // 执行创建 Bean，详情后面再说\n                     return createBean(beanName, mbd, args);\n                  }\n                  catch (BeansException ex) {\n                     destroySingleton(beanName);\n                     throw ex;\n                  }\n               }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         }\n\n         // 如果是 prototype scope 的，创建 prototype 的实例\n         else if (mbd.isPrototype()) {\n            // It&#39;s a prototype -&gt; create a new instance.\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               // 执行创建 Bean\n               prototypeInstance = createBean(beanName, mbd, args);\n            }\n            finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         }\n\n         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理\n         else {\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);\n            }\n            try {\n               Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() {\n                  @Override\n                  public Object getObject() throws BeansException {\n                     beforePrototypeCreation(beanName);\n                     try {\n                        // 执行创建 Bean\n                        return createBean(beanName, mbd, args);\n                     }\n                     finally {\n                        afterPrototypeCreation(beanName);\n                     }\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            }\n            catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +\n                     &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,\n                     ex);\n            }\n         }\n      }\n      catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n\n   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了\n   if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) {\n      try {\n         return getTypeConverter().convertIfNecessary(bean, requiredType);\n      }\n      catch (TypeMismatchException ex) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +\n                  ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n      }\n   }\n   return (T) bean;\n}</code></pre>\n<p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p>\n<pre><code class=\"language-java\">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;</code></pre>\n<p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p>\n<p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p>\n<p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p>\n<pre><code class=\"language-java\">public class MessageServiceImpl implements MessageService {\n    @Autowired\n    private UserService userService;\n\n    public String getMessage() {\n        return userService.getMessage();\n    }\n}</code></pre>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt;</code></pre>\n<p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p>\n<p>好了，读者要知道这么回事就可以了，继续向前。</p>\n<p>// AbstractAutowireCapableBeanFactory 447</p>\n<pre><code class=\"language-java\">/**\n * Central method of this class: creates a bean instance,\n * populates the bean instance, applies post-processors, etc.\n * @see #doCreateBean\n */\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {\n   if (logger.isDebugEnabled()) {\n      logger.debug(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n   }\n   RootBeanDefinition mbdToUse = mbd;\n\n   // 确保 BeanDefinition 中的 Class 被加载\n   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);\n   if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {\n      mbdToUse = new RootBeanDefinition(mbd);\n      mbdToUse.setBeanClass(resolvedClass);\n   }\n\n   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; \n   // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。\n   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看\n   try {\n      mbdToUse.prepareMethodOverrides();\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n            beanName, &quot;Validation of method overrides failed&quot;, ex);\n   }\n\n   try {\n      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，\n      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过\n      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n      if (bean != null) {\n         return bean; \n      }\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n            &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);\n   }\n   // 重头戏，创建 bean\n   Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n   if (logger.isDebugEnabled()) {\n      logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n   }\n   return beanInstance;\n}</code></pre>\n<h4 id=\"创建-bean\">创建 Bean</h4>\n<p>我们继续往里看 doCreateBean 这个方法：</p>\n<pre><code class=\"language-java\">/**\n * Actually create the specified bean. Pre-creation processing has already happened\n * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n * &lt;p&gt;Differentiates between default bean instantiation, use of a\n * factory method, and autowiring a constructor.\n * @param beanName the name of the bean\n * @param mbd the merged bean definition for the bean\n * @param args explicit arguments to use for constructor or factory method invocation\n * @return a new instance of the bean\n * @throws BeanCreationException if the bean could not be created\n * @see #instantiateBean\n * @see #instantiateUsingFactoryMethod\n * @see #autowireConstructor\n */\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)\n      throws BeanCreationException {\n\n   // Instantiate the bean.\n   BeanWrapper instanceWrapper = null;\n   if (mbd.isSingleton()) {\n      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n   }\n   if (instanceWrapper == null) {\n      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说\n      instanceWrapper = createBeanInstance(beanName, mbd, args);\n   }\n   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 &quot;bean 实例&quot;\n   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);\n   // 类型\n   Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);\n   mbd.resolvedTargetType = beanType;\n\n   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor\n   synchronized (mbd.postProcessingLock) {\n      if (!mbd.postProcessed) {\n         try {\n            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的\n            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n         }\n         catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                  &quot;Post-processing of merged bean definition failed&quot;, ex);\n         }\n         mbd.postProcessed = true;\n      }\n   }\n\n   // Eagerly cache singletons to be able to resolve circular references\n   // even when triggered by lifecycle interfaces like BeanFactoryAware.\n   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧\n   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;\n         isSingletonCurrentlyInCreation(beanName));\n   if (earlySingletonExposure) {\n      if (logger.isDebugEnabled()) {\n         logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +\n               &quot;&#39; to allow for resolving potential circular references&quot;);\n      }\n      addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() {\n         @Override\n         public Object getObject() throws BeansException {\n            return getEarlyBeanReference(beanName, mbd, bean);\n         }\n      });\n   }\n\n   // Initialize the bean instance.\n   Object exposedObject = bean;\n   try {\n      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值\n      populateBean(beanName, mbd, instanceWrapper);\n      if (exposedObject != null) {\n         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？\n         // 这里就是处理 bean 初始化完成后的各种回调\n         exposedObject = initializeBean(beanName, exposedObject, mbd);\n      }\n   }\n   catch (Throwable ex) {\n      if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {\n         throw (BeanCreationException) ex;\n      }\n      else {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);\n      }\n   }\n\n   if (earlySingletonExposure) {\n      // \n      Object earlySingletonReference = getSingleton(beanName, false);\n      if (earlySingletonReference != null) {\n         if (exposedObject == bean) {\n            exposedObject = earlySingletonReference;\n         }\n         else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {\n            String[] dependentBeans = getDependentBeans(beanName);\n            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);\n            for (String dependentBean : dependentBeans) {\n               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                  actualDependentBeans.add(dependentBean);\n               }\n            }\n            if (!actualDependentBeans.isEmpty()) {\n               throw new BeanCurrentlyInCreationException(beanName,\n                     &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +\n                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                     &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +\n                     &quot;wrapped. This means that said other beans do not use the final version of the &quot; +\n                     &quot;bean. This is often the result of over-eager type matching - consider using &quot; +\n                     &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);\n            }\n         }\n      }\n   }\n\n   // Register bean as disposable.\n   try {\n      registerDisposableBeanIfNecessary(beanName, bean, mbd);\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);\n   }\n\n   return exposedObject;\n}</code></pre>\n<p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p>\n<p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 </p>\n<p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p>\n<h5 id=\"创建-bean-实例\">创建 Bean 实例</h5>\n<p>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p>\n<pre><code class=\"language-java\">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {\n   // 确保已经加载了此 class\n   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);\n\n   // 校验一下这个类的访问权限\n   if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {\n      throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n            &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());\n   }\n\n   if (mbd.getFactoryMethodName() != null)  {\n      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean\n      return instantiateUsingFactoryMethod(beanName, mbd, args);\n   }\n\n   // 如果不是第一次创建，比如第二次创建 prototype bean。\n   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化\n   boolean resolved = false;\n   boolean autowireNecessary = false;\n   if (args == null) {\n      synchronized (mbd.constructorArgumentLock) {\n         if (mbd.resolvedConstructorOrFactoryMethod != null) {\n            resolved = true;\n            autowireNecessary = mbd.constructorArgumentsResolved;\n         }\n      }\n   }\n   if (resolved) {\n      if (autowireNecessary) {\n         // 构造函数依赖注入\n         return autowireConstructor(beanName, mbd, null, null);\n      }\n      else {\n         // 无参构造函数\n         return instantiateBean(beanName, mbd);\n      }\n   }\n\n   // 判断是否采用有参构造函数\n   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n   if (ctors != null ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n      // 构造函数依赖注入\n      return autowireConstructor(beanName, mbd, ctors, args);\n   }\n\n   // 调用无参构造函数\n   return instantiateBean(beanName, mbd);\n}</code></pre>\n<p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p>\n<pre><code class=\"language-java\">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n   try {\n      Object beanInstance;\n      final BeanFactory parent = this;\n      if (System.getSecurityManager() != null) {\n         beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {\n            @Override\n            public Object run() {\n\n               return getInstantiationStrategy().instantiate(mbd, beanName, parent);\n            }\n         }, getAccessControlContext());\n      }\n      else {\n         // 实例化\n         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);\n      }\n      // 包装一下，返回\n      BeanWrapper bw = new BeanWrapperImpl(beanInstance);\n      initBeanWrapper(bw);\n      return bw;\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);\n   }\n}</code></pre>\n<p>我们可以看到，关键的地方在于：</p>\n<pre><code class=\"language-java\">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</code></pre>\n<p>这里会进行实际的实例化过程，我们进去看看:</p>\n<p>// SimpleInstantiationStrategy 59</p>\n<pre><code class=\"language-java\">@Override\npublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {\n\n   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,\n   // 方法覆写 请参见附录&quot;方法注入&quot;中对 lookup-method 和 replaced-method 的介绍\n   if (bd.getMethodOverrides().isEmpty()) {\n      Constructor&lt;?&gt; constructorToUse;\n      synchronized (bd.constructorArgumentLock) {\n         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;\n         if (constructorToUse == null) {\n            final Class&lt;?&gt; clazz = bd.getBeanClass();\n            if (clazz.isInterface()) {\n               throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);\n            }\n            try {\n               if (System.getSecurityManager() != null) {\n                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() {\n                     @Override\n                     public Constructor&lt;?&gt; run() throws Exception {\n                        return clazz.getDeclaredConstructor((Class[]) null);\n                     }\n                  });\n               }\n               else {\n                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);\n               }\n               bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n            }\n            catch (Throwable ex) {\n               throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);\n            }\n         }\n      }\n      // 利用构造方法进行实例化\n      return BeanUtils.instantiateClass(constructorToUse);\n   }\n   else {\n      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。\n      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持\n      return instantiateWithMethodInjection(bd, beanName, owner);\n   }\n}</code></pre>\n<p>到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。</p>\n<h5 id=\"bean-属性注入\">bean 属性注入</h5>\n<p>看完了 createBeanInstance(...) 方法，我们来看看 populateBean(...) 方法，该方法负责进行属性设值，处理依赖。</p>\n<p>// AbstractAutowireCapableBeanFactory 1203</p>\n<pre><code class=\"language-java\">protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {\n   // bean 实例的所有属性都在这里了\n   PropertyValues pvs = mbd.getPropertyValues();\n\n   if (bw == null) {\n      if (!pvs.isEmpty()) {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);\n      }\n      else {\n         // Skip property population phase for null instance.\n         return;\n      }\n   }\n\n   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，\n   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，\n   // 我也没找到有实际的使用，所以我们暂且忽略这块吧\n   boolean continueWithPropertyPopulation = true;\n   if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n      for (BeanPostProcessor bp : getBeanPostProcessors()) {\n         if (bp instanceof InstantiationAwareBeanPostProcessor) {\n            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n            // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理\n            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n               continueWithPropertyPopulation = false;\n               break;\n            }\n         }\n      }\n   }\n\n   if (!continueWithPropertyPopulation) {\n      return;\n   }\n\n   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n         autowireByName(beanName, mbd, bw, newPvs);\n      }\n\n      // 通过类型装配。复杂一些\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n         autowireByType(beanName, mbd, bw, newPvs);\n      }\n\n      pvs = newPvs;\n   }\n\n   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n   if (hasInstAwareBpps || needsDepCheck) {\n      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n      if (hasInstAwareBpps) {\n         for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor\n               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究\n               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n               if (pvs == null) {\n                  return;\n               }\n            }\n         }\n      }\n      if (needsDepCheck) {\n         checkDependencies(beanName, mbd, filteredPds, pvs);\n      }\n   }\n   // 设置 bean 实例的属性值\n   applyPropertyValues(beanName, mbd, bw, pvs);\n}</code></pre>\n<h5 id=\"initializebean\">initializeBean</h5>\n<p>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p>\n<pre><code class=\"language-java\">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n   if (System.getSecurityManager() != null) {\n      AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {\n         @Override\n         public Object run() {\n            invokeAwareMethods(beanName, bean);\n            return null;\n         }\n      }, getAccessControlContext());\n   }\n   else {\n      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调\n      invokeAwareMethods(beanName, bean);\n   }\n\n   Object wrappedBean = bean;\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessBeforeInitialization 回调\n      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n   }\n\n   try {\n      // 处理 bean 中定义的 init-method，\n      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法\n      invokeInitMethods(beanName, wrappedBean, mbd);\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            (mbd != null ? mbd.getResourceDescription() : null),\n            beanName, &quot;Invocation of init method failed&quot;, ex);\n   }\n\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessAfterInitialization 回调\n      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n   }\n   return wrappedBean;\n}</code></pre>\n<p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p>\n<h2 id=\"附录\">附录</h2>\n<h3 id=\"id-和-name\">id 和 name</h3>\n<p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p>\n<p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p>\n<pre><code class=\"language-java\">beanFactory.getBean(&quot;beanName or alias&quot;);</code></pre>\n<p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;messageService&quot; name=&quot;m1, m2, m3&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</code></pre>\n<p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p>\n<pre><code class=\"language-xml\">&lt;bean name=&quot;m1, m2, m3&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt;</code></pre>\n<p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p>\n<pre><code class=\"language-xml\">&lt;bean class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</code></pre>\n<p>beanName 为：com.javadoop.example.MessageServiceImpl#0，</p>\n<p>别名 1 个，为： com.javadoop.example.MessageServiceImpl</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</code></pre>\n<p>以上配置的结果就是：beanName 为 messageService，没有别名。</p>\n<h3 id=\"配置是否允许-bean-覆盖、是否允许循环依赖\">配置是否允许 Bean 覆盖、是否允许循环依赖</h3>\n<p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>\n<p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p>\n<p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p>\n<p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p>\n<p>添加这两个属性的作者 Juergen Hoeller 在这个 <a href=\"https://jira.spring.io/browse/SPR-4374\">jira</a> 的讨论中说明了怎么配置这两个属性。</p>\n<pre><code class=\"language-java\">public class NoBeanOverridingContextLoader extends ContextLoader {\n\n  @Override\n  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) {\n    super.customizeContext(servletContext, applicationContext);\n    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;\n    arac.setAllowBeanDefinitionOverriding(false);\n  }\n}</code></pre>\n<pre><code class=\"language-java\">public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener {\n\n  @Override\n  protected ContextLoader createContextLoader() {\n    return new NoBeanOverridingContextLoader();\n  }\n\n}</code></pre>\n<pre><code class=\"language-xml\">&lt;listener&gt;\n    &lt;listener-class&gt;com.javadoop.MyContextLoaderListener&lt;/listener-class&gt;  \n&lt;/listener&gt;</code></pre>\n<p>如果以上方式不能满足你的需求，请参考这个链接：<a href=\"http://blog.csdn.net/zgmzyr/article/details/39380477\">解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题</a></p>\n<h3 id=\"profile\">profile</h3>\n<p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p>\n<pre><code class=\"language-xml\">&lt;beans profile=&quot;development&quot;\n    xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;\n    xsi:schemaLocation=&quot;...&quot;&gt;\n\n    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;\n        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;\n        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;\n    &lt;/jdbc:embedded-database&gt;\n&lt;/beans&gt;</code></pre>\n<pre><code class=\"language-xml\">&lt;beans profile=&quot;production&quot;\n    xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;\n    xsi:schemaLocation=&quot;...&quot;&gt;\n\n    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;\n&lt;/beans&gt;</code></pre>\n<p>应该不必做过多解释了吧，看每个文件第一行的 profile=&quot;&quot;。</p>\n<p>当然，我们也可以在一个配置文件中使用：</p>\n<pre><code class=\"language-xml\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;\n    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;\n    xsi:schemaLocation=&quot;...&quot;&gt;\n\n    &lt;beans profile=&quot;development&quot;&gt;\n        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;\n            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;\n            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;\n        &lt;/jdbc:embedded-database&gt;\n    &lt;/beans&gt;\n\n    &lt;beans profile=&quot;production&quot;&gt;\n        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;\n    &lt;/beans&gt;\n&lt;/beans&gt;</code></pre>\n<p>理解起来也很简单吧。</p>\n<p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p>\n<p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p>\n<p>最简单的方式莫过于在程序启动的时候指定：</p>\n<pre><code class=\"language-shell\">-Dspring.profiles.active=&quot;profile1,profile2&quot;</code></pre>\n<blockquote>\n<p>profile 可以激活多个</p>\n</blockquote>\n<p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p>\n<pre><code class=\"language-java\">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles(&quot;development&quot;);\nctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\nctx.refresh(); // 重启</code></pre>\n<p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p>\n<pre><code class=\"language-shell\">java -Dspring.profiles.active=prod -jar JavaDoop.jar</code></pre>\n<p>如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。</p>\n<h3 id=\"工厂模式生成-bean\">工厂模式生成 Bean</h3>\n<p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p>\n<p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p>\n<p>静态工厂：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;clientService&quot;\n    class=&quot;examples.ClientService&quot;\n    factory-method=&quot;createInstance&quot;/&gt;</code></pre>\n<pre><code class=\"language-java\">public class ClientService {\n    private static ClientService clientService = new ClientService();\n    private ClientService() {}\n\n    // 静态方法\n    public static ClientService createInstance() {\n        return clientService;\n    }\n}</code></pre>\n<p>实例工厂：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;\n    &lt;!-- inject any dependencies required by this locator bean --&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;clientService&quot;\n    factory-bean=&quot;serviceLocator&quot;\n    factory-method=&quot;createClientServiceInstance&quot;/&gt;\n\n&lt;bean id=&quot;accountService&quot;\n    factory-bean=&quot;serviceLocator&quot;\n    factory-method=&quot;createAccountServiceInstance&quot;/&gt;</code></pre>\n<pre><code class=\"language-java\">public class DefaultServiceLocator {\n\n    private static ClientService clientService = new ClientServiceImpl();\n\n    private static AccountService accountService = new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() {\n        return clientService;\n    }\n\n    public AccountService createAccountServiceInstance() {\n        return accountService;\n    }\n}</code></pre>\n<h3 id=\"factorybean\">FactoryBean</h3>\n<p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p>\n<pre><code class=\"language-java\">public interface FactoryBean&lt;T&gt; {\n    T getObject() throws Exception;\n    Class&lt;T&gt; getObjectType();\n    boolean isSingleton();\n}</code></pre>\n<pre><code class=\"language-java\">public class Person { \n    private Car car ;\n    private void setCar(Car car){ this.car = car;  }  \n}</code></pre>\n<p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p>\n<pre><code class=\"language-java\">public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;{\n    private String make; \n    private int year ;\n\n    public void setMake(String m){ this.make =m ; }\n\n    public void setYear(int y){ this.year = y; }\n\n    public Car getObject(){ \n      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种\n      CarBuilder cb = CarBuilder.car();\n\n      if(year!=0) cb.setYear(this.year);\n      if(StringUtils.hasText(this.make)) cb.setMake( this.make ); \n      return cb.factory(); \n    }\n\n    public Class&lt;Car&gt; getObjectType() { return Car.class ; } \n\n    public boolean isSingleton() { return false; }\n}</code></pre>\n<p>我们看看装配的时候是怎么配置的：</p>\n<pre><code class=\"language-xml\">&lt;bean class = &quot;com.javadoop.MyCarFactoryBean&quot; id = &quot;car&quot;&gt;\n  &lt;property name = &quot;make&quot; value =&quot;Honda&quot;/&gt;\n  &lt;property name = &quot;year&quot; value =&quot;1984&quot;/&gt;\n&lt;/bean&gt;\n&lt;bean class = &quot;com.javadoop.Person&quot; id = &quot;josh&quot;&gt;\n  &lt;property name = &quot;car&quot; ref = &quot;car&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p>\n<p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？</p>\n<pre><code class=\"language-java\">@Configuration \npublic class CarConfiguration { \n\n    @Bean \n    public MyCarFactoryBean carFactoryBean(){ \n      MyCarFactoryBean cfb = new MyCarFactoryBean();\n      cfb.setMake(&quot;Honda&quot;);\n      cfb.setYear(1984);\n      return cfb;\n    }\n\n    @Bean\n    public Person aPerson(){ \n    Person person = new Person();\n      // 注意这里的不同\n    person.setCar(carFactoryBean().getObject());\n    return person; \n    } \n}</code></pre>\n<p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p>\n<h3 id=\"初始化-bean-的回调\">初始化 Bean 的回调</h3>\n<p>有以下四种方案：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;</code></pre>\n<pre><code class=\"language-java\">public class AnotherExampleBean implements InitializingBean {\n\n    public void afterPropertiesSet() {\n        // do some initialization work\n    }\n}</code></pre>\n<pre><code class=\"language-java\">@Bean(initMethod = &quot;init&quot;)\npublic Foo foo() {\n    return new Foo();\n}</code></pre>\n<pre><code class=\"language-java\">@PostConstruct\npublic void init() {\n\n}</code></pre>\n<h3 id=\"销毁-bean-的回调\">销毁 Bean 的回调</h3>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;</code></pre>\n<pre><code class=\"language-java\">public class AnotherExampleBean implements DisposableBean {\n\n    public void destroy() {\n        // do some destruction work (like releasing pooled connections)\n    }\n}</code></pre>\n<pre><code class=\"language-java\">@Bean(destroyMethod = &quot;cleanup&quot;)\npublic Bar bar() {\n    return new Bar();\n}</code></pre>\n<pre><code class=\"language-java\">@PreDestroy\npublic void cleanup() {\n\n}</code></pre>\n<h3 id=\"conversionservice\">ConversionService</h3>\n<p>既然文中说到了这个，顺便提一下好了。</p>\n<p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p>\n<p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;conversionService&quot;\n  class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;\n  &lt;property name=&quot;converters&quot;&gt;\n    &lt;list&gt;\n      &lt;bean class=&quot;com.javadoop.learning.utils.StringToEnumConverterFactory&quot;/&gt;\n    &lt;/list&gt;\n  &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p>\n<p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p>\n<p>来看一个很简单的例子，这样比什么都管用。</p>\n<pre><code class=\"language-java\">public class StringToDateConverter implements Converter&lt;String, Date&gt; {\n\n    @Override\n    public Date convert(String source) {\n        try {\n            return DateUtils.parseDate(source, &quot;yyyy-MM-dd&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd HH:mm&quot;, &quot;HH:mm:ss&quot;, &quot;HH:mm&quot;);\n        } catch (ParseException e) {\n            return null;\n        }\n    }\n}</code></pre>\n<p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p>\n<h3 id=\"bean-继承\">Bean 继承</h3>\n<p>在初始化 Bean 的地方，我们说过了这个：</p>\n<pre><code class=\"language-java\">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</code></pre>\n<p>这里涉及到的就是 <code>&lt;bean parent=&quot;&quot; /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p>\n<p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p>\n<p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p>\n<p>看如下一个例子:</p>\n<pre><code class=\"language-java\">&lt;bean id=&quot;inheritedTestBean&quot; abstract=&quot;true&quot; class=&quot;org.springframework.beans.TestBean&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;\n    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;inheritsWithDifferentClass&quot; class=&quot;org.springframework.beans.DerivedTestBean&quot;\n        parent=&quot;inheritedTestBean&quot; init-method=&quot;initialize&quot;&gt;\n\n    &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<p>parent bean 设置了 <code>abstract=&quot;true&quot;</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p>\n<p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p>\n<p>当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p>\n<p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p>\n<pre><code class=\"language-java\">&lt;bean id=&quot;inheritedTestBeanWithoutClass&quot; abstract=&quot;true&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;\n    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<h3 id=\"方法注入\">方法注入</h3>\n<p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p>\n<p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p>\n<p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p>\n<p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p>\n<h4 id=\"lookup-method\">lookup-method</h4>\n<p>我们来看一下 Spring Reference 中提供的一个例子：</p>\n<pre><code class=\"language-java\">package fiona.apple;\n\n// no more Spring imports!\n\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        // grab a new instance of the appropriate Command interface\n        Command command = createCommand();\n        // set the state on the (hopefully brand new) Command instance\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    // okay... but where is the implementation of this method?\n    protected abstract Command createCommand();\n}</code></pre>\n<p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p>\n<pre><code class=\"language-xml\">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;\n&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt;\n    &lt;!-- inject dependencies here as required --&gt;\n&lt;/bean&gt;\n\n&lt;!-- commandProcessor uses statefulCommandHelper --&gt;\n&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt;\n    &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<p>Spring 采用 <strong>CGLIB 生成字节码</strong>的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p>\n<p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p>\n<pre><code class=\"language-java\">public abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup(&quot;myCommand&quot;)\n    protected abstract Command createCommand();\n}</code></pre>\n<blockquote>\n<p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt;</code></p>\n</blockquote>\n<p>甚至，我们可以像下面这样：</p>\n<pre><code class=\"language-java\">public abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup\n    protected abstract MyCommand createCommand();\n}</code></pre>\n<blockquote>\n<p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p>\n</blockquote>\n<h4 id=\"replaced-method\">replaced-method</h4>\n<p>记住它的功能，就是替换掉 bean 中的一些方法。</p>\n<pre><code class=\"language-java\">public class MyValueCalculator {\n\n    public String computeValue(String input) {\n        // some real code...\n    }\n\n    // some other methods...\n}</code></pre>\n<p>方法覆写，注意要实现 MethodReplacer 接口：</p>\n<pre><code class=\"language-java\">public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer {\n\n    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {\n        // get the input value, work with it, and return a computed result\n        String input = (String) args[0];\n        ...\n        return ...;\n    }\n}</code></pre>\n<p>配置也很简单：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt;\n    &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;\n    &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt;\n        &lt;arg-type&gt;String&lt;/arg-type&gt;\n    &lt;/replaced-method&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt;</code></pre>\n<blockquote>\n<p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p>\n</blockquote>\n<h3 id=\"beanpostprocessor\">BeanPostProcessor</h3>\n<p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p>\n<pre><code class=\"language-java\">public interface BeanPostProcessor {\n\n   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\n   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n\n}</code></pre>\n<p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p>\n<p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p>\n<p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p>\n<p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p>\n<p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p>\n<p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p>\n<p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p>\n<h2 id=\"总结\">总结</h2>\n<p>按理说，总结应该写在附录前面，我就不讲究了。</p>\n<p>在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。</p>\n<p>本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。</p>\n<p>（全文完）</p>\n',345,0,105,2,NULL,'2018-05-01 00:49:23','2020-09-30 00:49:19',1,'32,44,48',1,0),(9,'Java 线上故障如何完整排查？','线上故障主要会包括 CPU、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如 jstack、jmap 等工具也是不囿于一个方面的问题的，基本上出问题就是 df、free、top 三连，然后依次 jstack、jmap 伺候，具体问题具体分析即可。','fredalxin','线上故障主要会包括 CPU、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如 jstack、jmap 等工具也是不囿于一个方面的问题的，基本上出问题就是 df、free、top 三连，然后依次 jstack、jmap 伺候，具体问题具体分析即可。\n\n#### CPU\n\n一般来讲我们首先会排查 CPU 方面的问题。CPU 异常往往还是比较好定位的。原因包括业务逻辑问题(死循环)、频繁 gc 以及上下文切换过多。而最常见的往往是业务逻辑(或者框架逻辑)导致的，可以使用 jstack 来分析对应的堆栈情况。\n\n#### 使用 jstack 分析 CPU 问题\n\n我们先用 ps 命令找到对应进程的 pid(如果你有好几个目标进程，可以先用 top 看一下哪个占用比较高)。\n\n接着用top -H -p pid来找到 CPU 使用率比较高的一些线程\n\n![image.png](http://oss.osalien.com/dbblog/20200927/d33c397f46b145fc86679540e5be2904.png)\n\n然后将占用最高的 pid 转换为 16 进制printf \'%x\\n\' pid得到 nid\n\n![image.png](http://oss.osalien.com/dbblog/20200927/6760c82f80f44c27828a3ba9f60c614d.png)\n\n接着直接在 jstack 中找到相应的堆栈信息jstack pid |grep \'nid\' -C5 –color\n\n![image.png](http://oss.osalien.com/dbblog/20200927/22650688578a4f6a93ab5ea615627c2b.png)\n\n可以看到我们已经找到了 nid 为 0x42 的堆栈信息，接着只要仔细分析一番即可。\n\n当然更常见的是我们对整个 jstack 文件进行分析，通常我们会比较关注 WAITING 和 TIMED_WAITING 的部分，BLOCKED 就不用说了。我们可以使用命令cat jstack.log | grep \"java.lang.Thread.State\" | sort -nr | uniq -c来对 jstack 的状态有一个整体的把握，如果 WAITING 之类的特别多，那么多半是有问题啦。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/2963c48aa1544016b0e11e29a0aaff48.png)\n\n#### 频繁 gc\n\n当然我们还是会使用 jstack 来分析问题，但有时候我们可以先确定下 gc 是不是太频繁，使用jstat -gc pid 1000命令来对 gc 分代变化情况进行观察，1000 表示采样间隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU 分别代表两个 Survivor 区、Eden 区、老年代、元数据区的容量和使用量。YGC/YGT、FGC/FGCT、GCT 则代表 YoungGc、FullGc 的耗时和次数以及总耗时。如果看到 gc 比较频繁，再针对 gc 方面做进一步分析，具体可以参考一下 gc 章节的描述。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/3fadb753db7b4568993bb3e6344b1af4.png)\n\n#### 上下文切换\n\n针对频繁上下文问题，我们可以使用vmstat命令来进行查看\n\n![image.png](http://oss.osalien.com/dbblog/20200927/c449faf67d734bdc8ab4563e9de8d384.png)\n\ncs(context switch)一列则代表了上下文切换的次数。\n\n如果我们希望对特定的 pid 进行监控那么可以使用 pidstat -w pid命令，cswch 和 nvcswch 表示自愿及非自愿切换。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/fd00a2f8bd544565ba51d68b6d14c863.png)\n\n#### 磁盘\n\n磁盘问题和 CPU 一样是属于比较基础的。首先是磁盘空间方面，我们直接使用df -hl来查看文件系统状态\n\n![image.png](http://oss.osalien.com/dbblog/20200927/23e2dc95130f44e591df06636e8e4ebb.png)\n\n更多时候，磁盘问题还是性能上的问题。我们可以通过 iostatiostat -d -k -x来进行分析\n\n![image.png](http://oss.osalien.com/dbblog/20200927/1f27ecf8dd69422596392f12fccf3105.png)\n\n最后一列%util可以看到每块磁盘写入的程度，而rrqpm/s以及wrqm/s分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。\n\n另外我们还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用 iotop 命令来进行定位文件读写的来源。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/f9705cad7ea746f1a2cd9bbea9dd351f.png)\n\n不过这边拿到的是 tid，我们要转换成 pid，可以通过 readlink 来找到 pidreadlink -f /proc/*/task/tid/../..。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/235332789b2e473ebfb1aa19880a4242.png)\n\n找到 pid 之后就可以看这个进程具体的读写情况cat /proc/pid/io\n\n![image.png](http://oss.osalien.com/dbblog/20200927/4e9e0e65e2f2498baf3d4ffb58cede5e.png)\n\n我们还可以通过 lsof 命令来确定具体的文件读写情况lsof -p pid\n\n![image.png](http://oss.osalien.com/dbblog/20200927/eb46b64979434f62b96245f4682a51c1.png)\n\n#### 内存\n\n内存问题排查起来相对比 CPU 麻烦一些，场景也比较多。主要包括 OOM、GC 问题和堆外内存。一般来讲，我们会先用free命令先来检查一发内存的各种情况。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/8e4e7c787d8840949eb04d4021fd464d.png)\n\n#### 堆内内存\n\n内存问题大多还都是堆内内存问题。表象上主要分为 OOM 和 Stack Overflow。\n\n#### OOM\n\nJMV 中的内存不足，OOM 大致可以分为以下几种：\n\nException in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread\n\n这个意思是没有足够的内存空间给线程分配 Java 栈，基本上还是线程池代码写的有问题，比如说忘记 shutdown，所以说应该首先从代码层面来寻找问题，使用 jstack 或者 jmap。如果一切都正常，JVM 方面可以通过指定Xss来减少单个 thread stack 的大小。另外也可以在系统层面，可以通过修改/etc/security/limits.confnofile 和 nproc 来增大 os 对线程的限制\n\n![image.png](http://oss.osalien.com/dbblog/20200927/2c72af00da7b4aaba4099b915bfdde3b.png)\n\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\n这个意思是堆的内存占用已经达到-Xmx 设置的最大值，应该是最常见的 OOM 错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过 jstack 和 jmap 去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。\n\nCaused by: java.lang.OutOfMemoryError: Meta space\n\n这个意思是元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值，排查思路和上面的一致，参数方面可以通过XX:MaxPermSize来进行调整(这里就不说 1.8 以前的永久代了)。\n\n#### Stack Overflow\n栈内存溢出，这个大家见到也比较多。\n\nException in thread \"main\" java.lang.StackOverflowError\n\n表示线程栈需要的内存大于 Xss 值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起 OOM。\n\n#### 使用 JMAP 定位代码内存泄漏\n\n上述关于 OOM 和 Stack Overflo 的代码排查方面，我们一般使用 JMAPjmap -dump:format=b,file=filename pid来导出 dump 文件\n\n![image.png](http://oss.osalien.com/dbblog/20200927/db465142011f4e1685e175d0a04db8d6.png)\n\n通过 mat(Eclipse Memory Analysis Tools)导入 dump 文件进行分析，内存泄漏问题一般我们直接选 Leak Suspects 即可，mat 给出了内存泄漏的建议。另外也可以选择 Top Consumers 来查看最大对象报告。和线程相关的问题可以选择 thread overview 进行分析。除此之外就是选择 Histogram 类概览来自己慢慢分析，大家可以搜搜 mat 的相关教程。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/47c7b39e77a0471e80262e6ade5133ed.png)\n\n日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都 new 对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发 gc；ByteBuffer 缓存分配不合理等都会造成代码 OOM。\n\n另一方面，我们可以在启动参数中指定-XX:+HeapDumpOnOutOfMemoryError来保存 OOM 时的 dump 文件。\n\n#### gc 问题和线程\n\ngc 问题除了影响 CPU 也会影响内存，排查思路也是一致的。一般先使用 jstat 来查看分代变化情况，比如 youngGC 或者 fullGC 次数是不是太多呀；EU、OU 等指标增长是不是异常呀等。\n\n线程的话太多而且不被及时 gc 也会引发 oom，大部分就是之前说的unable to create new native thread。除了 jstack 细细分析 dump 文件外，我们一般先会看下总体线程，通过pstreee -p pid |wc -l。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/c71f1d2b672d4a64a46db2053357b973.png)\n\n或者直接通过查看/proc/pid/task的数量即为线程数量。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/3607e378a2774679a7ff8964164d31ba.png)\n\n#### 堆外内存\n\n如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用 Netty 导致的，那错误日志里可能会出现OutOfDirectMemoryError错误，如果直接是 DirectByteBuffer，那会报OutOfMemoryError: Direct buffer memory。\n\n堆外内存溢出往往是和 NIO 的使用相关，一般我们先通过 pmap 来查看下进程占用的内存情况pmap -x pid | sort -rn -k3 | head -30，这段意思是查看对应 pid 倒序前 30 大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/e1a9f722b6234ecab47cec2cca393680.png)\n\n我们如果确定有可疑的内存端，需要通过 gdb 来分析gdb --batch --pid {pid} -ex \"dump memory filename.dump {内存起始地址} {内存起始地址+内存块大小}\"\n\n![image.png](http://oss.osalien.com/dbblog/20200927/c632856b2f4945f195a0bc9f958e314d.png)\n\n获取 dump 文件后可用 heaxdump 进行查看hexdump -C filename | less，不过大多数看到的都是二进制乱码。\n\nNMT 是 Java7U40 引入的 HotSpot 新特性，配合 jcmd 命令我们就可以看到具体内存组成了。需要在启动参数中加入 -XX:NativeMemoryTracking=summary 或者 -XX:NativeMemoryTracking=detail，会有略微性能损耗。\n\n一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线jcmd pid VM.native_memory baseline。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/4a6cf290ef724e2aa9b0f7d49efa4df6.png)\n\n然后等放一段时间后再去看看内存增长的情况，通过jcmd pid VM.native_memory detail.diff(summary.diff)做一下 summary 或者 detail 级别的 diff。\n![image.png](http://oss.osalien.com/dbblog/20200927/41290e8a8eba44eda50321ccbf0200ee.png)\n\n![image.png](http://oss.osalien.com/dbblog/20200927/5a5a1aacb7724a88a02a969fe47c6ddf.png)\n\n可以看到 jcmd 分析出来的内存十分详细，包括堆内、线程以及 gc(所以上述其他内存异常其实都可以用 nmt 来分析)，这边堆外内存我们重点关注 Internal 的内存增长，如果增长十分明显的话那就是有问题了。\n\ndetail 级别的话还会有具体内存段的增长情况，如下图。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/7d33fe50bc084327a175d3349a073410.png)\n\n此外在系统层面，我们还可以使用 strace 命令来监控内存分配 strace -f -e \"brk,mmap,munmap\" -p pid\n\n这边内存分配信息主要包括了 pid 和内存地址。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/199815eca3ec4628bf708b8efe94c442.png)\n\n不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如 DirectByteBuffer 分配内存的话，是需要 full GC 或者手动 system.gc 来进行回收的(所以最好不要使用-XX:+DisableExplicitGC)。那么其实我们可以跟踪一下 DirectByteBuffer 对象的内存情况，通过jmap -histo:live pid手动触发 fullGC 来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过-XX:MaxDirectMemorySize进行调整。如果没有什么变化，那就要使用 jmap 去分析那些不能被 gc 的对象，以及和 DirectByteBuffer 之间的引用关系了。\n\n#### GC 问题\n\n堆内内存泄漏总是和 GC 异常相伴。不过 GC 问题不只是和内存问题相关，还有可能引起 CPU 负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下 GC 相关问题。\n\n我们在 CPU 章介绍了使用 jstat 来获取当前 GC 分代变化信息。而更多时候，我们是通过 GC 日志来排查问题的，在启动参数中加上-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps来开启 GC 日志。\n\n常见的 Young GC、Full GC 日志含义在此就不做赘述了。\n\n针对 gc 日志，我们就能大致推断出 youngGC 与 fullGC 是否过于频繁或者耗时过长，从而对症下药。我们下面将对 G1 垃圾收集器来做分析，这边也建议大家使用 G1-XX:+UseG1GC。\n\n#### youngGC 过频繁\n\nyoungGC 频繁一般是短周期小对象较多，先考虑是不是 Eden 区/新生代设置的太小了，看能否通过调整-Xmn、-XX:SurvivorRatio 等参数设置来解决问题。如果参数正常，但是 young gc 频率还是太高，就需要使用 Jmap 和 MAT 对 dump 文件进行进一步排查了。\n\n#### youngGC 耗时过长\n\n耗时过长问题就要看 GC 日志里耗时耗在哪一块了。以 G1 日志为例，可以关注 Root Scanning、Object Copy、Ref Proc 等阶段。Ref Proc 耗时长，就要注意引用相关的对象。Root Scanning 耗时长，就要注意线程数、跨代引用。Object Copy 则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的 Root Scanning 和正常时间段比增长较多，那就是起的线程太多了。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/947a26cadcc04bc8a870144179c62c39.png)\n\n#### 触发 fullGC\n\nG1 中更多的还是 mixedGC，但 mixedGC 可以和 youngGC 思路一样去排查。触发 fullGC 了一般都会有问题，G1 会退化使用 Serial 收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。\n\nfullGC 的原因可能包括以下这些，以及参数调整方面的一些思路：\n\n- 并发阶段失败：在并发标记阶段，MixGC 之前老年代就被填满了，那么这时候 G1 就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数-XX:ConcGCThreads。\n\n- 晋升失败：在 GC 的时候没有足够的内存供存活/晋升对象使用，所以触发了 Full GC。这时候可以通过-XX:G1ReservePercent来增加预留内存百分比，减少-XX:InitiatingHeapOccupancyPercent来提前启动标记，-XX:ConcGCThreads来增加标记线程数也是可以的。\n\n- 大对象分配失败：大对象找不到合适的 region 空间进行分配，就会进行 fullGC，这种情况下可以增大内存或者增大-XX:G1HeapRegionSize。\n\n- 程序主动执行 System.gc()：不要随便写就对了。\n\n另外，我们可以在启动参数中配置-XX:HeapDumpPath=/xxx/dump.hprof来 dump fullGC 相关的文件，并通过 jinfo 来进行 gc 前后的 dump\n\n```\njinfo -flag +HeapDumpBeforeFullGC pid\njinfo -flag +HeapDumpAfterFullGC pid\n```\n\n这样得到 2 份 dump 文件，对比后主要关注被 gc 掉的问题对象来定位问题。\n\n#### 网络\n\n涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从 tcp 层、应用层以及工具的使用等方面进行阐述。\n\n#### 超时\n\n超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。\n\n- 读写超时。readTimeout/writeTimeout，有些框架叫做 so_timeout 或者 socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa 的超时指的也是读超时。读写超时一般都只针对客户端设置。\n\n- 连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边 connectionTimeout 就有些五花八门了，Jetty 中表示空闲连接清理时间，Tomcat 则表示连接维持的最大时间。\n\n- 其他。包括连接获取超时 connectionAcquireTimeout 和空闲连接清理超时 idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。\n\n我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。\n\n在实际开发中，我们关心最多的应该是接口的读写超时了。\n\n如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的 tcp 连接。而如果接口设置的过短，那么接口超时就会非常频繁。\n\n服务端接口明明 rt 降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。\n\n#### TCP 队列溢出\n\ntcp 队列溢出是个相对底层的错误，它可能会造成超时、rst 等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/5a70a907d7e947709d3cc8f98c3a2af5.png)\n\n如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在 server 收到 client 的 syn 后，把消息放到 syns queue，回复 syn+ack 给 client，server 收到 client 的 ack，如果这时 accept queue 没满，那就从 syns queue 拿出暂存的信息放入 accept queue 中，否则按 tcp_abort_on_overflow 指示的执行。\n\ntcp_abort_on_overflow 0 表示如果三次握手第三步的时候 accept queue 满了那么 server 扔掉 client 发过来的 ack。tcp_abort_on_overflow 1 则表示第三步的时候如果全连接队列满了，server 发送一个 rst 包给 client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多connection reset / connection reset by peer。\n\n那么在实际开发中，我们怎么能快速定位到 tcp 队列溢出呢？\n\nnetstat 命令，执行 netstat -s | egrep \"listen|LISTEN\"\n\n![image.png](http://oss.osalien.com/dbblog/20200927/7429f7ac0a034cce958bb62d5404599d.png)\n\n如上图所示，overflowed 表示全连接队列溢出的次数，sockets dropped 表示半连接队列溢出的次数。\n\n#### ss 命令，执行 ss -lnt\n\n![image.png](http://oss.osalien.com/dbblog/20200927/528542ca39d84222b64ee4479f373e07.png)\n\n上面看到 Send-Q 表示第三列的 listen 端口上的全连接队列最大为 5，第一列 Recv-Q 为全连接队列当前使用了多少。\n\n接着我们看看怎么设置全连接、半连接队列大小吧：\n\n全连接队列的大小取决于 min(backlog, somaxconn)。backlog 是在 socket 创建的时候传入的，somaxconn 是一个 os 级别的系统参数。而半连接队列的大小取决于 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。\n\n在日常开发中，我们往往使用 servlet 容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在 Tomcat 中 backlog 叫做acceptCount，在 Jetty 里面则是acceptQueueSize。\n\n#### RST 异常\n\nRST 包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。\n\n在实际开发中，我们往往会看到connection reset / connection reset by peer错误，这种情况就是 RST 包导致的。\n\n#### 端口不存在\n\n如果像不存在的端口发出建立连接 SYN 请求，那么服务端发现自己并没有这个端口则会直接返回一个 RST 报文，用于中断连接。\n\n#### 主动代替 FIN 终止连接\n\n一般来说，正常的连接关闭都是需要通过 FIN 报文实现，然而我们也可以用 RST 报文来代替 FIN，表示直接终止连接。实际开发中，可设置 SO_LINGER 数值来控制，这种往往是故意的，来跳过 TIMED_WAIT，提供交互效率，不闲就慎用。\n\n**客户端或服务端有一边发生了异常，该方向对端发送 RST 以告知关闭连接**\n\n我们上面讲的 tcp 队列溢出发送 RST 包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。\n\n**接收到的 TCP 报文不在已知的 TCP 连接内**\n\n比如，一方机器由于网络实在太差 TCP 报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的 TCP 报文，但由于对应的 TCP 连接已不存在，那么会直接发一个 RST 包以便开启新的连接。\n\n**一方长期未收到另一方的确认报文，在一定时间或重传次数后发出 RST 报文**\n\n这种大多也和网络环境相关了，网络环境差可能会导致更多的 RST 报文。\n\n之前说过 RST 报文多会导致程序报错，在一个已关闭的连接上读操作会报connection reset，而在一个已关闭的连接上写操作则会报connection reset by peer。通常我们可能还会看到broken pipe错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到 RST，报出connection reset错后继续读写数据报的错，这个在 glibc 源码注释中也有介绍。\n\n我们在排查故障时候怎么确定有 RST 包的存在呢？当然是使用 tcpdump 命令进行抓包，并使用 wireshark 进行简单分析了。tcpdump -i en0 tcp -w xxx.cap，en0 表示监听的网卡。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/940bcfd015b04240bf8bc050ece98c8d.png)\n\n接下来我们通过 wireshark 打开抓到的包，可能就能看到如下图所示，红色的就表示 RST 包了。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/7a07046d13824178980f1dcc28ff227f.png)\n\n#### TIME_WAIT 和 CLOSE_WAIT\n\nTIME_WAIT 和 CLOSE_WAIT 是啥意思相信大家都知道。\n\n在线上时，我们可以直接用命令netstat -n | awk \'/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}\'来查看 time-wait 和 close_wait 的数量\n\n用 ss 命令会更快ss -ant | awk \'{++S[$1]} END {for(a in S) print a, S[a]}\'\n\n![image.png](http://oss.osalien.com/dbblog/20200927/2e9d2d2362704767bcf15172774c2ac3.png)\n\n#### TIME_WAIT\n\ntime_wait 的存在一是为了丢失的数据包被后面连接复用，二是为了在 2MSL 的时间范围内正常关闭连接。它的存在其实会大大减少 RST 包的出现。\n\n过多的 time_wait 在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:\n\n```\n#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭\n\nnet.ipv4.tcp_tw_reuse = 1\n\n#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭\n\nnet.ipv4.tcp_tw_recycle = 1\n```\n\n当然我们不要忘记在 NAT 环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小tcp_max_tw_buckets，超过这个数的 time_wait 都会被干掉，不过这也会导致报time wait bucket table overflow的错。\n\n#### CLOSE_WAIT\n\nclose_wait 往往都是因为应用程序写的有问题，没有在 ACK 后再次发起 FIN 报文。close_wait 出现的概率甚至比 time_wait 要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。\n\n想要定位这类问题，最好是通过 jstack 来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。\n\n开发同学说应用上线后 CLOSE_WAIT 就一直增多，直到挂掉为止，jstack 后找到比较可疑的堆栈是大部分线程都卡在了countdownlatch.await方法，找开发同学了解后得知使用了多线程但是确没有 catch 异常，修改后发现异常仅仅是最简单的升级 sdk 后常出现的class not found。\n','<p>线上故障主要会包括 CPU、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如 jstack、jmap 等工具也是不囿于一个方面的问题的，基本上出问题就是 df、free、top 三连，然后依次 jstack、jmap 伺候，具体问题具体分析即可。</p>\n<h4 id=\"cpu\">CPU</h4>\n<p>一般来讲我们首先会排查 CPU 方面的问题。CPU 异常往往还是比较好定位的。原因包括业务逻辑问题(死循环)、频繁 gc 以及上下文切换过多。而最常见的往往是业务逻辑(或者框架逻辑)导致的，可以使用 jstack 来分析对应的堆栈情况。</p>\n<h4 id=\"使用-jstack-分析-cpu-问题\">使用 jstack 分析 CPU 问题</h4>\n<p>我们先用 ps 命令找到对应进程的 pid(如果你有好几个目标进程，可以先用 top 看一下哪个占用比较高)。</p>\n<p>接着用top -H -p pid来找到 CPU 使用率比较高的一些线程</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/d33c397f46b145fc86679540e5be2904.png\" alt=\"image.png\"></p>\n<p>然后将占用最高的 pid 转换为 16 进制printf &#39;%x\\n&#39; pid得到 nid</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/6760c82f80f44c27828a3ba9f60c614d.png\" alt=\"image.png\"></p>\n<p>接着直接在 jstack 中找到相应的堆栈信息jstack pid |grep &#39;nid&#39; -C5 –color</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/22650688578a4f6a93ab5ea615627c2b.png\" alt=\"image.png\"></p>\n<p>可以看到我们已经找到了 nid 为 0x42 的堆栈信息，接着只要仔细分析一番即可。</p>\n<p>当然更常见的是我们对整个 jstack 文件进行分析，通常我们会比较关注 WAITING 和 TIMED_WAITING 的部分，BLOCKED 就不用说了。我们可以使用命令cat jstack.log | grep &quot;java.lang.Thread.State&quot; | sort -nr | uniq -c来对 jstack 的状态有一个整体的把握，如果 WAITING 之类的特别多，那么多半是有问题啦。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/2963c48aa1544016b0e11e29a0aaff48.png\" alt=\"image.png\"></p>\n<h4 id=\"频繁-gc\">频繁 gc</h4>\n<p>当然我们还是会使用 jstack 来分析问题，但有时候我们可以先确定下 gc 是不是太频繁，使用jstat -gc pid 1000命令来对 gc 分代变化情况进行观察，1000 表示采样间隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU 分别代表两个 Survivor 区、Eden 区、老年代、元数据区的容量和使用量。YGC/YGT、FGC/FGCT、GCT 则代表 YoungGc、FullGc 的耗时和次数以及总耗时。如果看到 gc 比较频繁，再针对 gc 方面做进一步分析，具体可以参考一下 gc 章节的描述。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/3fadb753db7b4568993bb3e6344b1af4.png\" alt=\"image.png\"></p>\n<h4 id=\"上下文切换\">上下文切换</h4>\n<p>针对频繁上下文问题，我们可以使用vmstat命令来进行查看</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/c449faf67d734bdc8ab4563e9de8d384.png\" alt=\"image.png\"></p>\n<p>cs(context switch)一列则代表了上下文切换的次数。</p>\n<p>如果我们希望对特定的 pid 进行监控那么可以使用 pidstat -w pid命令，cswch 和 nvcswch 表示自愿及非自愿切换。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/fd00a2f8bd544565ba51d68b6d14c863.png\" alt=\"image.png\"></p>\n<h4 id=\"磁盘\">磁盘</h4>\n<p>磁盘问题和 CPU 一样是属于比较基础的。首先是磁盘空间方面，我们直接使用df -hl来查看文件系统状态</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/23e2dc95130f44e591df06636e8e4ebb.png\" alt=\"image.png\"></p>\n<p>更多时候，磁盘问题还是性能上的问题。我们可以通过 iostatiostat -d -k -x来进行分析</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/1f27ecf8dd69422596392f12fccf3105.png\" alt=\"image.png\"></p>\n<p>最后一列%util可以看到每块磁盘写入的程度，而rrqpm/s以及wrqm/s分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。</p>\n<p>另外我们还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用 iotop 命令来进行定位文件读写的来源。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/f9705cad7ea746f1a2cd9bbea9dd351f.png\" alt=\"image.png\"></p>\n<p>不过这边拿到的是 tid，我们要转换成 pid，可以通过 readlink 来找到 pidreadlink -f /proc/*/task/tid/../..。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/235332789b2e473ebfb1aa19880a4242.png\" alt=\"image.png\"></p>\n<p>找到 pid 之后就可以看这个进程具体的读写情况cat /proc/pid/io</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/4e9e0e65e2f2498baf3d4ffb58cede5e.png\" alt=\"image.png\"></p>\n<p>我们还可以通过 lsof 命令来确定具体的文件读写情况lsof -p pid</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/eb46b64979434f62b96245f4682a51c1.png\" alt=\"image.png\"></p>\n<h4 id=\"内存\">内存</h4>\n<p>内存问题排查起来相对比 CPU 麻烦一些，场景也比较多。主要包括 OOM、GC 问题和堆外内存。一般来讲，我们会先用free命令先来检查一发内存的各种情况。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/8e4e7c787d8840949eb04d4021fd464d.png\" alt=\"image.png\"></p>\n<h4 id=\"堆内内存\">堆内内存</h4>\n<p>内存问题大多还都是堆内内存问题。表象上主要分为 OOM 和 Stack Overflow。</p>\n<h4 id=\"oom\">OOM</h4>\n<p>JMV 中的内存不足，OOM 大致可以分为以下几种：</p>\n<p>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</p>\n<p>这个意思是没有足够的内存空间给线程分配 Java 栈，基本上还是线程池代码写的有问题，比如说忘记 shutdown，所以说应该首先从代码层面来寻找问题，使用 jstack 或者 jmap。如果一切都正常，JVM 方面可以通过指定Xss来减少单个 thread stack 的大小。另外也可以在系统层面，可以通过修改/etc/security/limits.confnofile 和 nproc 来增大 os 对线程的限制</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/2c72af00da7b4aaba4099b915bfdde3b.png\" alt=\"image.png\"></p>\n<p>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</p>\n<p>这个意思是堆的内存占用已经达到-Xmx 设置的最大值，应该是最常见的 OOM 错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过 jstack 和 jmap 去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。</p>\n<p>Caused by: java.lang.OutOfMemoryError: Meta space</p>\n<p>这个意思是元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值，排查思路和上面的一致，参数方面可以通过XX:MaxPermSize来进行调整(这里就不说 1.8 以前的永久代了)。</p>\n<h4 id=\"stack-overflow\">Stack Overflow</h4>\n<p>栈内存溢出，这个大家见到也比较多。</p>\n<p>Exception in thread &quot;main&quot; java.lang.StackOverflowError</p>\n<p>表示线程栈需要的内存大于 Xss 值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起 OOM。</p>\n<h4 id=\"使用-jmap-定位代码内存泄漏\">使用 JMAP 定位代码内存泄漏</h4>\n<p>上述关于 OOM 和 Stack Overflo 的代码排查方面，我们一般使用 JMAPjmap -dump:format=b,file=filename pid来导出 dump 文件</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/db465142011f4e1685e175d0a04db8d6.png\" alt=\"image.png\"></p>\n<p>通过 mat(Eclipse Memory Analysis Tools)导入 dump 文件进行分析，内存泄漏问题一般我们直接选 Leak Suspects 即可，mat 给出了内存泄漏的建议。另外也可以选择 Top Consumers 来查看最大对象报告。和线程相关的问题可以选择 thread overview 进行分析。除此之外就是选择 Histogram 类概览来自己慢慢分析，大家可以搜搜 mat 的相关教程。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/47c7b39e77a0471e80262e6ade5133ed.png\" alt=\"image.png\"></p>\n<p>日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都 new 对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发 gc；ByteBuffer 缓存分配不合理等都会造成代码 OOM。</p>\n<p>另一方面，我们可以在启动参数中指定-XX:+HeapDumpOnOutOfMemoryError来保存 OOM 时的 dump 文件。</p>\n<h4 id=\"gc-问题和线程\">gc 问题和线程</h4>\n<p>gc 问题除了影响 CPU 也会影响内存，排查思路也是一致的。一般先使用 jstat 来查看分代变化情况，比如 youngGC 或者 fullGC 次数是不是太多呀；EU、OU 等指标增长是不是异常呀等。</p>\n<p>线程的话太多而且不被及时 gc 也会引发 oom，大部分就是之前说的unable to create new native thread。除了 jstack 细细分析 dump 文件外，我们一般先会看下总体线程，通过pstreee -p pid |wc -l。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/c71f1d2b672d4a64a46db2053357b973.png\" alt=\"image.png\"></p>\n<p>或者直接通过查看/proc/pid/task的数量即为线程数量。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/3607e378a2774679a7ff8964164d31ba.png\" alt=\"image.png\"></p>\n<h4 id=\"堆外内存\">堆外内存</h4>\n<p>如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用 Netty 导致的，那错误日志里可能会出现OutOfDirectMemoryError错误，如果直接是 DirectByteBuffer，那会报OutOfMemoryError: Direct buffer memory。</p>\n<p>堆外内存溢出往往是和 NIO 的使用相关，一般我们先通过 pmap 来查看下进程占用的内存情况pmap -x pid | sort -rn -k3 | head -30，这段意思是查看对应 pid 倒序前 30 大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/e1a9f722b6234ecab47cec2cca393680.png\" alt=\"image.png\"></p>\n<p>我们如果确定有可疑的内存端，需要通过 gdb 来分析gdb --batch --pid {pid} -ex &quot;dump memory filename.dump {内存起始地址} {内存起始地址+内存块大小}&quot;</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/c632856b2f4945f195a0bc9f958e314d.png\" alt=\"image.png\"></p>\n<p>获取 dump 文件后可用 heaxdump 进行查看hexdump -C filename | less，不过大多数看到的都是二进制乱码。</p>\n<p>NMT 是 Java7U40 引入的 HotSpot 新特性，配合 jcmd 命令我们就可以看到具体内存组成了。需要在启动参数中加入 -XX:NativeMemoryTracking=summary 或者 -XX:NativeMemoryTracking=detail，会有略微性能损耗。</p>\n<p>一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线jcmd pid VM.native_memory baseline。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/4a6cf290ef724e2aa9b0f7d49efa4df6.png\" alt=\"image.png\"></p>\n<p>然后等放一段时间后再去看看内存增长的情况，通过jcmd pid VM.native_memory detail.diff(summary.diff)做一下 summary 或者 detail 级别的 diff。\n<img src=\"http://oss.osalien.com/dbblog/20200927/41290e8a8eba44eda50321ccbf0200ee.png\" alt=\"image.png\"></p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/5a5a1aacb7724a88a02a969fe47c6ddf.png\" alt=\"image.png\"></p>\n<p>可以看到 jcmd 分析出来的内存十分详细，包括堆内、线程以及 gc(所以上述其他内存异常其实都可以用 nmt 来分析)，这边堆外内存我们重点关注 Internal 的内存增长，如果增长十分明显的话那就是有问题了。</p>\n<p>detail 级别的话还会有具体内存段的增长情况，如下图。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/7d33fe50bc084327a175d3349a073410.png\" alt=\"image.png\"></p>\n<p>此外在系统层面，我们还可以使用 strace 命令来监控内存分配 strace -f -e &quot;brk,mmap,munmap&quot; -p pid</p>\n<p>这边内存分配信息主要包括了 pid 和内存地址。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/199815eca3ec4628bf708b8efe94c442.png\" alt=\"image.png\"></p>\n<p>不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如 DirectByteBuffer 分配内存的话，是需要 full GC 或者手动 system.gc 来进行回收的(所以最好不要使用-XX:+DisableExplicitGC)。那么其实我们可以跟踪一下 DirectByteBuffer 对象的内存情况，通过jmap -histo:live pid手动触发 fullGC 来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过-XX:MaxDirectMemorySize进行调整。如果没有什么变化，那就要使用 jmap 去分析那些不能被 gc 的对象，以及和 DirectByteBuffer 之间的引用关系了。</p>\n<h4 id=\"gc-问题\">GC 问题</h4>\n<p>堆内内存泄漏总是和 GC 异常相伴。不过 GC 问题不只是和内存问题相关，还有可能引起 CPU 负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下 GC 相关问题。</p>\n<p>我们在 CPU 章介绍了使用 jstat 来获取当前 GC 分代变化信息。而更多时候，我们是通过 GC 日志来排查问题的，在启动参数中加上-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps来开启 GC 日志。</p>\n<p>常见的 Young GC、Full GC 日志含义在此就不做赘述了。</p>\n<p>针对 gc 日志，我们就能大致推断出 youngGC 与 fullGC 是否过于频繁或者耗时过长，从而对症下药。我们下面将对 G1 垃圾收集器来做分析，这边也建议大家使用 G1-XX:+UseG1GC。</p>\n<h4 id=\"younggc-过频繁\">youngGC 过频繁</h4>\n<p>youngGC 频繁一般是短周期小对象较多，先考虑是不是 Eden 区/新生代设置的太小了，看能否通过调整-Xmn、-XX:SurvivorRatio 等参数设置来解决问题。如果参数正常，但是 young gc 频率还是太高，就需要使用 Jmap 和 MAT 对 dump 文件进行进一步排查了。</p>\n<h4 id=\"younggc-耗时过长\">youngGC 耗时过长</h4>\n<p>耗时过长问题就要看 GC 日志里耗时耗在哪一块了。以 G1 日志为例，可以关注 Root Scanning、Object Copy、Ref Proc 等阶段。Ref Proc 耗时长，就要注意引用相关的对象。Root Scanning 耗时长，就要注意线程数、跨代引用。Object Copy 则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的 Root Scanning 和正常时间段比增长较多，那就是起的线程太多了。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/947a26cadcc04bc8a870144179c62c39.png\" alt=\"image.png\"></p>\n<h4 id=\"触发-fullgc\">触发 fullGC</h4>\n<p>G1 中更多的还是 mixedGC，但 mixedGC 可以和 youngGC 思路一样去排查。触发 fullGC 了一般都会有问题，G1 会退化使用 Serial 收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。</p>\n<p>fullGC 的原因可能包括以下这些，以及参数调整方面的一些思路：</p>\n<ul>\n<li><p>并发阶段失败：在并发标记阶段，MixGC 之前老年代就被填满了，那么这时候 G1 就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数-XX:ConcGCThreads。</p>\n</li>\n<li><p>晋升失败：在 GC 的时候没有足够的内存供存活/晋升对象使用，所以触发了 Full GC。这时候可以通过-XX:G1ReservePercent来增加预留内存百分比，减少-XX:InitiatingHeapOccupancyPercent来提前启动标记，-XX:ConcGCThreads来增加标记线程数也是可以的。</p>\n</li>\n<li><p>大对象分配失败：大对象找不到合适的 region 空间进行分配，就会进行 fullGC，这种情况下可以增大内存或者增大-XX:G1HeapRegionSize。</p>\n</li>\n<li><p>程序主动执行 System.gc()：不要随便写就对了。</p>\n</li>\n</ul>\n<p>另外，我们可以在启动参数中配置-XX:HeapDumpPath=/xxx/dump.hprof来 dump fullGC 相关的文件，并通过 jinfo 来进行 gc 前后的 dump</p>\n<pre><code>jinfo -flag +HeapDumpBeforeFullGC pid\njinfo -flag +HeapDumpAfterFullGC pid</code></pre><p>这样得到 2 份 dump 文件，对比后主要关注被 gc 掉的问题对象来定位问题。</p>\n<h4 id=\"网络\">网络</h4>\n<p>涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从 tcp 层、应用层以及工具的使用等方面进行阐述。</p>\n<h4 id=\"超时\">超时</h4>\n<p>超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。</p>\n<ul>\n<li><p>读写超时。readTimeout/writeTimeout，有些框架叫做 so_timeout 或者 socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa 的超时指的也是读超时。读写超时一般都只针对客户端设置。</p>\n</li>\n<li><p>连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边 connectionTimeout 就有些五花八门了，Jetty 中表示空闲连接清理时间，Tomcat 则表示连接维持的最大时间。</p>\n</li>\n<li><p>其他。包括连接获取超时 connectionAcquireTimeout 和空闲连接清理超时 idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。</p>\n</li>\n</ul>\n<p>我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。</p>\n<p>在实际开发中，我们关心最多的应该是接口的读写超时了。</p>\n<p>如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的 tcp 连接。而如果接口设置的过短，那么接口超时就会非常频繁。</p>\n<p>服务端接口明明 rt 降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。</p>\n<h4 id=\"tcp-队列溢出\">TCP 队列溢出</h4>\n<p>tcp 队列溢出是个相对底层的错误，它可能会造成超时、rst 等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/5a70a907d7e947709d3cc8f98c3a2af5.png\" alt=\"image.png\"></p>\n<p>如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在 server 收到 client 的 syn 后，把消息放到 syns queue，回复 syn+ack 给 client，server 收到 client 的 ack，如果这时 accept queue 没满，那就从 syns queue 拿出暂存的信息放入 accept queue 中，否则按 tcp_abort_on_overflow 指示的执行。</p>\n<p>tcp_abort_on_overflow 0 表示如果三次握手第三步的时候 accept queue 满了那么 server 扔掉 client 发过来的 ack。tcp_abort_on_overflow 1 则表示第三步的时候如果全连接队列满了，server 发送一个 rst 包给 client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多connection reset / connection reset by peer。</p>\n<p>那么在实际开发中，我们怎么能快速定位到 tcp 队列溢出呢？</p>\n<p>netstat 命令，执行 netstat -s | egrep &quot;listen|LISTEN&quot;</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/7429f7ac0a034cce958bb62d5404599d.png\" alt=\"image.png\"></p>\n<p>如上图所示，overflowed 表示全连接队列溢出的次数，sockets dropped 表示半连接队列溢出的次数。</p>\n<h4 id=\"ss-命令，执行-ss--lnt\">ss 命令，执行 ss -lnt</h4>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/528542ca39d84222b64ee4479f373e07.png\" alt=\"image.png\"></p>\n<p>上面看到 Send-Q 表示第三列的 listen 端口上的全连接队列最大为 5，第一列 Recv-Q 为全连接队列当前使用了多少。</p>\n<p>接着我们看看怎么设置全连接、半连接队列大小吧：</p>\n<p>全连接队列的大小取决于 min(backlog, somaxconn)。backlog 是在 socket 创建的时候传入的，somaxconn 是一个 os 级别的系统参数。而半连接队列的大小取决于 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。</p>\n<p>在日常开发中，我们往往使用 servlet 容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在 Tomcat 中 backlog 叫做acceptCount，在 Jetty 里面则是acceptQueueSize。</p>\n<h4 id=\"rst-异常\">RST 异常</h4>\n<p>RST 包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。</p>\n<p>在实际开发中，我们往往会看到connection reset / connection reset by peer错误，这种情况就是 RST 包导致的。</p>\n<h4 id=\"端口不存在\">端口不存在</h4>\n<p>如果像不存在的端口发出建立连接 SYN 请求，那么服务端发现自己并没有这个端口则会直接返回一个 RST 报文，用于中断连接。</p>\n<h4 id=\"主动代替-fin-终止连接\">主动代替 FIN 终止连接</h4>\n<p>一般来说，正常的连接关闭都是需要通过 FIN 报文实现，然而我们也可以用 RST 报文来代替 FIN，表示直接终止连接。实际开发中，可设置 SO_LINGER 数值来控制，这种往往是故意的，来跳过 TIMED_WAIT，提供交互效率，不闲就慎用。</p>\n<p><strong>客户端或服务端有一边发生了异常，该方向对端发送 RST 以告知关闭连接</strong></p>\n<p>我们上面讲的 tcp 队列溢出发送 RST 包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。</p>\n<p><strong>接收到的 TCP 报文不在已知的 TCP 连接内</strong></p>\n<p>比如，一方机器由于网络实在太差 TCP 报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的 TCP 报文，但由于对应的 TCP 连接已不存在，那么会直接发一个 RST 包以便开启新的连接。</p>\n<p><strong>一方长期未收到另一方的确认报文，在一定时间或重传次数后发出 RST 报文</strong></p>\n<p>这种大多也和网络环境相关了，网络环境差可能会导致更多的 RST 报文。</p>\n<p>之前说过 RST 报文多会导致程序报错，在一个已关闭的连接上读操作会报connection reset，而在一个已关闭的连接上写操作则会报connection reset by peer。通常我们可能还会看到broken pipe错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到 RST，报出connection reset错后继续读写数据报的错，这个在 glibc 源码注释中也有介绍。</p>\n<p>我们在排查故障时候怎么确定有 RST 包的存在呢？当然是使用 tcpdump 命令进行抓包，并使用 wireshark 进行简单分析了。tcpdump -i en0 tcp -w xxx.cap，en0 表示监听的网卡。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/940bcfd015b04240bf8bc050ece98c8d.png\" alt=\"image.png\"></p>\n<p>接下来我们通过 wireshark 打开抓到的包，可能就能看到如下图所示，红色的就表示 RST 包了。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/7a07046d13824178980f1dcc28ff227f.png\" alt=\"image.png\"></p>\n<h4 id=\"time_wait-和-close_wait\">TIME_WAIT 和 CLOSE_WAIT</h4>\n<p>TIME_WAIT 和 CLOSE_WAIT 是啥意思相信大家都知道。</p>\n<p>在线上时，我们可以直接用命令netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;来查看 time-wait 和 close_wait 的数量</p>\n<p>用 ss 命令会更快ss -ant | awk &#39;{++S[$1]} END {for(a in S) print a, S[a]}&#39;</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/2e9d2d2362704767bcf15172774c2ac3.png\" alt=\"image.png\"></p>\n<h4 id=\"time_wait\">TIME_WAIT</h4>\n<p>time_wait 的存在一是为了丢失的数据包被后面连接复用，二是为了在 2MSL 的时间范围内正常关闭连接。它的存在其实会大大减少 RST 包的出现。</p>\n<p>过多的 time_wait 在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:</p>\n<pre><code>#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭\n\nnet.ipv4.tcp_tw_reuse = 1\n\n#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭\n\nnet.ipv4.tcp_tw_recycle = 1</code></pre><p>当然我们不要忘记在 NAT 环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小tcp_max_tw_buckets，超过这个数的 time_wait 都会被干掉，不过这也会导致报time wait bucket table overflow的错。</p>\n<h4 id=\"close_wait\">CLOSE_WAIT</h4>\n<p>close_wait 往往都是因为应用程序写的有问题，没有在 ACK 后再次发起 FIN 报文。close_wait 出现的概率甚至比 time_wait 要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。</p>\n<p>想要定位这类问题，最好是通过 jstack 来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。</p>\n<p>开发同学说应用上线后 CLOSE_WAIT 就一直增多，直到挂掉为止，jstack 后找到比较可疑的堆栈是大部分线程都卡在了countdownlatch.await方法，找开发同学了解后得知使用了多线程但是确没有 catch 异常，修改后发现异常仅仅是最简单的升级 sdk 后常出现的class not found。</p>\n',117,0,22,NULL,NULL,'2020-09-26 23:15:20','2020-09-30 01:04:53',1,'32,42',1,0),(10,'一文讲清楚互斥锁、自旋锁、读写锁、悲观锁、乐观锁','高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。\n所以，知道各种锁的开销，以及应用场景是很有必要的。','小林coding','### 前言\n生活中用到的锁，用途都比较简单粗暴，上锁基本是为了防止外人进来、电动车被偷等等。\n\n但生活中也不是没有 BUG 的，比如加锁的电动车在「广西 - 窃·格瓦拉」面前，锁就是形同虚设，只要他愿意，他就可以轻轻松松地把你电动车给「顺走」，不然打工怎么会是他这辈子不可能的事情呢？牛逼之人，必有牛逼之处。\n\n![image.png](http://oss.osalien.com/dbblog/20200928/d6b0a966913c41e9bd315254527c3d1f.png)\n\n那在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。\n\n如何用好锁，也是程序员的基本素养之一了。\n\n高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。\n\n所以，知道各种锁的开销，以及应用场景是很有必要的。\n\n接下来，就谈一谈常见的这几种锁：\n\n![image.png](http://oss.osalien.com/dbblog/20200928/9a49b16e156e459fb028c7540450093d.png)\n\n----\n\n### 正文\n多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。\n\n最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。\n\n如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。\n\n所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。\n\n对症下药，才能减少锁对高并发性能的影响。\n\n那接下来，针对不同的应用场景，谈一谈「**互斥锁、自旋锁、读写锁、乐观锁、悲观锁**」的选择和使用。\n\n#### 互斥锁与自旋锁：谁更轻松自如？\n\n最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。\n\n加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。\n\n当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：\n\n- **互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；\n- **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁；\n\n互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，**既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。**\n\n**对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的**。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：\n\n![image.png](http://oss.osalien.com/dbblog/20200928/0ff0f991a9d14bd2a1b41ba1e8395487.png)\n\n所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。\n\n那这个开销成本是什么呢？会有**两次线程上下文切换的成本**：\n\n当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；\n接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。\n线程的上下文切换的是什么？当两个线程是属于同一个进程，**因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。**\n\n上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。\n\n所以，**如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。**\n\n自旋锁是通过 CPU 提供的 **CAS** 函数（**Compare And Swap**），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。\n\n一般加锁的过程，包含两个步骤：\n\n- 第一步，查看锁的状态，如果锁是空闲的，则执行第二步；\n- 第二步，将锁设置为当前线程持有；\nCAS 函数就把这两个步骤合并成一条硬件级指令，形成**原子指令**，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。\n\n使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 **while**循环等待实现，不过最好是使用 CPU 提供的 **PAUSE**指令来实现「忙等待」，因为可以减少循环等待时的耗电量。\n\n自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。**需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。**\n\n自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。\n\n自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：**当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对。**\n\n它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。\n\n---\n\n#### 读写锁：读和写还有优先级区分？\n\n读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。\n\n所以，**读写锁适用于能明确区分读操作和写操作的场景。**\n\n读写锁的工作原理是：\n\n- 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。\n- 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。\n所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。\n\n知道了读写锁的工作原理后，我们可以发现，**读写锁在读多写少的场景，能发挥出优势。**\n\n另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。\n\n读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：\n\n![image.png](http://oss.osalien.com/dbblog/20200928/02c9cf3fe63a4cb088c24082441e2cdc.png)\n\n而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：\n\n![image.png](http://oss.osalien.com/dbblog/20200928/f8acc3a9e69d45fdace7b7da76388fcd.png)\n\n读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。\n\n写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。\n\n既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。\n\n**公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。**\n\n互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。\n\n----\n\n#### 乐观锁与悲观锁：做事的心态有何不同？\n\n前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。\n\n悲观锁做事比较悲观，它认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。**\n\n那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。\n\n乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。**\n\n放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。\n\n可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现**乐观锁全程并没有加锁，所以它也叫无锁编程。**\n\n这里举一个场景例子：在线文档。\n\n我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。\n\n那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。\n\n怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。\n\n服务端要怎么验证是否冲突了呢？通常方案如下：\n\n- 由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；\n- 当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。\n\n实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。\n\n乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。**\n\n----\n\n### 总结\n\n开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。\n\n如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。\n\n如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。\n\n互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。\n\n另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。\n\n相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。\n\n但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。\n\n不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。\n\n','<h3 id=\"前言\">前言</h3>\n<p>生活中用到的锁，用途都比较简单粗暴，上锁基本是为了防止外人进来、电动车被偷等等。</p>\n<p>但生活中也不是没有 BUG 的，比如加锁的电动车在「广西 - 窃·格瓦拉」面前，锁就是形同虚设，只要他愿意，他就可以轻轻松松地把你电动车给「顺走」，不然打工怎么会是他这辈子不可能的事情呢？牛逼之人，必有牛逼之处。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200928/d6b0a966913c41e9bd315254527c3d1f.png\" alt=\"image.png\"></p>\n<p>那在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。</p>\n<p>如何用好锁，也是程序员的基本素养之一了。</p>\n<p>高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。</p>\n<p>所以，知道各种锁的开销，以及应用场景是很有必要的。</p>\n<p>接下来，就谈一谈常见的这几种锁：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200928/9a49b16e156e459fb028c7540450093d.png\" alt=\"image.png\"></p>\n<hr>\n<h3 id=\"正文\">正文</h3>\n<p>多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。</p>\n<p>最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。</p>\n<p>如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。</p>\n<p>所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。</p>\n<p>对症下药，才能减少锁对高并发性能的影响。</p>\n<p>那接下来，针对不同的应用场景，谈一谈「<strong>互斥锁、自旋锁、读写锁、乐观锁、悲观锁</strong>」的选择和使用。</p>\n<h4 id=\"互斥锁与自旋锁：谁更轻松自如？\">互斥锁与自旋锁：谁更轻松自如？</h4>\n<p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。</p>\n<p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p>\n<p>当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：</p>\n<ul>\n<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>\n<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>\n</ul>\n<p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。</strong></p>\n<p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200928/0ff0f991a9d14bd2a1b41ba1e8395487.png\" alt=\"image.png\"></p>\n<p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。</p>\n<p>那这个开销成本是什么呢？会有<strong>两次线程上下文切换的成本</strong>：</p>\n<p>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；\n接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。\n线程的上下文切换的是什么？当两个线程是属于同一个进程，<strong>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</strong></p>\n<p>上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。</p>\n<p>所以，<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p>\n<p>自旋锁是通过 CPU 提供的 <strong>CAS</strong> 函数（<strong>Compare And Swap</strong>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p>\n<p>一般加锁的过程，包含两个步骤：</p>\n<ul>\n<li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li>\n<li>第二步，将锁设置为当前线程持有；\nCAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</li>\n</ul>\n<p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <strong>while</strong>循环等待实现，不过最好是使用 CPU 提供的 <strong>PAUSE</strong>指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p>\n<p>自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p>\n<p>自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p>\n<p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对。</strong></p>\n<p>它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。</p>\n<hr>\n<h4 id=\"读写锁：读和写还有优先级区分？\">读写锁：读和写还有优先级区分？</h4>\n<p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p>\n<p>所以，<strong>读写锁适用于能明确区分读操作和写操作的场景。</strong></p>\n<p>读写锁的工作原理是：</p>\n<ul>\n<li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li>\n<li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。\n所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。</li>\n</ul>\n<p>知道了读写锁的工作原理后，我们可以发现，<strong>读写锁在读多写少的场景，能发挥出优势。</strong></p>\n<p>另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。</p>\n<p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200928/02c9cf3fe63a4cb088c24082441e2cdc.png\" alt=\"image.png\"></p>\n<p>而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200928/f8acc3a9e69d45fdace7b7da76388fcd.png\" alt=\"image.png\"></p>\n<p>读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。</p>\n<p>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。</p>\n<p>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。</p>\n<p><strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p>\n<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>\n<hr>\n<h4 id=\"乐观锁与悲观锁：做事的心态有何不同？\">乐观锁与悲观锁：做事的心态有何不同？</h4>\n<p>前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。</p>\n<p>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</strong></p>\n<p>那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</p>\n<p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</strong></p>\n<p>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。</p>\n<p>可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现<strong>乐观锁全程并没有加锁，所以它也叫无锁编程。</strong></p>\n<p>这里举一个场景例子：在线文档。</p>\n<p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p>\n<p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p>\n<p>怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。</p>\n<p>服务端要怎么验证是否冲突了呢？通常方案如下：</p>\n<ul>\n<li>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</li>\n<li>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。</li>\n</ul>\n<p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p>\n<p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p>\n<hr>\n<h3 id=\"总结\">总结</h3>\n<p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p>\n<p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p>\n<p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。</p>\n<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>\n<p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p>\n<p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p>\n<p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p>\n<p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p>\n',215,0,34,NULL,NULL,'2020-09-27 22:43:19','2020-09-30 00:48:35',1,'32,42',1,0),(11,'Java图形验证码支持gif、中文、算术等','图形验证码是最经典，也是最常用的验证方式。今天介绍一个非常不错的类库：Java图形验证码，支持gif、中文、算术等类型，可用于Java Web、JavaSE等项目。',' JAVA乐园','图形验证码是最经典，也是最常用的验证方式。今天介绍一个非常不错的类库：Java图形验证码，支持gif、中文、算术等类型，可用于Java Web、JavaSE等项目。\n\n官网：\n```\nhttps://gitee.com/whvse/EasyCaptcha\n```\n效果图：\n\n![image.png](http://oss.osalien.com/dbblog/20200929/5db8f7a3297645c393145c983f2e8272.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/26bb7b26e582465e9b09b7f9735348bb.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/02ab3d266f0b43f0b9d19ed62ae53ab6.png)\n\n![msFvb6.gif](http://oss.osalien.com/dbblog/20200929/52be7ba2332041f1abfd7227c4324066.gif)&emsp;![msFXK1.gif](http://oss.osalien.com/dbblog/20200929/3f2b63cfa9ab4b35a1c6c5a0bdbaf58f.gif)&emsp;![msFzVK.gif](http://oss.osalien.com/dbblog/20200929/81d7a8d9455b4799b9c640ce1e746abd.gif)\n\n算术类型：\n\n![image.png](http://oss.osalien.com/dbblog/20200929/9eadd044c4c5409dae039cbf8418f66f.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/f60589d25ce141e08f62daddb2228e12.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/9fe6e08842434b01bab6d7b7b3cfa604.png)\n\n中文类型：\n\n![image.png](http://oss.osalien.com/dbblog/20200929/c633a03a8a6b4ed0a82b9bf2eea1242f.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/5a2242c00c894af88b139ef3e2ff268a.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/611b85fb037843f084de98902f434930.png)\n\n内置字体：\n\n![image.png](http://oss.osalien.com/dbblog/20200929/0176cc600a554e0aad31eafe09a1c66a.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/30ee91ee22554d39a3f125cd998d2c23.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/576f09b3e1954019bcae81b0a5fce5e9.png)\n\n#### 0x01：项目引入easy-captcha\n```\n<dependencies>\n   <dependency>\n      <groupId>com.github.whvcse</groupId>\n      <artifactId>easy-captcha</artifactId>\n      <version>1.6.2</version>\n   </dependency>\n</dependencies>\n```\n#### 0x02：SpringBoot项目创建图形验证码\n\n前后端分离项目中建议不要存储在session中；而使用分布式session，存储在redis中，redis存储需要一个key，key一同返回给前端用于验证输入。\n```\n@Controller\npublic class CaptchaController {\n\n    @Autowired\n    private RedisUtil redisUtil;\n\n    @ResponseBody\n    @RequestMapping(\"/vcode/captcha\")\n    public JsonResult captcha(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        SpecCaptcha specCaptcha = new SpecCaptcha(130, 48, 5);\n        String verCode = specCaptcha.text().toLowerCase();\n        String key = UUID.randomUUID().toString();\n        // 存入redis并设置过期时间为30分钟\n        redisUtil.setEx(key, verCode, 30, TimeUnit.MINUTES);\n        // 将key和base64返回给前端\n        return JsonResult.ok().put(\"key\", key).put(\"image\", specCaptcha.toBase64());\n    }\n\n    @ResponseBody\n    @PostMapping(\"/vcode/vaild\")\n    public JsonResult login(String username,String password,String verCode,String verKey){\n        // 获取redis中的验证码\n        String redisCode = redisUtil.get(verKey);\n        // 判断验证码\n        if (verCode==null || !redisCode.equals(verCode.trim().toLowerCase())) {\n            return JsonResult.error(\"验证码不正确\");\n        }\n    }  \n}\n```\n#### 0x03：前端使用ajax获取验证码并验证\n```\n<img id=\"verImg\" width=\"130px\" height=\"48px\"/>\n\n<script>\n    var verKey;\n    // 获取验证码\n    $.get(\'/vcode/captcha\', function(res) {\n        verKey = res.key;\n        $(\'#verImg\').attr(\'src\', res.image);\n    },\'json\');\n\n    // 登录\n    $.post(\'/vcode/login\', {\n        verKey: verKey,\n        verCode: \'8u6h\',\n        username: \'admin\'，\n        password: \'admin\'\n    }, function(res) {\n        console.log(res);\n    }, \'json\');\n</script>\n```','<p>图形验证码是最经典，也是最常用的验证方式。今天介绍一个非常不错的类库：Java图形验证码，支持gif、中文、算术等类型，可用于Java Web、JavaSE等项目。</p>\n<p>官网：</p>\n<pre><code>https://gitee.com/whvse/EasyCaptcha</code></pre><p>效果图：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200929/5db8f7a3297645c393145c983f2e8272.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/26bb7b26e582465e9b09b7f9735348bb.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/02ab3d266f0b43f0b9d19ed62ae53ab6.png\" alt=\"image.png\"></p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200929/52be7ba2332041f1abfd7227c4324066.gif\" alt=\"msFvb6.gif\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/3f2b63cfa9ab4b35a1c6c5a0bdbaf58f.gif\" alt=\"msFXK1.gif\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/81d7a8d9455b4799b9c640ce1e746abd.gif\" alt=\"msFzVK.gif\"></p>\n<p>算术类型：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200929/9eadd044c4c5409dae039cbf8418f66f.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/f60589d25ce141e08f62daddb2228e12.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/9fe6e08842434b01bab6d7b7b3cfa604.png\" alt=\"image.png\"></p>\n<p>中文类型：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200929/c633a03a8a6b4ed0a82b9bf2eea1242f.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/5a2242c00c894af88b139ef3e2ff268a.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/611b85fb037843f084de98902f434930.png\" alt=\"image.png\"></p>\n<p>内置字体：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200929/0176cc600a554e0aad31eafe09a1c66a.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/30ee91ee22554d39a3f125cd998d2c23.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/576f09b3e1954019bcae81b0a5fce5e9.png\" alt=\"image.png\"></p>\n<h4 id=\"0x01：项目引入easy-captcha\">0x01：项目引入easy-captcha</h4>\n<pre><code>&lt;dependencies&gt;\n   &lt;dependency&gt;\n      &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt;\n      &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt;\n      &lt;version&gt;1.6.2&lt;/version&gt;\n   &lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre><h4 id=\"0x02：springboot项目创建图形验证码\">0x02：SpringBoot项目创建图形验证码</h4>\n<p>前后端分离项目中建议不要存储在session中；而使用分布式session，存储在redis中，redis存储需要一个key，key一同返回给前端用于验证输入。</p>\n<pre><code>@Controller\npublic class CaptchaController {\n\n    @Autowired\n    private RedisUtil redisUtil;\n\n    @ResponseBody\n    @RequestMapping(&quot;/vcode/captcha&quot;)\n    public JsonResult captcha(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        SpecCaptcha specCaptcha = new SpecCaptcha(130, 48, 5);\n        String verCode = specCaptcha.text().toLowerCase();\n        String key = UUID.randomUUID().toString();\n        // 存入redis并设置过期时间为30分钟\n        redisUtil.setEx(key, verCode, 30, TimeUnit.MINUTES);\n        // 将key和base64返回给前端\n        return JsonResult.ok().put(&quot;key&quot;, key).put(&quot;image&quot;, specCaptcha.toBase64());\n    }\n\n    @ResponseBody\n    @PostMapping(&quot;/vcode/vaild&quot;)\n    public JsonResult login(String username,String password,String verCode,String verKey){\n        // 获取redis中的验证码\n        String redisCode = redisUtil.get(verKey);\n        // 判断验证码\n        if (verCode==null || !redisCode.equals(verCode.trim().toLowerCase())) {\n            return JsonResult.error(&quot;验证码不正确&quot;);\n        }\n    }  \n}</code></pre><h4 id=\"0x03：前端使用ajax获取验证码并验证\">0x03：前端使用ajax获取验证码并验证</h4>\n<pre><code>&lt;img id=&quot;verImg&quot; width=&quot;130px&quot; height=&quot;48px&quot;/&gt;\n\n&lt;script&gt;\n    var verKey;\n    // 获取验证码\n    $.get(&#39;/vcode/captcha&#39;, function(res) {\n        verKey = res.key;\n        $(&#39;#verImg&#39;).attr(&#39;src&#39;, res.image);\n    },&#39;json&#39;);\n\n    // 登录\n    $.post(&#39;/vcode/login&#39;, {\n        verKey: verKey,\n        verCode: &#39;8u6h&#39;,\n        username: &#39;admin&#39;，\n        password: &#39;admin&#39;\n    }, function(res) {\n        console.log(res);\n    }, &#39;json&#39;);\n&lt;/script&gt;</code></pre>',24,0,0,NULL,NULL,'2020-09-28 19:16:18','2020-09-30 00:48:09',0,'32,43,50',1,0),(12,'各种OOM代码样例及解决方法','针对目前大家对OOM的类型不太熟悉，那么来总结一下各种OOM出现的情况以及解决方法。把各种OOM的情况列出来，然后逐一进行代码编写复现和提供解决方法。','JAVA乐园','针对目前大家对OOM的类型不太熟悉，那么来总结一下各种OOM出现的情况以及解决方法。把各种OOM的情况列出来，然后逐一进行代码编写复现和提供解决方法。\n\n1. 堆溢出-java.lang.OutOfMemoryError: Java heap space。\n2. 栈溢出-java.lang.OutOfMemorryError。\n3. 栈溢出-java.lang.StackOverFlowError。\n4. 元信息溢出-java.lang.OutOfMemoryError: Metaspace。\n5. 直接内存溢出-java.lang.OutOfMemoryError: Direct buffer memory。\n6. GC超限-java.lang.OutOfMemoryError: GC overhead limit exceeded。\n\n### 0x01: 堆溢出\n\n堆溢出异常，相信大家很常见。即堆内对象不能进行回收了，堆内存持续增大，这样达到了堆内存的最大值，数据满了，所以就出来了。我们直接放溢出的代码样例。需要设置好idea的VM Options: -Xmx100m，这样设置为最大堆内存，这样运行起来就很快就出来错误了。\n\n```\npackage oom;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class HeapOOM {\n\n    static class OOMObject {\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        List<OOMObject> list = new ArrayList<>();\n\n        while(true) {\n//            TimeUnit.MILLISECONDS.sleep(1);\n            list.add(new OOMObject());\n        }\n    }\n\n}\n```\n\n运行的异常如下，代码直接就出来我们看到的异常了。\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xmx100m -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.HeapOOM\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n    at java.util.Arrays.copyOf(Arrays.java:3210)\n    at java.util.Arrays.copyOf(Arrays.java:3181)\n    at java.util.ArrayList.grow(ArrayList.java:261)\n    at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)\n    at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)\n    at java.util.ArrayList.add(ArrayList.java:458)\n    at oom.HeapOOM.main(HeapOOM.java:21)\n\nProcess finished with exit code 1\n```\n\n细心的小伙伴可以发现代码中设置了一个休眠，目的是看一下堆内存的结构和数据图。将休眠代码打开，然后打开JDK自带的jconsole命令，连接上之后看一下概览图，通过下图发现堆内存持续不断的增长。\n\n![image.png](http://oss.osalien.com/dbblog/20201009/ce46094ddf10467497bdeb3df7f38ec8.png)\n\n打开内存界面，看一下内存，然后点一下GC按钮，这个时候会有一些类进行回收，但是还是会继续增长，看一下下面的图。\n\n![image.png](http://oss.osalien.com/dbblog/20201009/dc15839cbd7e4130b4295b9f80f5ffe5.png)\n\n![image.png](http://oss.osalien.com/dbblog/20201009/f11f47101ba743fda59417cdefeb12c3.png)\n\n点开信息标签看一下。经过几次GC回收之后，类的数据量还是变化不大，说明没有进行回收。\n\n![image.png](http://oss.osalien.com/dbblog/20201009/04e7ebfb652e4092ac48f6cfafd699c0.png)\n\n以上这种情况的解决方法就是找到问题点，分析哪个地方是否存储了大量类没有被回收的情况，通过JMAP命令将线上的堆内存导出来后进行分析。\n\n### 0x02: 栈溢出-OutOfMemorryError\n\n看一下栈溢出的情况，下面的代码就是无限的创建线程，直到没法再创建线程。\n\n```\npackage oom;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Date 2020-07-18\n */\npublic class StackOOM {\n\n    public static void infiniteRun() {\n        while(true) {\n            Thread thread = new Thread(() -> {\n\n                while (true) {\n                    try {\n                        TimeUnit.HOURS.sleep(1);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n            });\n            thread.start();\n        }\n    }\n\n    public static void main(String[] args) {\n        infiniteRun();\n    }\n\n}\n```\n\n抛出来的异常如下，如果真的需要创建线程，我们需要调整帧栈的大小-Xss512k，默认帧栈大小为1M，如果设置小了，可以创建更多线程。\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xss512k -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.StackOOM\nException in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread\n    at java.lang.Thread.start0(Native Method)\n    at java.lang.Thread.start(Thread.java:717)\n    at oom.StackOOM.infiniteRun(StackOOM.java:24)\n    at oom.StackOOM.main(StackOOM.java:29)\n\nProcess finished with exit code 130 (interrupted by signal 2: SIGINT)\n```\n\n以上这种情况是帧栈不够用了，如果出现了这种情况，需要了解什么地方创建了很多线程，线上程序需要用jstack命令，将当前线程的状态导出来放到文件里边，然后将文件上传到fastthread.io网站上进行分析。\n\n### 0x03: 栈溢出-StackOverFlowError\n\n看一下栈溢出的另一种情况，这就是栈的StackOverFlow的情况。下面就是一个死循环递归调用。\n\n```\npackage oom;\n\n/**\n * @Date 2020-07-18\n */\npublic class StackOFE {\n\n    public static void stackOverFlowErrorMethod() {\n        stackOverFlowErrorMethod();\n    }\n\n    public static void main(String[] args) {\n        stackOverFlowErrorMethod();\n    }\n\n}\n```\n\n运行之后出现的错误如下，程序每次递归的时候，程序会把数据结果压入栈，包括里边的指针等，这个时候就需要帧栈大一些才能承受住更多的递归调用。通过-Xss进行设置，上边的例子需要设置小一些，以分配更多的帧栈，这次是一个帧栈需要记录程序数据，所以需要更大的值。\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xss2m -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.StackOFE\nException in thread \"main\" java.lang.StackOverflowError\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n```\n\n遇到上面的情况下，那么就需要通过jstack将线程数据导到文件进行分析。找到递归的点，如果程序就是需要递归的次数的话，那么这个时候就需要增大帧栈的大小以适应程序。\n\n### 0x04: 元信息溢出\n\n元数据区域溢出，元数据区域也成为方法区，存储着类的相关信息，常量池，方法描述符，字段描述符，运行时产生大量的类就会造成这个区域的溢出。我们运行的时候指定一下元数据区域的大小，设置到idea的VM options里边：-XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=30M。\n\n```\npackage oom;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n/**\n * @Date 2020-07-18\n */\npublic class MetaspaceOOM {\n\n    static class OOMObject{}\n\n    public static void main(String[] args) {\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() {\n                public Object intercept(Object obj, Method method,\n                                        Object[] args, MethodProxy proxy) throws Throwable {\n                    return proxy.invokeSuper(obj, args);\n                }\n            });\n            enhancer.create();\n        }\n    }\n\n}\n```\n\n运行的结果如下，元数据信息溢出了。这种情况产生的原因有：通过CBLIG大量生成类，导致Meta信息满了；JDK7的时候使用String.intern()不当，会产生大量常量数据；加载大量的jsp以及动态生成jsp文件。需要调整元数据空间的大小，如果调大了之后还出现了这种异常，我们需要分析哪里出现的溢出并fix掉\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=30M -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar:/Users/huangqingshi/.m2/repository/cglib/cglib/3.2.5/cglib-3.2.5.jar:/Users/huangqingshi/.m2/repository/org/ow2/asm/asm/5.2/asm-5.2.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant/1.9.6/ant-1.9.6.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant-launcher/1.9.6/ant-launcher-1.9.6.jar oom.MetaspaceOOM\nException in thread \"main\" java.lang.OutOfMemoryError: Metaspace\n    at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:345)\n    at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)\n    at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:114)\n    at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:291)\n    at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)\n    at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)\n    at oom.MetaspaceOOM.main(MetaspaceOOM.java:28)\n\nProcess finished with exit code 1\n```\n\n### 0x05: 直接内存溢出\n\n直接内存溢出，除了使用堆内存外，还可能用直接内存，即堆外内存。NIO为了提高性能，避免在Java Heap和native Heap中切换，所以使用直接内存，默认情况下，直接内存的大小和对内存大小一致。堆外内存不受JVM的限制，但是受制于机器整体内存的大小限制。如下代码设置堆最大内存为128m，直接内存为100m，然后我们每次分配1M放到list里边。　\n\n```\n-Xmx128m -XX:MaxDirectMemorySize=100M\n\npackage oom;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @Date 2020-07-18\n */\npublic class DirectBufferOOM {\n\n    public static void main(String[] args) {\n        final int _1M = 1024 * 1024 * 1;\n        List<ByteBuffer> buffers = new ArrayList<>();\n        int count = 1;\n        while (true) {\n            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);\n            buffers.add(byteBuffer);\n            System.out.println(count++);\n        }\n\n    }\n}\n```\n\n这个时候，当输出100次的时候，下次再分配的时候会报OOM-Direct buffer memory。\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xmx128m -XX:MaxDirectMemorySize=100M -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar:/Users/huangqingshi/.m2/repository/cglib/cglib/3.2.5/cglib-3.2.5.jar:/Users/huangqingshi/.m2/repository/org/ow2/asm/asm/5.2/asm-5.2.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant/1.9.6/ant-1.9.6.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant-launcher/1.9.6/ant-launcher-1.9.6.jar oom.DirectBufferOOM\n\nException in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory\n    at java.nio.Bits.reserveMemory(Bits.java:694)\n    at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123)\n    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)\n    at oom.DirectBufferOOM.main(DirectBufferOOM.java:18)\n\nProcess finished with exit code 1\n```\n\n这种情况是我们使用直接内存造成溢出，这个时候我们需要检查一下程序里边是否使用的NIO及NIO，比如Netty，里边的直接内存的配置。\n\n### 0x06: GC超限\n\nJDK1.6之后新增了一个错误类型，如果堆内存太小的时候会报这个错误。如果98%的GC的时候回收不到2%的时候会报这个错误，也就是最小最大内存出现了问题的时候会报这个错误。如果代码配置了最小最大堆内存都为10m。　\n\n```\n-Xmx10m -Xms10m\n\npackage oom;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * @Date 2020-07-18\n */\npublic class GCOverheadOOM {\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(5);\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n            executor.execute(() -> {\n                try {\n                    Thread.sleep(10000);\n                } catch (InterruptedException e) {\n                    //do nothing\n                }\n            });\n        }\n\n    }\n\n}\n```\n\n这个创建了一个线程池，如果线程池执行的时候如果核心线程处理不过来的时候会把数据放到LinkedBlockingQueue里边，也就是堆内存当中。这个时候我们需要检查-Xms -Xmx最小最大堆配置是否合理。再一个dump出现当前内存来分析一下是否使用了大量的循环或使用大量内存代码。\n\n以上就是经常遇到的情况，需要针对出现的不同情况进行分析和处理。','<p>针对目前大家对OOM的类型不太熟悉，那么来总结一下各种OOM出现的情况以及解决方法。把各种OOM的情况列出来，然后逐一进行代码编写复现和提供解决方法。</p>\n<ol>\n<li>堆溢出-java.lang.OutOfMemoryError: Java heap space。</li>\n<li>栈溢出-java.lang.OutOfMemorryError。</li>\n<li>栈溢出-java.lang.StackOverFlowError。</li>\n<li>元信息溢出-java.lang.OutOfMemoryError: Metaspace。</li>\n<li>直接内存溢出-java.lang.OutOfMemoryError: Direct buffer memory。</li>\n<li>GC超限-java.lang.OutOfMemoryError: GC overhead limit exceeded。</li>\n</ol>\n<h3 id=\"0x01-堆溢出\">0x01: 堆溢出</h3>\n<p>堆溢出异常，相信大家很常见。即堆内对象不能进行回收了，堆内存持续增大，这样达到了堆内存的最大值，数据满了，所以就出来了。我们直接放溢出的代码样例。需要设置好idea的VM Options: -Xmx100m，这样设置为最大堆内存，这样运行起来就很快就出来错误了。</p>\n<pre><code>package oom;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class HeapOOM {\n\n    static class OOMObject {\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();\n\n        while(true) {\n//            TimeUnit.MILLISECONDS.sleep(1);\n            list.add(new OOMObject());\n        }\n    }\n\n}</code></pre><p>运行的异常如下，代码直接就出来我们看到的异常了。</p>\n<pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xmx100m -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.HeapOOM\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space\n    at java.util.Arrays.copyOf(Arrays.java:3210)\n    at java.util.Arrays.copyOf(Arrays.java:3181)\n    at java.util.ArrayList.grow(ArrayList.java:261)\n    at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)\n    at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)\n    at java.util.ArrayList.add(ArrayList.java:458)\n    at oom.HeapOOM.main(HeapOOM.java:21)\n\nProcess finished with exit code 1</code></pre><p>细心的小伙伴可以发现代码中设置了一个休眠，目的是看一下堆内存的结构和数据图。将休眠代码打开，然后打开JDK自带的jconsole命令，连接上之后看一下概览图，通过下图发现堆内存持续不断的增长。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201009/ce46094ddf10467497bdeb3df7f38ec8.png\" alt=\"image.png\"></p>\n<p>打开内存界面，看一下内存，然后点一下GC按钮，这个时候会有一些类进行回收，但是还是会继续增长，看一下下面的图。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201009/dc15839cbd7e4130b4295b9f80f5ffe5.png\" alt=\"image.png\"></p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201009/f11f47101ba743fda59417cdefeb12c3.png\" alt=\"image.png\"></p>\n<p>点开信息标签看一下。经过几次GC回收之后，类的数据量还是变化不大，说明没有进行回收。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201009/04e7ebfb652e4092ac48f6cfafd699c0.png\" alt=\"image.png\"></p>\n<p>以上这种情况的解决方法就是找到问题点，分析哪个地方是否存储了大量类没有被回收的情况，通过JMAP命令将线上的堆内存导出来后进行分析。</p>\n<h3 id=\"0x02-栈溢出-outofmemorryerror\">0x02: 栈溢出-OutOfMemorryError</h3>\n<p>看一下栈溢出的情况，下面的代码就是无限的创建线程，直到没法再创建线程。</p>\n<pre><code>package oom;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Date 2020-07-18\n */\npublic class StackOOM {\n\n    public static void infiniteRun() {\n        while(true) {\n            Thread thread = new Thread(() -&gt; {\n\n                while (true) {\n                    try {\n                        TimeUnit.HOURS.sleep(1);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n            });\n            thread.start();\n        }\n    }\n\n    public static void main(String[] args) {\n        infiniteRun();\n    }\n\n}</code></pre><p>抛出来的异常如下，如果真的需要创建线程，我们需要调整帧栈的大小-Xss512k，默认帧栈大小为1M，如果设置小了，可以创建更多线程。</p>\n<pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xss512k -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.StackOOM\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread\n    at java.lang.Thread.start0(Native Method)\n    at java.lang.Thread.start(Thread.java:717)\n    at oom.StackOOM.infiniteRun(StackOOM.java:24)\n    at oom.StackOOM.main(StackOOM.java:29)\n\nProcess finished with exit code 130 (interrupted by signal 2: SIGINT)</code></pre><p>以上这种情况是帧栈不够用了，如果出现了这种情况，需要了解什么地方创建了很多线程，线上程序需要用jstack命令，将当前线程的状态导出来放到文件里边，然后将文件上传到fastthread.io网站上进行分析。</p>\n<h3 id=\"0x03-栈溢出-stackoverflowerror\">0x03: 栈溢出-StackOverFlowError</h3>\n<p>看一下栈溢出的另一种情况，这就是栈的StackOverFlow的情况。下面就是一个死循环递归调用。</p>\n<pre><code>package oom;\n\n/**\n * @Date 2020-07-18\n */\npublic class StackOFE {\n\n    public static void stackOverFlowErrorMethod() {\n        stackOverFlowErrorMethod();\n    }\n\n    public static void main(String[] args) {\n        stackOverFlowErrorMethod();\n    }\n\n}</code></pre><p>运行之后出现的错误如下，程序每次递归的时候，程序会把数据结果压入栈，包括里边的指针等，这个时候就需要帧栈大一些才能承受住更多的递归调用。通过-Xss进行设置，上边的例子需要设置小一些，以分配更多的帧栈，这次是一个帧栈需要记录程序数据，所以需要更大的值。</p>\n<pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xss2m -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.StackOFE\nException in thread &quot;main&quot; java.lang.StackOverflowError\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)</code></pre><p>遇到上面的情况下，那么就需要通过jstack将线程数据导到文件进行分析。找到递归的点，如果程序就是需要递归的次数的话，那么这个时候就需要增大帧栈的大小以适应程序。</p>\n<h3 id=\"0x04-元信息溢出\">0x04: 元信息溢出</h3>\n<p>元数据区域溢出，元数据区域也成为方法区，存储着类的相关信息，常量池，方法描述符，字段描述符，运行时产生大量的类就会造成这个区域的溢出。我们运行的时候指定一下元数据区域的大小，设置到idea的VM options里边：-XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=30M。</p>\n<pre><code>package oom;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n/**\n * @Date 2020-07-18\n */\npublic class MetaspaceOOM {\n\n    static class OOMObject{}\n\n    public static void main(String[] args) {\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() {\n                public Object intercept(Object obj, Method method,\n                                        Object[] args, MethodProxy proxy) throws Throwable {\n                    return proxy.invokeSuper(obj, args);\n                }\n            });\n            enhancer.create();\n        }\n    }\n\n}</code></pre><p>运行的结果如下，元数据信息溢出了。这种情况产生的原因有：通过CBLIG大量生成类，导致Meta信息满了；JDK7的时候使用String.intern()不当，会产生大量常量数据；加载大量的jsp以及动态生成jsp文件。需要调整元数据空间的大小，如果调大了之后还出现了这种异常，我们需要分析哪里出现的溢出并fix掉</p>\n<pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=30M -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar:/Users/huangqingshi/.m2/repository/cglib/cglib/3.2.5/cglib-3.2.5.jar:/Users/huangqingshi/.m2/repository/org/ow2/asm/asm/5.2/asm-5.2.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant/1.9.6/ant-1.9.6.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant-launcher/1.9.6/ant-launcher-1.9.6.jar oom.MetaspaceOOM\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace\n    at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:345)\n    at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)\n    at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:114)\n    at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:291)\n    at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)\n    at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)\n    at oom.MetaspaceOOM.main(MetaspaceOOM.java:28)\n\nProcess finished with exit code 1</code></pre><h3 id=\"0x05-直接内存溢出\">0x05: 直接内存溢出</h3>\n<p>直接内存溢出，除了使用堆内存外，还可能用直接内存，即堆外内存。NIO为了提高性能，避免在Java Heap和native Heap中切换，所以使用直接内存，默认情况下，直接内存的大小和对内存大小一致。堆外内存不受JVM的限制，但是受制于机器整体内存的大小限制。如下代码设置堆最大内存为128m，直接内存为100m，然后我们每次分配1M放到list里边。　</p>\n<pre><code>-Xmx128m -XX:MaxDirectMemorySize=100M\n\npackage oom;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @Date 2020-07-18\n */\npublic class DirectBufferOOM {\n\n    public static void main(String[] args) {\n        final int _1M = 1024 * 1024 * 1;\n        List&lt;ByteBuffer&gt; buffers = new ArrayList&lt;&gt;();\n        int count = 1;\n        while (true) {\n            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);\n            buffers.add(byteBuffer);\n            System.out.println(count++);\n        }\n\n    }\n}</code></pre><p>这个时候，当输出100次的时候，下次再分配的时候会报OOM-Direct buffer memory。</p>\n<pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xmx128m -XX:MaxDirectMemorySize=100M -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar:/Users/huangqingshi/.m2/repository/cglib/cglib/3.2.5/cglib-3.2.5.jar:/Users/huangqingshi/.m2/repository/org/ow2/asm/asm/5.2/asm-5.2.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant/1.9.6/ant-1.9.6.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant-launcher/1.9.6/ant-launcher-1.9.6.jar oom.DirectBufferOOM\n\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory\n    at java.nio.Bits.reserveMemory(Bits.java:694)\n    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)\n    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)\n    at oom.DirectBufferOOM.main(DirectBufferOOM.java:18)\n\nProcess finished with exit code 1</code></pre><p>这种情况是我们使用直接内存造成溢出，这个时候我们需要检查一下程序里边是否使用的NIO及NIO，比如Netty，里边的直接内存的配置。</p>\n<h3 id=\"0x06-gc超限\">0x06: GC超限</h3>\n<p>JDK1.6之后新增了一个错误类型，如果堆内存太小的时候会报这个错误。如果98%的GC的时候回收不到2%的时候会报这个错误，也就是最小最大内存出现了问题的时候会报这个错误。如果代码配置了最小最大堆内存都为10m。　</p>\n<pre><code>-Xmx10m -Xms10m\n\npackage oom;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * @Date 2020-07-18\n */\npublic class GCOverheadOOM {\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(5);\n        for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {\n            executor.execute(() -&gt; {\n                try {\n                    Thread.sleep(10000);\n                } catch (InterruptedException e) {\n                    //do nothing\n                }\n            });\n        }\n\n    }\n\n}</code></pre><p>这个创建了一个线程池，如果线程池执行的时候如果核心线程处理不过来的时候会把数据放到LinkedBlockingQueue里边，也就是堆内存当中。这个时候我们需要检查-Xms -Xmx最小最大堆配置是否合理。再一个dump出现当前内存来分析一下是否使用了大量的循环或使用大量内存代码。</p>\n<p>以上就是经常遇到的情况，需要针对出现的不同情况进行分析和处理。</p>\n',104,0,11,NULL,NULL,'2020-07-20 21:50:54','2020-10-08 21:59:17',0,'32,42',1,0);
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `book`
--

DROP TABLE IF EXISTS `book`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(100) DEFAULT NULL COMMENT '标题',
  `cover` varchar(255) DEFAULT NULL COMMENT '封面',
  `author` varchar(50) DEFAULT NULL COMMENT '作者',
  `category_id` varchar(20) DEFAULT NULL COMMENT '分类类别',
  `recommend` tinyint(1) DEFAULT '0' COMMENT '是否推荐',
  `publisher` varchar(100) DEFAULT NULL COMMENT '出版社',
  `publish_date` date DEFAULT NULL COMMENT '出版日期',
  `page_num` int(11) DEFAULT NULL COMMENT '页数',
  `grade` double DEFAULT NULL COMMENT '评分',
  `description` text COMMENT '简介',
  `catalogue` text COMMENT '原书目录',
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  `read_num` int(11) DEFAULT '0' COMMENT '阅读量',
  `comment_num` int(11) DEFAULT '0' COMMENT '评论量',
  `like_num` int(11) DEFAULT '0' COMMENT '点赞量',
  `publish` tinyint(1) DEFAULT '0' COMMENT '是否发布',
  `progress` int(11) DEFAULT '0' COMMENT '读书状态',
  `reading` tinyint(1) DEFAULT NULL COMMENT '是否阅读',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='图书表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book`
--

LOCK TABLES `book` WRITE;
/*!40000 ALTER TABLE `book` DISABLE KEYS */;
INSERT INTO `book` VALUES (1,'LeetCode','http://oss.osalien.com/dbblog/20200629/4e1dd67b2f5c45ddb50fe26aab551ca6.jpg','leetcode','55,31',1,'leetcode出版社','2016-11-01',1699,5,'<p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><span style=\"color: rgb(38, 38, 38);\">﻿每一个不曾起舞的日子都是对生命的一种辜负</span></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p>','<p>1. 两数之和</p><p>2. 两数相加</p><p>3. 无重复字符的最长子串</p><p>4. 寻找两个有序数组的中位数</p><p>6. Z字形变换</p><p>7. 反转整数</p><p>8. 字符串转换整数</p><p>9. 回文数</p><p>12. 整数转罗马数字</p><p>13. 罗马数字转整数</p><p>14. 最长公共前缀</p><p>15. 三数之和</p><p>16. 最接近的三数之和</p><p>17. 电话号码的字母组合</p><p>18. 四数之和</p><p>19. 删除链表的倒数第N个节点</p><p>20. 有效的括号</p><p><br></p><p>waiting...</p>','2019-06-29 00:23:17','2020-09-30 08:56:20',22,0,0,1,10,1),(2,'Java核心技术·卷 I（原书第10版）','http://oss.osalien.com/dbblog/20200930/8d3ff46326fb4e59ae2b916af98b45af.jpg','凯 S.霍斯特曼 (Cay S. Horstmann)','52,39',1,'机械工业出版社出版','2016-09-01',711,4,'<p>Java领域最有影响力和价值的著作之一，由拥有20多年教学与研究经验的资深Java技术专家撰写(获Jolt大奖)，与《Java编程思想》齐名，10余年全球畅销不衰，广受好评。第10版根据Java SE 8全面更新，同时修正了第9版中的不足，系统全面讲解了Java语言的核 心概念、语法、重要特性和开发方法，包含大量案例，实践性强。</p><p>一直以来，《Java核心技术》都被认为是面向高级程序员的经典教程和参考书，它内容翔实、客观准确，不拖泥带水，是想为实际应用编写健壮Java代码的程序员的首选。如今，本版进行了全面更新， 以反映近年来人们翘首以待、变革最大的Java版本（Java SE 8）的内容。这一版经过重写，并重新组织，全面阐释了新的Java SE 8特性、惯用法和*佳实践，其中包含数百个示例程序，所有这些代码都经过精心设计，不仅易于理解，也很容易实际应用。</p><p>本书为专业程序员解决实际问题而写，可以帮助你深入了解Java语言和库。在卷I中，Horstmann主要强调基本语言概念和现代用户界面编程基础，深入介绍了从Java面向对象编程到泛型、集合、lambda表达式、Swing UI设计以及并发和函数式编程的*新方法等内容。</p>','<p><span style=\"color: rgb(17, 17, 17);\">译者序</span></p><p><span style=\"color: rgb(17, 17, 17);\">前言</span></p><p><span style=\"color: rgb(17, 17, 17);\">致谢</span></p><p><span style=\"color: rgb(17, 17, 17);\">第1章　Java程序设计概述 1</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.1　Java程序设计平台 1</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2　Java“白皮书”的关键术语 2</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.1　简单性 2</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.2　面向对象 2</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.3　分布式 3</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.4　健壮性 3</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.5　安全性 3</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.6　体系结构中立 4</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.7　可移植性 4</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.8　解释型 5</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.9　高性能 5</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.10　多线程 5</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.11　动态性 5</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.3　Java applet与Internet 6</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.4　Java发展简史 7</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.5　关于Java的常见误解 9</span></p><p><span style=\"color: rgb(17, 17, 17);\">第2章　Java程序设计环境 12</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.1　安装Java开发工具包 12</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.1.1　下载JDK 12</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.1.2　设置JDK 13</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.1.3　安装库源文件和文档 15</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.2　使用命令行工具 16</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.3　使用集成开发环境 18</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.4　运行图形化应用程序 21</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.5　构建并运行applet 23</span></p><p><span style=\"color: rgb(17, 17, 17);\">第3章　Java的基本程序设计结构 28</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.1　一个简单的Java应用程序 28</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.2　注释 31</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3　数据类型 32</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3.1　整型 32</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3.2　浮点类型 33</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3.3　char类型 34</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3.4　Unicode和char类型 35</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3.5　boolean类型 35</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.4　变量 36</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.4.1　变量初始化 37</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.4.2　常量 37</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5　运算符 38</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.1　数学函数与常量 39</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.2　数值类型之间的转换 40</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.3　强制类型转换 41</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.4　结合赋值和运算符 42</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.5　自增与自减运算符 42</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.6　关系和boolean运算符 42</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.7　位运算符 43</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.8　括号与运算符级别 44</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.9　枚举类型 45</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6　字符串 45</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.1　子串 45</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.2　拼接 46</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.3　不可变字符串 46</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.4　检测字符串是否相等 47</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.5　空串与Null串 48</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.6　码点与代码单元 49</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.7　String API 50</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.8　阅读联机API文档 52</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.9　构建字符串 54</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.7　输入输出 55</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.7.1　读取输入 55</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.7.2　格式化输出 58</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.7.3　文件输入与输出 61</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8　控制流程 63</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.1　块作用域 63</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.2　条件语句 63</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.3　循环 66</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.4　确定循环 69</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.5　多重选择：switch语句 72</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.6　中断控制流程语句 74</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.9　大数值 76</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10　数组 78</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.1　for each循环 79</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.2　数组初始化以及匿名数组 80</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.3　数组拷贝 81</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.4　命令行参数 81</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.5　数组排序 82</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.6　多维数组 85</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.7　不规则数组 88</span></p><p><span style=\"color: rgb(17, 17, 17);\">第4章　对象与类 91</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.1　面向对象程序设计概述 91</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.1.1　类 92</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.1.2　对象 93</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.1.3　识别类 93</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.1.4　类之间的关系 94</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.2　使用预定义类 95</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.2.1　对象与对象变量 95</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.2.2　Java类库中的LocalDate类 98</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.2.3　更改器方法与访问器方法 100</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3　用户自定义类 103</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.1　Employee类 103</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.2　多个源文件的使用 105</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.3　剖析Employee类 106</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.4　从构造器开始 106</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.5　隐式参数与显式参数 108</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.6　封装的优点 109</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.7　基于类的访问权限 111</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.8　私有方法 111</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.9　final实例域 112</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4　静态域与静态方法 112</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4.1　静态域 112</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4.2　静态常量 113</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4.3　静态方法 114</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4.4　工厂方法 115</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4.5　main方法 115</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.5　方法参数 118</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6　对象构造 123</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.1　重载 123</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.2　默认域初始化 123</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.3　无参数的构造器 124</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.4　显式域初始化 125</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.5　参数名 125</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.6　调用另一个构造器 126</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.7　初始化块 127</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.8　对象析构与finalize方法 130</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.7　包 131</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.7.1　类的导入 131</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.7.2　静态导入 133</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.7.3　将类放入包中 133</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.7.4　包作用域 136</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.8　类路径 137</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.8.1　设置类路径 139</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9　文档注释 140</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.1　注释的插入 140</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.2　类注释 140</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.3　方法注释 141</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.4　域注释 142</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.5　通用注释 142</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.6　包与概述注释 143</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.7　注释的抽取 143</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.10　类设计技巧 144</span></p><p><span style=\"color: rgb(17, 17, 17);\">第5章　继承 147</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1　类、超类和子类 147</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.1　定义子类 147</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.2　覆盖方法 149</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.3　子类构造器 150</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.4　继承层次 153</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.5　多态 154</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.6　理解方法调用 155</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.7　阻止继承：final类和方法 157</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.8　强制类型转换 158</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.9　抽象类 160</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.10　受保护访问 165</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.2　Object：所有类的超类 166</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.2.1　equals方法 166</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.2.2　相等测试与继承 167</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.2.3　hashCode方法 170</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.2.4　toString方法 172</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.3　泛型数组列表 178</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.3.1　访问数组列表元素 180</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.3.2　类型化与原始数组列表的兼容性 183</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.4　对象包装器与自动装箱 184</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.5　参数数量可变的方法 187</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.6　枚举类 188</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7　反射 190</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.1　Class类 190</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.2　捕获异常 192</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.3　利用反射分析类的能力 194</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.4　在运行时使用反射分析对象 198</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.5　使用反射编写泛型数组代码 202</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.6　调用任意方法 205</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.8　继承的设计技巧 208</span></p><p><span style=\"color: rgb(17, 17, 17);\">第6章　接口、lambda表达式与内部类 211</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1　接口 211</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.1　接口概念 211</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.2　接口的特性 217</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.3　接口与抽象类 218</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.4　静态方法 218</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.5　默认方法 219</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.6　解决默认方法冲突 220</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.2　接口示例 222</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.2.1　接口与回调 222</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.2.2　Comparator接口 224</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.2.3　对象克隆 225</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3　lambda表达式 231</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.1　为什么引入lambda表达式 231</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.2　lambda表达式的语法 232</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.3　函数式接口 234</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.4　方法引用 235</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.5　构造器引用 237</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.6　变量作用域 237</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.7　处理lambda表达式 239</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.8　再谈Comparator 242</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4　内部类 242</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.1　使用内部类访问对象状态 244</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.2　内部类的特殊语法规则 247</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.3　内部类是否有用、必要和安全 248</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.4　局部内部类 250</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.5　由外部方法访问变量 250</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.6　匿名内部类 252</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.7　静态内部类 255</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.5　代理 258</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.5.1　何时使用代理 259</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.5.2　创建代理对象 259</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.5.3　代理类的特性 262</span></p><p><span style=\"color: rgb(17, 17, 17);\">第7章　异常、断言和日志 264</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.1　处理错误 264</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.1.1　异常分类 265</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.1.2　声明受查异常 267</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.1.3　如何抛出异常 269</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.1.4　创建异常类 270</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2　捕获异常 271</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.1　捕获异常 271</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.2　捕获多个异常 273</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.3　再次抛出异常与异常链 274</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.4　finally子句 275</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.5　带资源的try语句 278</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.6　分析堆栈轨迹元素 280</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.3　使用异常机制的技巧 282</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.4　使用断言 285</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.4.1　断言的概念 285</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.4.2　启用和禁用断言 286</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.4.3　使用断言完成参数检查 287</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.4.4　为文档假设使用断言 288</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5　记录日志 289</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.1　基本日志 289</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.2　高级日志 289</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.3　修改日志管理器配置 291</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.4　本地化 292</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.5　处理器 293</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.6　过滤器 296</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.7　格式化器 296</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.8　日志记录说明 296</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.6　调试技巧 304</span></p><p><span style=\"color: rgb(17, 17, 17);\">第8章　泛型程序设计 309</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.1　为什么要使用泛型程序设计 309</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.1.1　类型参数的好处 309</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.1.2　谁想成为泛型程序员 310</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.2　定义简单泛型类 311</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.3　泛型方法 313</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.4　类型变量的限定 314</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.5　泛型代码和虚拟机 316</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.5.1　类型擦除 316</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.5.2　翻译泛型表达式 317</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.5.3　翻译泛型方法 318</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.5.4　调用遗留代码 319</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6　约束与局限性 320</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.1　不能用基本类型实例化类型参数 320</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.2　运行时类型查询只适用于原始类型 321</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.3　不能创建参数化类型的数组 321</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.4　Varargs警告 322</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.5　不能实例化类型变量 323</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.6　不能构造泛型数组 323</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.7　泛型类的静态上下文中类型变量无效 325</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.8　不能抛出或捕获泛型类的实例 325</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.9　可以消除对受查异常的检查 326</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.10　注意擦除后的冲突 327</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.7　泛型类型的继承规则 328</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.8　通配符类型 330</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.8.1　通配符概念 330</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.8.2　通配符的超类型限定 331</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.8.3　无限定通配符 334</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.8.4　通配符捕获 334</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.9　反射和泛型 337</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.9.1　泛型Class类 337</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.9.2　使用Class参数进行类型匹配 338</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.9.3　虚拟机中的泛型类型信息 338</span></p><p><span style=\"color: rgb(17, 17, 17);\">第9章　集合 344</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1　Java集合框架 344</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1.1　将集合的接口与实现分离 344</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1.2　Collection接口 346</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1.3　迭代器 347</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1.4　泛型实用方法 349</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1.5　集合框架中的接口 352</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2　具体的集合 353</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.1　链表 355</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.2　数组列表 362</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.3　散列集 363</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.4　树集 366</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.5　队列与双端队列 369</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.6　优先级队列 371</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3　映射 372</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.1　基本映射操作 372</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.2　更新映射项 375</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.3　映射视图 376</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.4　弱散列映射 377</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.5　链接散列集与映射 378</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.6　枚举集与映射 379</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.7　标识散列映射 380</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4　视图与包装器 381</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.1　轻量级集合包装器 382</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.2　子范围 382</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.3　不可修改的视图 383</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.4　同步视图 384</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.5　受查视图 384</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.6　关于可选操作的说明 385</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5　算法 388</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.1　排序与混排 389</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.2　二分查找 391</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.3　简单算法 392</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.4　批操作 394</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.5　集合与数组的转换 394</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.6　编写自己的算法 395</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6　遗留的集合 396</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6.1　Hashtable类 397</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6.2　枚举 397</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6.3　属性映射 398</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6.4　栈 399</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6.5　位集 399</span></p><p><span style=\"color: rgb(17, 17, 17);\">第10章　图形程序设计 403</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.1　Swing概述 403</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.2　创建框架 407</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.3　框架定位 409</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.3.1　框架属性 411</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.3.2　确定合适的框架大小 411</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.4　在组件中显示信息 415</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.5　处理2D图形 419</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.6　使用颜色 426</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.7　文本使用特殊字体 429</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.8　显示图像 435</span></p><p><span style=\"color: rgb(17, 17, 17);\">第11章　事件处理 439</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.1　事件处理基础 439</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.1.1　实例：处理按钮点击事件 441</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.1.2　简洁地指定监听器 445</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.1.3　实例：改变观感 447</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.1.4　适配器类 450</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.2　动作 453</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.3　鼠标事件 459</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.4　AWT事件继承层次 465</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.4.1　语义事件和底层事件 466</span></p><p><span style=\"color: rgb(17, 17, 17);\">第12章　Swing用户界面组件 469</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.1　Swing和模型–视图–控制器设计模式 469</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.1.1　设计模式 469</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.1.2　模型–视图–控制器模式 470</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.1.3　Swing按钮的模型–视图–控制器分析 473</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.2　布局管理概述 474</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.2.1　边框布局 477</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.2.2　网格布局 478</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3　文本输入 481</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3.1　文本域 482</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3.2　标签和标签组件 483</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3.3　密码域 484</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3.4　文本区 485</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3.5　滚动窗格 485</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4　选择组件 488</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4.1　复选框 488</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4.2　单选钮 490</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4.3　边框 493</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4.4　组合框 496</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4.5　滑动条 499</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5　菜单 504</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.1　菜单创建 504</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.2　菜单项中的图标 507</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.3　复选框和单选钮菜单项 508</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.4　弹出菜单 508</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.5　快捷键和加速器 510</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.6　启用和禁用菜单项 511</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.7　工具栏 515</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.8　工具提示 516</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6　复杂的布局管理 518</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6.1　网格组布局 520</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6.2　组布局 528</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6.3　不使用布局管理器 537</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6.4　定制布局管理器 537</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6.5　遍历顺序 541</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7　对话框 541</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7.1　选项对话框 542</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7.2　创建对话框 551</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7.3　数据交换 554</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7.4　文件对话框 559</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7.5　颜色选择器 569</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.8　GUI程序排错 573</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.8.1　调试技巧 573</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.8.2　让AWT机器人完成工作 576</span></p><p><span style=\"color: rgb(17, 17, 17);\">第13章　部署Java应用程序 580</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1　JAR文件 580</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1.1　创建JAR文件 580</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1.2　清单文件 581</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1.3　可执行JAR文件 582</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1.4　资源 583</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1.5　密封 585</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.2　应用首选项的存储 586</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.2.1　属性映射 586</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.2.2　首选项API 591</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.3　服务加载器 596</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4　applet 598</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.1　一个简单的applet 599</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.2　applet HTML标记和属性 602</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.3　使用参数向applet传递信息 603</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.4　访问图像和音频文件 608</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.5　applet上下文 609</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.6　applet间通信 609</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.7　在浏览器中显示信息项 610</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.8　沙箱 611</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.9　签名代码 612</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.5　Java Web Start 614</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.5.1　发布Java Web Start应用 614</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.5.2　JNLP API 617</span></p><p><span style=\"color: rgb(17, 17, 17);\">第14章　并发 624</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.1　什么是线程 624</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.1.1　使用线程给其他任务提供机会 629</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.2　中断线程 632</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.3　线程状态 635</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.3.1　新创建线程 635</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.3.2　可运行线程 635</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.3.3　被阻塞线程和等待线程 636</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.3.4　被终止的线程 636</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.4　线程属性 638</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.4.1　线程优先级 638</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.4.2　守护线程 639</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.4.3　未捕获异常处理器 639</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5　同步 640</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.1　竞争条件的一个例子 641</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.2　竞争条件详解 644</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.3　锁对象 646</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.4　条件对象 648</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.5　synchronized关键字 653</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.6　同步阻塞 656</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.7　监视器概念 657</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.8　Volatile域 658</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.9　final变量 659</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.10　原子性 659</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.11　死锁 661</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.12　线程局部变量 663</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.13　锁测试与超时 665</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.14　读/写锁 666</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.15　为什么弃用stop和suspend方法 667</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.6　阻塞队列 668</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7　线程安全的集合 673</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.1　高效的映射、集和队列 674</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.2　映射条目的原子更新 675</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.3　对并发散列映射的批操作 676</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.4　并发集视图 678</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.5　写数组的拷贝 679</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.6　并行数组算法 679</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.7　较早的线程安全集合 680</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.8　Callable与Future 681</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9　执行器 685</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9.1　线程池 685</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9.2　预定执行 689</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9.3　控制任务组 690</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9.4　Fork-Join框架 691</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9.5　可完成Future 694</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10　同步器 696</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10.1　信号量 696</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10.2　倒计时门栓 697</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10.3　障栅 697</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10.4　交换器 698</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10.5　同步队列 698</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.11　线程与Swing 698</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.11.1　运行耗时的任务 699</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.11.2　使用Swing工作线程 703</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.11.3　单一线程规则 708</span></p><p><span style=\"color: rgb(17, 17, 17);\">附录A　Java关键字 710</span></p>','2020-09-29 18:08:54','2020-09-30 08:55:30',5,0,0,1,0,NULL);
/*!40000 ALTER TABLE `book` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `book_note`
--

DROP TABLE IF EXISTS `book_note`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book_note` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(50) NOT NULL COMMENT '笔记标题',
  `description` varchar(255) DEFAULT NULL COMMENT '笔记描述',
  `author` varchar(50) DEFAULT NULL COMMENT '笔记作者',
  `content` longtext COMMENT '笔记内容',
  `content_format` longtext COMMENT 'html的context',
  `read_num` int(11) DEFAULT '0' COMMENT '阅读量',
  `comment_num` int(11) DEFAULT '0' COMMENT '评论量',
  `like_num` int(11) DEFAULT '0' COMMENT '点赞量',
  `cover` text COMMENT '封面',
  `book_id` int(11) DEFAULT NULL COMMENT '所属书本',
  `chapter` varchar(255) DEFAULT NULL COMMENT '所属章节',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  `recommend` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否推荐笔记',
  `category_id` varchar(50) DEFAULT NULL COMMENT '分类类别存在多级分类，用逗号隔开',
  `publish` tinyint(4) DEFAULT '0' COMMENT '发布状态',
  `cover_type` int(11) DEFAULT NULL COMMENT '封面类型',
  `top` tinyint(1) DEFAULT NULL COMMENT '是否置顶',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='笔记';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book_note`
--

LOCK TABLES `book_note` WRITE;
/*!40000 ALTER TABLE `book_note` DISABLE KEYS */;
INSERT INTO `book_note` VALUES (1,'删除排序数组中的重复项','给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。','Viote','给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n \n\n#### 示例 1\n\n```text\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n#### 示例 2\n\n```text\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n#### 说明\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n```text\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n  \n  \n\n#### 解答\n\n```text\n   /**\n     * 官方题解：双指针法\n     *\n     * 数组完成排序后，我们可以放置两个指针i 和j，其中i 是慢指针，而j 是快指针。\n     *只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。\n     * 当我们遇到 nums[j] != nums[i]，跳过重复项的运行已经结束\n     *因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程\n     *直到 j 到达数组的末尾为止。\n     *\n     * 复杂度分析\n     * 时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。\n     * 空间复杂度：O(1)\n    **/\n    public static int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        int i = 0;\n        for (int j = 1; j < nums.length; j++) {\n            if (nums[j] != nums[i]) {\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i + 1;\n    }\n```','<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n<h4 id=\"示例-1\">示例 1</h4>\n<pre><code class=\"language-text\">给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。</code></pre>\n<h4 id=\"示例-2\">示例 2</h4>\n<pre><code class=\"language-text\">给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。</code></pre>\n<h4 id=\"说明\">说明</h4>\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\n<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n<p>你可以想象内部操作如下:</p>\n<pre><code class=\"language-text\">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i &lt; len; i++) {\n    print(nums[i]);\n}</code></pre>\n<h4 id=\"解答\">解答</h4>\n<pre><code class=\"language-text\">   /**\n     * 官方题解：双指针法\n     *\n     * 数组完成排序后，我们可以放置两个指针i 和j，其中i 是慢指针，而j 是快指针。\n     *只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。\n     * 当我们遇到 nums[j] != nums[i]，跳过重复项的运行已经结束\n     *因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程\n     *直到 j 到达数组的末尾为止。\n     *\n     * 复杂度分析\n     * 时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。\n     * 空间复杂度：O(1)\n    **/\n    public static int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        int i = 0;\n        for (int j = 1; j &lt; nums.length; j++) {\n            if (nums[j] != nums[i]) {\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i + 1;\n    }</code></pre>\n',23,0,0,NULL,1,'数组','2019-06-29 00:32:35','2020-09-30 00:57:20',0,'55,31',1,NULL,0),(2,'买卖股票的最佳时机 II','给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。','Viote','给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n### 示例 1\n```text\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n```\n### 示例 2\n```text\n输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n```\n### 示例 3\n```text\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n ```\n\n**提示：**\n```text\n1 <= prices.length <= 3 * 10 ^ 4\n0 <= prices[i] <= 10 ^ 4\n```\n\n### 解题思路\n&nbsp;&nbsp;&nbsp;&nbsp;可以采用<font color=\'red\'>贪心策略</font>来解决：首先我们需要理解一点，第i天买入，第j天卖出得到的收益和第i天买入，第i+p天卖出，第i+p天再买入，第j天卖出得到的收益是相同的。比如[1,2,3,4,5]，很明显我们知道最大收益是4，可以看作是第一天买入，第五天卖出，但是也可以看作是第1天买入，第二天卖出，同时买入，第三天又卖出，同时买入······\n\n&nbsp;&nbsp;&nbsp;&nbsp;理解了这一点，我们就清楚这里为什么能用贪心的思想了，从第一天开始买入，只要有收益就可以直接卖出，接下来再买入，同样一旦有收益就可以卖出，这是一种典型的贪心思想，<font color=\'red\'>局部最优达到全局最优</font>。\n\n### 解题\n```text\nclass Solution {\n    public int maxProfit(int[] prices) {\n        //贪心法\n        if(prices==null || prices.length==0)\n            return 0;\n        int profit=0;\n        for(int i=1;i<prices.length;i++){\n            if(prices[i]>prices[i-1])\n                profit+=(prices[i]-prices[i-1]);\n        }\n        return profit;\n    }\n}\n```','<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<h3 id=\"示例-1\">示例 1</h3>\n<pre><code class=\"language-text\">输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</code></pre>\n<h3 id=\"示例-2\">示例 2</h3>\n<pre><code class=\"language-text\">输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre>\n<h3 id=\"示例-3\">示例 3</h3>\n<pre><code class=\"language-text\">输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre>\n<p><strong>提示：</strong></p>\n<pre><code class=\"language-text\">1 &lt;= prices.length &lt;= 3 * 10 ^ 4\n0 &lt;= prices[i] &lt;= 10 ^ 4</code></pre>\n<h3 id=\"解题思路\">解题思路</h3>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;可以采用<font color=\'red\'>贪心策略</font>来解决：首先我们需要理解一点，第i天买入，第j天卖出得到的收益和第i天买入，第i+p天卖出，第i+p天再买入，第j天卖出得到的收益是相同的。比如[1,2,3,4,5]，很明显我们知道最大收益是4，可以看作是第一天买入，第五天卖出，但是也可以看作是第1天买入，第二天卖出，同时买入，第三天又卖出，同时买入······</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;理解了这一点，我们就清楚这里为什么能用贪心的思想了，从第一天开始买入，只要有收益就可以直接卖出，接下来再买入，同样一旦有收益就可以卖出，这是一种典型的贪心思想，<font color=\'red\'>局部最优达到全局最优</font>。</p>\n<h3 id=\"解题\">解题</h3>\n<pre><code class=\"language-text\">class Solution {\n    public int maxProfit(int[] prices) {\n        //贪心法\n        if(prices==null || prices.length==0)\n            return 0;\n        int profit=0;\n        for(int i=1;i&lt;prices.length;i++){\n            if(prices[i]&gt;prices[i-1])\n                profit+=(prices[i]-prices[i-1]);\n        }\n        return profit;\n    }\n}</code></pre>\n',15,0,0,NULL,1,'数组','2019-06-30 18:25:12','2020-09-30 00:57:13',0,'55,31',1,NULL,0);
/*!40000 ALTER TABLE `book_note` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `book_sense`
--

DROP TABLE IF EXISTS `book_sense`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book_sense` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `author` varchar(20) DEFAULT NULL COMMENT '作者',
  `content` text COMMENT '内容',
  `book_id` int(11) DEFAULT NULL COMMENT '关联图书Id',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='读后感';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book_sense`
--

LOCK TABLES `book_sense` WRITE;
/*!40000 ALTER TABLE `book_sense` DISABLE KEYS */;
/*!40000 ALTER TABLE `book_sense` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `category`
--

DROP TABLE IF EXISTS `category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(255) DEFAULT NULL COMMENT '名称',
  `type` int(11) DEFAULT NULL COMMENT '类型：0文章，1阅读',
  `rank` int(11) DEFAULT NULL COMMENT '级别',
  `parent_id` int(11) DEFAULT '0' COMMENT '父主键',
  PRIMARY KEY (`id`),
  UNIQUE KEY `operation_category_id_uindex` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=55 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `category`
--

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;
INSERT INTO `category` VALUES (1,'本站相关',0,0,-1),(2,'前端技术',0,0,-1),(17,'关系型数据库',0,1,45),(19,'mysql',0,2,17),(21,'非关系型数据库',0,1,45),(31,'LeetCode',1,1,55),(32,'后端技术',0,0,-1),(34,'Java基础',0,1,32),(37,'高并发',0,1,46),(39,'Java基础',1,1,52),(42,'Java进阶',0,1,32),(43,'工具',0,1,32),(44,'框架',0,1,32),(45,'数据库',0,0,-1),(46,'架构设计',0,0,-1),(47,'数据结构与算法',0,0,-1),(48,'Spring',0,2,44),(49,'SpringBoot',0,2,44),(50,'验证码',0,2,43),(51,'前端技术',1,0,-1),(52,'后端技术',1,0,-1),(53,'数据库',1,0,-1),(54,'架构设计',1,0,-1),(55,'数据结构与算法',1,0,-1);
/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `link`
--

DROP TABLE IF EXISTS `link`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `link` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(50) DEFAULT NULL COMMENT '链接名称',
  `url` varchar(500) DEFAULT NULL COMMENT '链接地址',
  `avatar` varchar(255) DEFAULT NULL COMMENT '头像',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COMMENT='友链';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `link`
--

LOCK TABLES `link` WRITE;
/*!40000 ALTER TABLE `link` DISABLE KEYS */;
INSERT INTO `link` VALUES (1,'个人站点','https://site.osalien.com','http://oss.osalien.com/dbblog/20200515/ed94c174a32f47b6b01b3a85b150da63.png'),(2,'每日分享','https://news.osalien.com','http://oss.osalien.com/dbblog/20200515/db33dd399ee74175a8bd2ef2b5e620ee.png'),(3,'Java工程师成神之路','https://hollischuang.github.io/toBeTopJavaer','http://oss.osalien.com/dbblog/20200515/d55bd0c8a0d24ea098dcb6da308c40b6.png'),(4,'Spring源码阅读','https://github.com/seaswalker/spring-analysis','http://oss.osalien.com/dbblog/20200515/0b809a4d668b4761bd60df9aa78d049d.png'),(5,'On Java 8','https://lingcoder.github.io/OnJava8','http://oss.osalien.com/dbblog/20200701/01990d1d80864b9390f1da1675197f48.jpg'),(6,'云点网','https://www.yundr.net','http://oss.osalien.com/dbblog/20200810/75e68b3e566f45ed9c82af610641b6a4.png');
/*!40000 ALTER TABLE `link` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `log_like`
--

DROP TABLE IF EXISTS `log_like`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `log_like` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `type` varchar(50) DEFAULT NULL COMMENT '点赞类型',
  `params` varchar(5000) DEFAULT NULL COMMENT '请求参数',
  `time` bigint(20) NOT NULL COMMENT '执行时长(毫秒)',
  `ip` varchar(64) DEFAULT NULL COMMENT 'IP地址',
  `create_date` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 COMMENT='点赞日志';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `log_like`
--

LOCK TABLES `log_like` WRITE;
/*!40000 ALTER TABLE `log_like` DISABLE KEYS */;
INSERT INTO `log_like` VALUES (1,'article','6',0,'172.17.0.1','2020-05-15 07:42:04'),(2,'article','6',0,'172.17.0.1','2020-05-15 07:49:17'),(3,'article','1',0,'172.17.0.1','2020-05-15 08:07:21'),(4,'article','1',0,'172.17.0.1','2020-05-15 08:07:22'),(5,'article','1',0,'172.17.0.1','2020-05-15 08:07:27'),(6,'article','1',0,'172.17.0.1','2020-05-15 08:07:27'),(7,'article','1',0,'172.17.0.1','2020-05-15 08:07:28'),(8,'article','1',0,'172.17.0.1','2020-05-15 08:07:28'),(9,'article','1',0,'172.17.0.1','2020-05-15 08:07:28'),(10,'article','9',0,'172.17.0.1','2020-09-27 09:05:02'),(11,'article','10',0,'172.17.0.1','2020-09-28 06:45:55');
/*!40000 ALTER TABLE `log_like` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `log_view`
--

DROP TABLE IF EXISTS `log_view`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `log_view` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `type` varchar(50) DEFAULT NULL COMMENT '浏览类型',
  `method` varchar(200) DEFAULT NULL COMMENT '请求方法',
  `params` varchar(5000) DEFAULT NULL COMMENT '请求参数',
  `time` bigint(20) NOT NULL COMMENT '执行时长(毫秒)',
  `ip` varchar(64) DEFAULT NULL COMMENT 'IP地址',
  `create_date` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=356 DEFAULT CHARSET=utf8 COMMENT='阅读日志';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `log_view`
--

LOCK TABLES `log_view` WRITE;
/*!40000 ALTER TABLE `log_view` DISABLE KEYS */;
INSERT INTO `log_view` VALUES (1,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',38,'172.17.0.1','2020-05-12 12:51:29'),(2,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',15,'172.17.0.1','2020-05-12 12:56:59'),(3,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','3',16,'172.17.0.1','2020-05-12 12:57:04'),(4,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',13,'172.17.0.1','2020-05-12 13:00:41'),(5,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',17,'172.17.0.1','2020-05-12 13:06:35'),(6,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',11,'172.17.0.1','2020-05-12 13:07:41'),(7,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',165,'172.17.0.1','2020-05-14 06:24:29'),(8,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',229,'172.17.0.1','2020-05-14 06:25:23'),(9,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',45,'172.17.0.1','2020-05-14 06:26:53'),(10,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',25,'172.17.0.1','2020-05-14 06:26:57'),(11,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',17,'172.17.0.1','2020-05-14 06:27:05'),(12,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',17,'172.17.0.1','2020-05-14 06:28:23'),(13,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',16,'172.17.0.1','2020-05-14 06:37:19'),(14,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',21,'172.17.0.1','2020-05-14 06:37:35'),(15,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',11,'172.17.0.1','2020-05-14 06:38:22'),(16,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',10,'172.17.0.1','2020-05-14 06:38:27'),(17,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',44,'172.17.0.1','2020-05-14 07:54:14'),(18,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',29,'172.17.0.1','2020-05-15 07:41:50'),(19,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',31,'172.17.0.1','2020-05-15 07:43:22'),(20,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',32,'172.17.0.1','2020-05-15 07:43:40'),(21,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',19,'172.17.0.1','2020-05-15 07:44:21'),(22,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',15,'172.17.0.1','2020-05-15 07:45:23'),(23,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',18,'172.17.0.1','2020-05-15 07:45:28'),(24,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',29,'172.17.0.1','2020-05-15 07:45:38'),(25,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',18,'172.17.0.1','2020-05-15 07:46:12'),(26,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-05-15 07:46:31'),(27,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',13,'172.17.0.1','2020-05-15 07:47:07'),(28,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',26,'172.17.0.1','2020-05-15 07:47:41'),(29,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',27,'172.17.0.1','2020-05-15 07:48:25'),(30,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',251,'172.17.0.1','2020-05-15 07:48:51'),(31,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',508,'172.17.0.1','2020-05-15 07:51:47'),(32,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',21,'172.17.0.1','2020-05-15 07:57:40'),(33,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',9,'172.17.0.1','2020-05-15 07:59:54'),(34,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',23,'172.17.0.1','2020-05-15 08:07:20'),(35,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-15 10:17:27'),(36,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',715,'172.17.0.1','2020-05-15 10:18:17'),(37,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-15 10:18:52'),(38,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-15 10:19:26'),(39,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-15 10:19:39'),(40,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',255,'172.17.0.1','2020-05-15 10:42:20'),(41,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',27,'172.17.0.1','2020-05-15 10:44:38'),(42,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',11,'172.17.0.1','2020-05-15 11:07:01'),(43,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',5,'172.17.0.1','2020-05-15 11:58:47'),(44,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',10,'172.17.0.1','2020-05-15 11:59:39'),(45,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',10,'172.17.0.1','2020-05-15 11:59:55'),(46,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',25,'172.17.0.1','2020-05-15 12:00:19'),(47,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',247,'172.17.0.1','2020-05-15 13:03:49'),(48,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',446,'172.17.0.1','2020-05-15 13:03:49'),(49,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-15 13:50:28'),(50,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',9,'172.17.0.1','2020-05-15 14:16:49'),(51,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',18,'172.17.0.1','2020-05-15 14:18:22'),(52,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',24,'172.17.0.1','2020-05-15 14:23:06'),(53,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',112,'172.17.0.1','2020-05-16 15:22:10'),(54,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',10,'172.17.0.1','2020-05-16 15:24:35'),(55,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',95,'172.17.0.1','2020-05-16 23:01:56'),(56,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',58,'172.17.0.1','2020-05-17 01:27:59'),(57,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',9,'172.17.0.1','2020-05-17 01:28:00'),(58,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-05-17 01:29:50'),(59,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',14,'172.17.0.1','2020-05-17 01:29:51'),(60,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',270,'172.17.0.1','2020-05-17 07:52:21'),(61,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',12,'172.17.0.1','2020-05-17 08:01:37'),(62,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',9,'172.17.0.1','2020-05-17 08:02:42'),(63,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',13,'172.17.0.1','2020-05-17 08:09:01'),(64,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-05-17 08:12:12'),(65,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-05-17 08:15:46'),(66,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',10,'172.17.0.1','2020-05-17 08:19:51'),(67,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',10,'172.17.0.1','2020-05-17 08:20:39'),(68,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',37,'172.17.0.1','2020-05-17 10:25:50'),(69,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',10,'172.17.0.1','2020-05-17 10:25:51'),(70,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',7,'172.17.0.1','2020-05-17 10:25:53'),(71,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',7,'172.17.0.1','2020-05-17 10:27:06'),(72,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',13,'172.17.0.1','2020-05-17 10:27:15'),(73,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',86,'172.17.0.1','2020-05-18 08:51:22'),(74,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',34,'172.17.0.1','2020-05-18 08:52:42'),(75,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',13,'172.17.0.1','2020-05-18 08:53:33'),(76,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',8,'172.17.0.1','2020-05-18 08:54:15'),(77,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',246,'172.17.0.1','2020-05-18 08:54:52'),(78,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',11,'172.17.0.1','2020-05-18 08:54:59'),(79,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',449,'172.17.0.1','2020-05-18 08:59:39'),(80,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',6,'172.17.0.1','2020-05-18 09:00:05'),(81,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',7,'172.17.0.1','2020-05-18 09:01:06'),(82,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',12,'172.17.0.1','2020-05-18 09:06:07'),(83,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',66,'172.17.0.1','2020-05-19 07:42:10'),(84,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',254,'172.17.0.1','2020-05-19 07:42:39'),(85,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',94,'172.17.0.1','2020-05-19 09:01:31'),(86,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',13,'172.17.0.1','2020-05-19 09:01:53'),(87,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',33,'172.17.0.1','2020-05-19 09:02:21'),(88,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',9,'172.17.0.1','2020-05-19 09:02:29'),(89,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',118,'172.17.0.1','2020-05-19 10:58:53'),(90,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',82,'172.17.0.1','2020-05-20 06:05:37'),(91,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2241,'172.17.0.1','2020-05-20 07:51:07'),(92,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',5347,'172.17.0.1','2020-05-20 07:51:34'),(93,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2896,'172.17.0.1','2020-05-20 07:51:51'),(94,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1379,'172.17.0.1','2020-05-20 08:02:11'),(95,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',14,'172.17.0.1','2020-05-20 08:03:33'),(96,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',660,'172.17.0.1','2020-05-20 08:03:55'),(97,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',956,'172.17.0.1','2020-05-20 08:04:30'),(98,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',941,'172.17.0.1','2020-05-20 08:04:58'),(99,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1071,'172.17.0.1','2020-05-20 08:19:36'),(100,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',997,'172.17.0.1','2020-05-20 08:19:57'),(101,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',918,'172.17.0.1','2020-05-20 08:21:01'),(102,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',958,'172.17.0.1','2020-05-20 08:27:46'),(103,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',917,'172.17.0.1','2020-05-20 08:30:40'),(104,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2291,'172.17.0.1','2020-05-20 08:32:00'),(105,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',950,'172.17.0.1','2020-05-20 08:32:26'),(106,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',682,'172.17.0.1','2020-05-20 08:32:47'),(107,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',949,'172.17.0.1','2020-05-20 08:55:10'),(108,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',922,'172.17.0.1','2020-05-20 08:59:26'),(109,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',11,'172.17.0.1','2020-05-20 08:59:48'),(110,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',9,'172.17.0.1','2020-05-20 08:59:55'),(111,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',927,'172.17.0.1','2020-05-20 09:00:17'),(112,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',11,'172.17.0.1','2020-05-20 09:02:32'),(113,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 09:03:53'),(114,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',17,'172.17.0.1','2020-05-20 09:05:32'),(115,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2725,'172.17.0.1','2020-05-20 09:15:46'),(116,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',80,'172.17.0.1','2020-05-20 09:15:56'),(117,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',3540,'172.17.0.1','2020-05-20 09:16:12'),(118,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',9,'172.17.0.1','2020-05-20 09:16:23'),(119,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',5,'172.17.0.1','2020-05-20 09:17:07'),(120,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',4874,'172.17.0.1','2020-05-20 09:17:32'),(121,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',924,'172.17.0.1','2020-05-20 09:20:04'),(122,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',981,'172.17.0.1','2020-05-20 09:23:24'),(123,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',916,'172.17.0.1','2020-05-20 09:23:53'),(124,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',3067,'172.17.0.1','2020-05-20 09:24:11'),(125,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',11,'172.17.0.1','2020-05-20 09:24:21'),(126,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',919,'172.17.0.1','2020-05-20 09:26:52'),(127,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',978,'172.17.0.1','2020-05-20 09:27:00'),(128,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1594,'172.17.0.1','2020-05-20 09:27:03'),(129,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',234,'172.17.0.1','2020-05-20 09:27:03'),(130,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',937,'172.17.0.1','2020-05-20 09:27:06'),(131,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',703,'172.17.0.1','2020-05-20 09:27:53'),(132,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',966,'172.17.0.1','2020-05-20 09:29:24'),(133,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1031,'172.17.0.1','2020-05-20 09:41:16'),(134,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',904,'172.17.0.1','2020-05-20 09:41:28'),(135,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',742,'172.17.0.1','2020-05-20 09:43:24'),(136,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',75,'172.17.0.1','2020-05-20 13:12:08'),(137,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',20,'172.17.0.1','2020-05-20 13:12:23'),(138,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 13:13:12'),(139,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',20,'172.17.0.1','2020-05-20 13:13:17'),(140,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',11,'172.17.0.1','2020-05-20 13:16:48'),(141,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',5,'172.17.0.1','2020-05-20 13:17:37'),(142,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 13:18:07'),(143,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-05-20 13:18:14'),(144,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 13:23:35'),(145,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 13:45:29'),(146,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',11,'172.17.0.1','2020-05-20 13:45:41'),(147,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',16,'172.17.0.1','2020-05-20 13:47:45'),(148,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',7,'172.17.0.1','2020-05-20 13:53:19'),(149,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',7,'172.17.0.1','2020-05-20 13:53:27'),(150,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 14:14:17'),(151,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',5,'172.17.0.1','2020-05-20 14:16:29'),(152,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',5,'172.17.0.1','2020-05-20 14:16:50'),(153,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 14:42:01'),(154,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-20 14:50:45'),(155,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',41,'172.17.0.1','2020-05-27 13:39:40'),(156,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',1450,'172.17.0.1','2020-06-08 09:25:47'),(157,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',271,'172.17.0.1','2020-06-08 23:12:35'),(158,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',1688,'172.17.0.1','2020-06-21 12:17:48'),(159,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',483,'172.17.0.1','2020-06-21 15:19:24'),(160,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',2106,'172.17.0.1','2020-06-21 21:40:34'),(161,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',403,'172.17.0.1','2020-06-22 00:51:20'),(162,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2214,'172.17.0.1','2020-06-27 03:19:11'),(163,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',362,'172.17.0.1','2020-06-27 03:20:02'),(164,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',34,'172.17.0.1','2020-06-27 03:20:10'),(165,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',1511,'172.17.0.1','2020-06-28 01:40:43'),(166,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',393,'172.17.0.1','2020-06-28 01:42:31'),(167,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',3215,'172.17.0.1','2020-06-28 01:42:51'),(168,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1174,'172.17.0.1','2020-06-28 01:42:59'),(169,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1227,'172.17.0.1','2020-06-28 02:05:08'),(170,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2388,'172.17.0.1','2020-06-28 10:11:51'),(171,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1251,'172.17.0.1','2020-06-28 10:13:02'),(172,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',17,'172.17.0.1','2020-06-28 10:17:30'),(173,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1032,'172.17.0.1','2020-06-28 10:37:43'),(174,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',17,'172.17.0.1','2020-06-29 08:33:36'),(175,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-06-29 08:33:49'),(176,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-06-29 08:35:11'),(177,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-06-29 08:36:39'),(178,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-06-29 08:37:13'),(179,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',11,'172.17.0.1','2020-06-29 08:38:32'),(180,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',5,'172.17.0.1','2020-06-29 08:39:14'),(181,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',16,'172.17.0.1','2020-06-29 08:52:09'),(182,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',3,'172.17.0.1','2020-06-29 08:52:15'),(183,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',61,'172.17.0.1','2020-06-29 08:52:17'),(184,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',25,'172.17.0.1','2020-06-29 08:57:17'),(185,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',19,'172.17.0.1','2020-06-29 08:57:30'),(186,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',14,'172.17.0.1','2020-06-29 08:58:14'),(187,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',26,'172.17.0.1','2020-06-29 08:59:35'),(188,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',3,'172.17.0.1','2020-06-29 09:00:54'),(189,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',3,'172.17.0.1','2020-06-29 09:01:14'),(190,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',43,'172.17.0.1','2020-06-29 09:01:31'),(191,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',928,'172.17.0.1','2020-06-29 09:01:36'),(192,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',12,'172.17.0.1','2020-06-29 09:01:43'),(193,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',10,'172.17.0.1','2020-06-29 09:24:03'),(194,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-06-29 09:53:11'),(195,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',3,'172.17.0.1','2020-07-01 02:27:05'),(196,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',8,'172.17.0.1','2020-07-01 02:27:46'),(197,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',8,'172.17.0.1','2020-07-01 02:29:05'),(198,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',2,'172.17.0.1','2020-07-01 02:29:08'),(199,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',2,'172.17.0.1','2020-07-01 02:29:48'),(200,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',2,'172.17.0.1','2020-07-01 02:30:44'),(201,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',5,'172.17.0.1','2020-07-01 02:34:57'),(202,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',206,'172.17.0.1','2020-07-01 05:59:49'),(203,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',5,'172.17.0.1','2020-07-01 05:59:51'),(204,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',86,'172.17.0.1','2020-07-01 09:56:24'),(205,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',95,'172.17.0.1','2020-07-01 10:16:20'),(206,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',718,'172.17.0.1','2020-07-01 22:11:09'),(207,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',1630,'172.17.0.1','2020-07-05 23:14:00'),(208,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',65,'172.17.0.1','2020-07-08 09:48:21'),(209,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',481,'172.17.0.1','2020-07-08 19:52:44'),(210,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',928,'172.17.0.1','2020-07-09 15:37:01'),(211,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',155,'172.17.0.1','2020-07-10 20:44:09'),(212,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',287,'172.17.0.1','2020-07-11 14:14:19'),(213,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',326,'172.17.0.1','2020-07-12 00:28:22'),(214,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1987,'172.17.0.1','2020-07-12 14:57:48'),(215,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',778,'172.17.0.1','2020-07-14 05:37:26'),(216,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',1636,'172.17.0.1','2020-07-14 12:59:49'),(217,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',184,'172.17.0.1','2020-07-14 14:29:04'),(218,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',1875,'172.17.0.1','2020-07-16 00:59:37'),(219,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',1708,'172.17.0.1','2020-07-17 09:14:53'),(220,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',240,'172.17.0.1','2020-07-28 12:17:49'),(221,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',306,'172.17.0.1','2020-07-28 15:09:11'),(222,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',202,'172.17.0.1','2020-07-28 16:28:38'),(223,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2665,'172.17.0.1','2020-07-28 20:33:42'),(224,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',966,'172.17.0.1','2020-07-28 20:33:48'),(225,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',353,'172.17.0.1','2020-07-29 04:44:24'),(226,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',169,'172.17.0.1','2020-07-29 05:58:05'),(227,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',1061,'172.17.0.1','2020-07-29 10:52:49'),(228,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',308,'172.17.0.1','2020-07-29 13:10:03'),(229,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',14,'172.17.0.1','2020-07-29 13:30:22'),(230,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',223,'172.17.0.1','2020-07-29 23:22:58'),(231,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1821,'172.17.0.1','2020-07-31 15:51:22'),(232,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2074,'172.17.0.1','2020-08-01 18:26:09'),(233,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',11,'172.17.0.1','2020-08-06 06:30:57'),(234,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',3,'172.17.0.1','2020-08-06 06:31:15'),(235,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',100,'172.17.0.1','2020-08-06 06:31:24'),(236,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',36,'172.17.0.1','2020-08-06 06:35:50'),(237,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1210,'172.17.0.1','2020-08-07 06:38:35'),(238,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',16,'172.17.0.1','2020-08-07 06:39:12'),(239,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',13,'172.17.0.1','2020-08-07 06:43:34'),(240,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',27,'172.17.0.1','2020-08-07 06:43:59'),(241,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',17,'172.17.0.1','2020-08-07 06:44:32'),(242,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',20,'172.17.0.1','2020-08-07 06:49:20'),(243,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',20,'172.17.0.1','2020-08-07 06:57:01'),(244,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',259,'172.17.0.1','2020-08-10 09:13:28'),(245,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',19,'172.17.0.1','2020-08-10 09:39:15'),(246,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',12,'172.17.0.1','2020-08-10 09:39:47'),(247,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',22,'172.17.0.1','2020-08-10 09:45:06'),(248,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',1328,'172.17.0.1','2020-08-10 10:34:49'),(249,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',88,'172.17.0.1','2020-08-13 03:09:50'),(250,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',21,'172.17.0.1','2020-08-13 03:10:05'),(251,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',52,'172.17.0.1','2020-08-13 03:10:23'),(252,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',199,'172.17.0.1','2020-08-13 14:54:09'),(253,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',21,'172.17.0.1','2020-08-14 09:33:44'),(254,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',23,'172.17.0.1','2020-08-14 09:34:39'),(255,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',735,'172.17.0.1','2020-08-14 09:36:38'),(256,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',18,'172.17.0.1','2020-08-14 09:36:48'),(257,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',14,'172.17.0.1','2020-08-14 09:38:34'),(258,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',36,'172.17.0.1','2020-08-14 09:42:56'),(259,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',30,'172.17.0.1','2020-08-14 09:47:16'),(260,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',991,'172.17.0.1','2020-08-14 09:47:34'),(261,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',521,'172.17.0.1','2020-08-20 15:23:37'),(262,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',200,'172.17.0.1','2020-08-29 15:13:27'),(263,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',181,'172.17.0.1','2020-08-30 12:47:50'),(264,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',380,'172.17.0.1','2020-09-04 14:45:57'),(265,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',45,'172.17.0.1','2020-09-05 02:49:35'),(266,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',99,'172.17.0.1','2020-09-05 10:09:18'),(267,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',140,'172.17.0.1','2020-09-05 11:01:21'),(268,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',91,'172.17.0.1','2020-09-05 21:45:44'),(269,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',63,'172.17.0.1','2020-09-08 06:11:11'),(270,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',24,'172.17.0.1','2020-09-08 15:43:57'),(271,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',185,'172.17.0.1','2020-09-09 01:27:58'),(272,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',264,'172.17.0.1','2020-09-09 03:26:26'),(273,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',38,'172.17.0.1','2020-09-09 03:26:27'),(274,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',809,'172.17.0.1','2020-09-09 03:33:17'),(275,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1113,'172.17.0.1','2020-09-09 03:33:21'),(276,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',8,'172.17.0.1','2020-09-09 03:36:22'),(277,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',34,'172.17.0.1','2020-09-09 03:36:27'),(278,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',31,'172.17.0.1','2020-09-09 03:39:41'),(279,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',107,'172.17.0.1','2020-09-27 07:16:05'),(280,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',743,'172.17.0.1','2020-09-27 07:16:34'),(281,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',665,'172.17.0.1','2020-09-27 07:16:40'),(282,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',713,'172.17.0.1','2020-09-27 07:16:58'),(283,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',46,'172.17.0.1','2020-09-27 07:38:22'),(284,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',35,'172.17.0.1','2020-09-27 07:41:42'),(285,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',21,'172.17.0.1','2020-09-27 07:48:54'),(286,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',31,'172.17.0.1','2020-09-27 07:51:42'),(287,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',14,'172.17.0.1','2020-09-27 09:05:00'),(288,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',18,'172.17.0.1','2020-09-27 09:05:13'),(289,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',12,'172.17.0.1','2020-09-27 09:05:17'),(290,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',148,'172.17.0.1','2020-09-27 09:05:20'),(291,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',23,'172.17.0.1','2020-09-27 09:06:01'),(292,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',30,'172.17.0.1','2020-09-27 10:34:48'),(293,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',32,'172.17.0.1','2020-09-28 06:45:52'),(294,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',11,'172.17.0.1','2020-09-28 06:47:09'),(295,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',13,'172.17.0.1','2020-09-28 07:29:33'),(296,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',25,'172.17.0.1','2020-09-28 07:29:41'),(297,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',12,'172.17.0.1','2020-09-28 07:49:05'),(298,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',58,'172.17.0.1','2020-09-28 09:06:34'),(299,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',693,'172.17.0.1','2020-09-28 09:06:45'),(300,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',88,'172.17.0.1','2020-09-28 09:06:57'),(301,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',45,'172.17.0.1','2020-09-29 03:18:00'),(302,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',169,'172.17.0.1','2020-09-29 03:18:28'),(303,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',7,'172.17.0.1','2020-09-29 03:20:47'),(304,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',8,'172.17.0.1','2020-09-29 03:31:21'),(305,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',7,'172.17.0.1','2020-09-29 03:34:13'),(306,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',10,'172.17.0.1','2020-09-29 03:34:18'),(307,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',6,'172.17.0.1','2020-09-29 03:34:45'),(308,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',18,'172.17.0.1','2020-09-29 03:35:01'),(309,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',11,'172.17.0.1','2020-09-29 03:36:56'),(310,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',11,'172.17.0.1','2020-09-29 03:37:43'),(311,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',12,'172.17.0.1','2020-09-29 03:39:22'),(312,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',19,'172.17.0.1','2020-09-29 03:43:21'),(313,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',8,'172.17.0.1','2020-09-29 03:50:15'),(314,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',5,'172.17.0.1','2020-09-29 04:02:46'),(315,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',6,'172.17.0.1','2020-09-29 04:15:11'),(316,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',119,'172.17.0.1','2020-09-29 04:15:39'),(317,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',7,'172.17.0.1','2020-09-29 04:17:17'),(318,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',8,'172.17.0.1','2020-09-29 04:18:37'),(319,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',9,'172.17.0.1','2020-09-29 07:14:02'),(320,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',15,'172.17.0.1','2020-09-29 07:36:42'),(321,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',17,'172.17.0.1','2020-09-29 07:37:00'),(322,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',55,'172.17.0.1','2020-09-29 09:16:20'),(323,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',10,'172.17.0.1','2020-09-29 09:50:01'),(324,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',12,'172.17.0.1','2020-09-29 09:50:07'),(325,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',96,'172.17.0.1','2020-09-30 02:16:10'),(326,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',29,'172.17.0.1','2020-09-30 02:16:13'),(327,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',73,'172.17.0.1','2020-09-30 02:16:51'),(328,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',20,'172.17.0.1','2020-09-30 06:29:26'),(329,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',6,'172.17.0.1','2020-09-30 06:32:03'),(330,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',11,'172.17.0.1','2020-09-30 06:45:53'),(331,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',17,'172.17.0.1','2020-09-30 06:48:12'),(332,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',7,'172.17.0.1','2020-09-30 08:18:15'),(333,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',21,'172.17.0.1','2020-09-30 08:45:49'),(334,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',7,'172.17.0.1','2020-09-30 08:49:52'),(335,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',11,'172.17.0.1','2020-09-30 09:00:36'),(336,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',46,'172.17.0.1','2020-09-30 09:05:55'),(337,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-09-30 15:05:43'),(338,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',39,'172.17.0.1','2020-10-01 01:30:23'),(339,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',52,'172.17.0.1','2020-10-01 21:44:39'),(340,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',305,'172.17.0.1','2020-10-01 21:44:40'),(341,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',2917,'172.17.0.1','2020-10-01 21:44:44'),(342,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',1345,'172.17.0.1','2020-10-01 21:44:46'),(343,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',120,'172.17.0.1','2020-10-01 23:35:54'),(344,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',221,'172.17.0.1','2020-10-02 10:38:25'),(345,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',164,'172.17.0.1','2020-10-02 16:14:14'),(346,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',96,'172.17.0.1','2020-10-09 05:35:46'),(347,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',2429,'172.17.0.1','2020-10-09 05:36:11'),(348,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',1751,'172.17.0.1','2020-10-09 05:37:05'),(349,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',17,'172.17.0.1','2020-10-09 05:52:58'),(350,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',192,'172.17.0.1','2020-10-09 05:53:28'),(351,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',35,'172.17.0.1','2020-10-09 05:55:28'),(352,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',69,'172.17.0.1','2020-10-09 05:56:11'),(353,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',495,'172.17.0.1','2020-10-09 05:57:32'),(354,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',34,'172.17.0.1','2020-10-09 05:58:25'),(355,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',40,'172.17.0.1','2020-10-09 05:59:20');
/*!40000 ALTER TABLE `log_view` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `oss_resource`
--

DROP TABLE IF EXISTS `oss_resource`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `oss_resource` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(255) DEFAULT NULL COMMENT '名称',
  `url` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=132 DEFAULT CHARSET=utf8 COMMENT='云存储资源表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `oss_resource`
--

LOCK TABLES `oss_resource` WRITE;
/*!40000 ALTER TABLE `oss_resource` DISABLE KEYS */;
INSERT INTO `oss_resource` VALUES (1,'bike_03.jpg','http://oss.osalien.com/dbblog/20200512/0587dad599224030a9779ac5b90f509d.jpg'),(2,'Mine.jpg','http://oss.osalien.com/dbblog/20200515/3b4a103561854dccb40eccf97b37673d.jpg'),(3,'微信图片_20200429220243.jpg','http://oss.osalien.com/dbblog/20200515/ae3b2b4518c747e198066e481fde27f2.jpg'),(4,'java.png','http://oss.osalien.com/dbblog/20200515/4e940ad498e24a87b11ee341620b5351.png'),(5,'Java (1).png','http://oss.osalien.com/dbblog/20200515/d55bd0c8a0d24ea098dcb6da308c40b6.png'),(6,'Site layout.png','http://oss.osalien.com/dbblog/20200515/ed94c174a32f47b6b01b3a85b150da63.png'),(7,'新闻.png','http://oss.osalien.com/dbblog/20200515/db33dd399ee74175a8bd2ef2b5e620ee.png'),(8,'SPRINGCLOUD.png','http://oss.osalien.com/dbblog/20200515/d511cbd6385e407d9d1047c36a38d590.png'),(9,'SpringBean连接.png','http://oss.osalien.com/dbblog/20200515/d24900bc28b84269bbc3f841d1d67e16.png'),(10,'SPRINGCLOUD.png','http://oss.osalien.com/dbblog/20200515/046761e7492646cd8c6bd8529fdc2ac5.png'),(11,'SpringBean连接.png','http://oss.osalien.com/dbblog/20200515/0b809a4d668b4761bd60df9aa78d049d.png'),(12,'image.png','http://oss.osalien.com/dbblog/20200515/f7c810ad1b274bb996c32f91184a86d5.png'),(13,'image.png','http://oss.osalien.com/dbblog/20200515/e0c082e148cd42e092deef117ac25719.png'),(14,'image.png','http://oss.osalien.com/dbblog/20200518/a55c974deb1b463c945c6a43205d055a.png'),(15,'image.png','http://oss.osalien.com/dbblog/20200518/7da093a7d1b541e8aec90f5da63f6b8f.png'),(16,'image.png','http://oss.osalien.com/dbblog/20200518/ef398346fe4349fa8b60cd8ca28c26c0.png'),(17,'image.png','http://oss.osalien.com/dbblog/20200518/76da426c28094d8aaa0b7401c4b5ac0e.png'),(18,'image.png','http://oss.osalien.com/dbblog/20200520/967eae0f814441f6ae52d3b8d1e6116d.png'),(19,'image.png','http://oss.osalien.com/dbblog/20200520/2de3ac3554d84c9eabff1d50eed3e5c8.png'),(20,'image.png','http://oss.osalien.com/dbblog/20200520/cbfc0b05edac444098b395de90f5e463.png'),(21,'leetcode1.jpg','http://oss.osalien.com/dbblog/20200629/4ad72089f23740d89b6a992c796d2ec1.jpg'),(22,'leetcode2.jpg','http://oss.osalien.com/dbblog/20200629/ec00fe6c4fe946c8bb3fb80d6452add1.jpg'),(23,'Leetcode.png','http://oss.osalien.com/dbblog/20200629/4060019fe40541a18405e18a09b06e43.png'),(24,'leetcode3.jpg','http://oss.osalien.com/dbblog/20200629/ca6dd0aa94394c3bb303fa25d791fe32.jpg'),(25,'leetcode3.jpg','http://oss.osalien.com/dbblog/20200629/4e1dd67b2f5c45ddb50fe26aab551ca6.jpg'),(26,'cover_small.jpg','http://oss.osalien.com/dbblog/20200701/4dc8fde7b8d9493985824f3911861e15.jpg'),(27,'cover_small.jpg','http://oss.osalien.com/dbblog/20200701/01990d1d80864b9390f1da1675197f48.jpg'),(28,'云点网.png','http://oss.osalien.com/dbblog/20200810/75e68b3e566f45ed9c82af610641b6a4.png'),(29,'image.png','http://oss.osalien.com/dbblog/20200927/51088a60dacc4833957527fac2844112.png'),(30,'image.png','http://oss.osalien.com/dbblog/20200927/4d3063f95d3146e69fb055529eb7fc51.png'),(31,'image.png','http://oss.osalien.com/dbblog/20200927/64260df48d8e479aa622e6abec438226.png'),(32,'image.png','http://oss.osalien.com/dbblog/20200927/40053d2583464b7dacc3c01d9efea4cc.png'),(33,'image.png','http://oss.osalien.com/dbblog/20200927/50a17df0f7fc46b7b09ff51d5e450c35.png'),(34,'image.png','http://oss.osalien.com/dbblog/20200927/00191170740a4c9ab97d74fefa5752f0.png'),(35,'image.png','http://oss.osalien.com/dbblog/20200927/502ca37449a34d7cb8b9c56bde8f44f0.png'),(36,'image.png','http://oss.osalien.com/dbblog/20200927/4b4fdc089d314bfdb22d765987cc7d1d.png'),(37,'image.png','http://oss.osalien.com/dbblog/20200927/aa7143128acd4f0d89ce8243e3c5244f.png'),(38,'image.png','http://oss.osalien.com/dbblog/20200927/d65364523ffe4627bc21060288426fe3.png'),(39,'image.png','http://oss.osalien.com/dbblog/20200927/afb65634d6e14d58806b064849276d5f.png'),(40,'image.png','http://oss.osalien.com/dbblog/20200927/b64d2d4bf4bc41589777bb2f87512701.png'),(41,'image.png','http://oss.osalien.com/dbblog/20200927/2a1a637457e442c38276a70ec299bb3d.png'),(42,'image.png','http://oss.osalien.com/dbblog/20200927/5e7516d8d1f242fab10893c3366cf7ae.png'),(43,'image.png','http://oss.osalien.com/dbblog/20200927/7eb344242dac44149e49d3940413a8c7.png'),(44,'image.png','http://oss.osalien.com/dbblog/20200927/493832f84a6c42d697dc99ad950ce40f.png'),(45,'image.png','http://oss.osalien.com/dbblog/20200927/c77ba53413d14c53bf743c9dc778ab25.png'),(46,'image.png','http://oss.osalien.com/dbblog/20200927/cd2ff0ab0f4040abbbeecda1346ce5b3.png'),(47,'image.png','http://oss.osalien.com/dbblog/20200927/0850ccbbaed74e378cb26dbd55c4f6cf.png'),(48,'image.png','http://oss.osalien.com/dbblog/20200927/23c7e2cca8e5434bba9018de4b52d862.png'),(49,'image.png','http://oss.osalien.com/dbblog/20200927/a8c14c3d89e34704be5f3b297b3349ec.png'),(50,'image.png','http://oss.osalien.com/dbblog/20200927/d03469988e6d415cb4cc0bb6e03c6e6f.png'),(51,'image.png','http://oss.osalien.com/dbblog/20200927/33a6a32a894048339e08dd3d58aaca16.png'),(52,'image.png','http://oss.osalien.com/dbblog/20200927/b0d2663195684681808be4f9ce6f63c2.png'),(53,'image.png','http://oss.osalien.com/dbblog/20200927/adb9024fdec142288d6fea276f3d0cc5.png'),(54,'image.png','http://oss.osalien.com/dbblog/20200927/f103f46c9fc841bab92f8887a7d9acb2.png'),(55,'image.png','http://oss.osalien.com/dbblog/20200927/e558705edeb44f37bb1d05955becfb4f.png'),(56,'image.png','http://oss.osalien.com/dbblog/20200927/2fa5e653c1ac426bb59ea404c61fde65.png'),(57,'image.png','http://oss.osalien.com/dbblog/20200927/efdae087278e44eb9a48b0c228aea9ec.png'),(58,'image.png','http://oss.osalien.com/dbblog/20200927/acf65856afa64289abcfd72b316d929b.png'),(59,'image.png','http://oss.osalien.com/dbblog/20200927/af1f8ebd7a064e0da4d46c9e0a685b1c.png'),(60,'image.png','http://oss.osalien.com/dbblog/20200927/d33c397f46b145fc86679540e5be2904.png'),(61,'image.png','http://oss.osalien.com/dbblog/20200927/968ab1df98c2498d96274d66ab509f06.png'),(62,'image.png','http://oss.osalien.com/dbblog/20200927/6760c82f80f44c27828a3ba9f60c614d.png'),(63,'image.png','http://oss.osalien.com/dbblog/20200927/22650688578a4f6a93ab5ea615627c2b.png'),(64,'image.png','http://oss.osalien.com/dbblog/20200927/2963c48aa1544016b0e11e29a0aaff48.png'),(65,'image.png','http://oss.osalien.com/dbblog/20200927/3fadb753db7b4568993bb3e6344b1af4.png'),(66,'image.png','http://oss.osalien.com/dbblog/20200927/c449faf67d734bdc8ab4563e9de8d384.png'),(67,'image.png','http://oss.osalien.com/dbblog/20200927/fd00a2f8bd544565ba51d68b6d14c863.png'),(68,'image.png','http://oss.osalien.com/dbblog/20200927/23e2dc95130f44e591df06636e8e4ebb.png'),(69,'image.png','http://oss.osalien.com/dbblog/20200927/1f27ecf8dd69422596392f12fccf3105.png'),(70,'image.png','http://oss.osalien.com/dbblog/20200927/f9705cad7ea746f1a2cd9bbea9dd351f.png'),(71,'image.png','http://oss.osalien.com/dbblog/20200927/235332789b2e473ebfb1aa19880a4242.png'),(72,'image.png','http://oss.osalien.com/dbblog/20200927/4e9e0e65e2f2498baf3d4ffb58cede5e.png'),(73,'image.png','http://oss.osalien.com/dbblog/20200927/468998e2e5c9465ca6e8897309182788.png'),(74,'image.png','http://oss.osalien.com/dbblog/20200927/eb46b64979434f62b96245f4682a51c1.png'),(75,'image.png','http://oss.osalien.com/dbblog/20200927/8e4e7c787d8840949eb04d4021fd464d.png'),(76,'image.png','http://oss.osalien.com/dbblog/20200927/2c72af00da7b4aaba4099b915bfdde3b.png'),(77,'image.png','http://oss.osalien.com/dbblog/20200927/db465142011f4e1685e175d0a04db8d6.png'),(78,'image.png','http://oss.osalien.com/dbblog/20200927/47c7b39e77a0471e80262e6ade5133ed.png'),(79,'image.png','http://oss.osalien.com/dbblog/20200927/c71f1d2b672d4a64a46db2053357b973.png'),(80,'image.png','http://oss.osalien.com/dbblog/20200927/3607e378a2774679a7ff8964164d31ba.png'),(81,'image.png','http://oss.osalien.com/dbblog/20200927/e1a9f722b6234ecab47cec2cca393680.png'),(82,'image.png','http://oss.osalien.com/dbblog/20200927/c632856b2f4945f195a0bc9f958e314d.png'),(83,'image.png','http://oss.osalien.com/dbblog/20200927/4a6cf290ef724e2aa9b0f7d49efa4df6.png'),(84,'image.png','http://oss.osalien.com/dbblog/20200927/41290e8a8eba44eda50321ccbf0200ee.png'),(85,'image.png','http://oss.osalien.com/dbblog/20200927/5a5a1aacb7724a88a02a969fe47c6ddf.png'),(86,'image.png','http://oss.osalien.com/dbblog/20200927/7d33fe50bc084327a175d3349a073410.png'),(87,'image.png','http://oss.osalien.com/dbblog/20200927/199815eca3ec4628bf708b8efe94c442.png'),(88,'image.png','http://oss.osalien.com/dbblog/20200927/947a26cadcc04bc8a870144179c62c39.png'),(89,'image.png','http://oss.osalien.com/dbblog/20200927/5a70a907d7e947709d3cc8f98c3a2af5.png'),(90,'image.png','http://oss.osalien.com/dbblog/20200927/7429f7ac0a034cce958bb62d5404599d.png'),(91,'image.png','http://oss.osalien.com/dbblog/20200927/528542ca39d84222b64ee4479f373e07.png'),(92,'image.png','http://oss.osalien.com/dbblog/20200927/940bcfd015b04240bf8bc050ece98c8d.png'),(93,'image.png','http://oss.osalien.com/dbblog/20200927/7a07046d13824178980f1dcc28ff227f.png'),(94,'image.png','http://oss.osalien.com/dbblog/20200927/2e9d2d2362704767bcf15172774c2ac3.png'),(95,'image.png','http://oss.osalien.com/dbblog/20200928/9a49b16e156e459fb028c7540450093d.png'),(96,'image.png','http://oss.osalien.com/dbblog/20200928/c7f32ec7730c4e89870f84683f488a49.png'),(97,'image.png','http://oss.osalien.com/dbblog/20200928/0ff0f991a9d14bd2a1b41ba1e8395487.png'),(98,'image.png','http://oss.osalien.com/dbblog/20200928/02c9cf3fe63a4cb088c24082441e2cdc.png'),(99,'image.png','http://oss.osalien.com/dbblog/20200928/f8acc3a9e69d45fdace7b7da76388fcd.png'),(100,'image.png','http://oss.osalien.com/dbblog/20200928/d6b0a966913c41e9bd315254527c3d1f.png'),(101,'image.png','http://oss.osalien.com/dbblog/20200929/e59ad1a7eea843a19f126ed2ef87d44b.png'),(102,'image.png','http://oss.osalien.com/dbblog/20200929/7973534bff654f7fac6f503d3b4712d2.png'),(103,'image.png','http://oss.osalien.com/dbblog/20200929/9ea148ae06414383a7eec802b3528226.png'),(104,'image.png','http://oss.osalien.com/dbblog/20200929/c0711afbb09246f486804e876ee450c8.png'),(105,'image.png','http://oss.osalien.com/dbblog/20200929/5db8f7a3297645c393145c983f2e8272.png'),(106,'image.png','http://oss.osalien.com/dbblog/20200929/9b9d2e1e7a9e46c58c5a5d4f10b135b8.png'),(107,'image.png','http://oss.osalien.com/dbblog/20200929/26bb7b26e582465e9b09b7f9735348bb.png'),(108,'image.png','http://oss.osalien.com/dbblog/20200929/02ab3d266f0b43f0b9d19ed62ae53ab6.png'),(109,'image.png','http://oss.osalien.com/dbblog/20200929/00b78ce60ada41538768a09946ca15cc.png'),(110,'image.png','http://oss.osalien.com/dbblog/20200929/fd22770866c84018b4d0e33708389ea0.png'),(111,'msFvb6.gif','http://oss.osalien.com/dbblog/20200929/52be7ba2332041f1abfd7227c4324066.gif'),(112,'msFXK1.gif','http://oss.osalien.com/dbblog/20200929/3f2b63cfa9ab4b35a1c6c5a0bdbaf58f.gif'),(113,'msFzVK.gif','http://oss.osalien.com/dbblog/20200929/81d7a8d9455b4799b9c640ce1e746abd.gif'),(114,'image.png','http://oss.osalien.com/dbblog/20200929/9eadd044c4c5409dae039cbf8418f66f.png'),(115,'image.png','http://oss.osalien.com/dbblog/20200929/f60589d25ce141e08f62daddb2228e12.png'),(116,'image.png','http://oss.osalien.com/dbblog/20200929/9fe6e08842434b01bab6d7b7b3cfa604.png'),(117,'image.png','http://oss.osalien.com/dbblog/20200929/c633a03a8a6b4ed0a82b9bf2eea1242f.png'),(118,'image.png','http://oss.osalien.com/dbblog/20200929/5a2242c00c894af88b139ef3e2ff268a.png'),(119,'image.png','http://oss.osalien.com/dbblog/20200929/611b85fb037843f084de98902f434930.png'),(120,'image.png','http://oss.osalien.com/dbblog/20200929/0176cc600a554e0aad31eafe09a1c66a.png'),(121,'image.png','http://oss.osalien.com/dbblog/20200929/30ee91ee22554d39a3f125cd998d2c23.png'),(122,'image.png','http://oss.osalien.com/dbblog/20200929/576f09b3e1954019bcae81b0a5fce5e9.png'),(123,'Java核心技术卷一.jpg','http://oss.osalien.com/dbblog/20200930/8d3ff46326fb4e59ae2b916af98b45af.jpg'),(124,'image.png','http://oss.osalien.com/dbblog/20201009/67e10dd51dc74af18d439e4f65c62df3.png'),(125,'image.png','http://oss.osalien.com/dbblog/20201009/c218b80c85e54887990f58bdb350e9b5.png'),(126,'image.png','http://oss.osalien.com/dbblog/20201009/6412ab3a46b54f0eae11f5ac94956a38.png'),(127,'image.png','http://oss.osalien.com/dbblog/20201009/5167aa9ce63347448baec159e1fa148a.png'),(128,'image.png','http://oss.osalien.com/dbblog/20201009/dc15839cbd7e4130b4295b9f80f5ffe5.png'),(129,'image.png','http://oss.osalien.com/dbblog/20201009/f11f47101ba743fda59417cdefeb12c3.png'),(130,'image.png','http://oss.osalien.com/dbblog/20201009/04e7ebfb652e4092ac48f6cfafd699c0.png'),(131,'image.png','http://oss.osalien.com/dbblog/20201009/ce46094ddf10467497bdeb3df7f38ec8.png');
/*!40000 ALTER TABLE `oss_resource` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `recommend`
--

DROP TABLE IF EXISTS `recommend`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `recommend` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `link_id` int(11) DEFAULT NULL COMMENT '推荐的文章Id',
  `type` int(11) DEFAULT NULL COMMENT '推荐类型',
  `order_num` int(11) DEFAULT '0' COMMENT '顺序',
  `title` varchar(100) DEFAULT NULL COMMENT '标题',
  `top` tinyint(1) DEFAULT '0' COMMENT '置顶',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COMMENT='推荐';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `recommend`
--

LOCK TABLES `recommend` WRITE;
/*!40000 ALTER TABLE `recommend` DISABLE KEYS */;
INSERT INTO `recommend` VALUES (1,1,0,0,'本站相关',1),(3,7,0,4,'Mysql双机热备',0),(4,8,0,1,'Spring IOC 容器源码分析',0),(5,9,0,2,'JAVA 线上故障如何完整排查？',0),(6,10,0,3,'一文讲清楚互斥锁、自旋锁、读写锁、悲观锁、乐观锁',0);
/*!40000 ALTER TABLE `recommend` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_menu`
--

DROP TABLE IF EXISTS `sys_menu`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_menu` (
  `menu_id` bigint(20) DEFAULT NULL,
  `parent_id` bigint(20) DEFAULT NULL,
  `name` tinytext,
  `url` varchar(200) DEFAULT NULL,
  `perms` varchar(500) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `icon` tinytext,
  `order_num` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='菜单管理';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_menu`
--

LOCK TABLES `sys_menu` WRITE;
/*!40000 ALTER TABLE `sys_menu` DISABLE KEYS */;
INSERT INTO `sys_menu` VALUES (5,1,'SQL监控','https://osb.osalien.com/dbblog/druid/sql.html',NULL,1,'sql',5),(1,0,'系统管理',NULL,NULL,0,'config',3),(2,1,'管理员列表','sys/user',NULL,1,'admin',1),(3,1,'角色管理','sys/role',NULL,1,'role',2),(4,1,'菜单管理','sys/menu',NULL,1,'menu',3),(15,2,'查看',NULL,'sys:user:list,sys:user:info',2,NULL,0),(16,2,'新增',NULL,'sys:user:save,sys:role:select',2,NULL,0),(17,2,'修改',NULL,'sys:user:update,sys:role:select',2,NULL,0),(18,2,'删除',NULL,'sys:user:delete',2,NULL,0),(19,3,'查看',NULL,'sys:role:list,sys:role:info',2,NULL,0),(20,3,'新增',NULL,'sys:role:save,sys:menu:list',2,NULL,0),(21,3,'修改',NULL,'sys:role:update,sys:menu:list',2,NULL,0),(22,3,'删除',NULL,'sys:role:delete',2,NULL,0),(23,4,'查看',NULL,'sys:menu:list,sys:menu:info',2,NULL,0),(24,4,'新增',NULL,'sys:menu:save,sys:menu:select',2,NULL,0),(25,4,'修改',NULL,'sys:menu:update,sys:menu:select',2,NULL,0),(26,4,'删除',NULL,'sys:menu:delete',2,NULL,0),(30,0,'博文管理',NULL,NULL,0,'article',0),(31,30,'新增博文','article/article-add-or-update','article:save,article:update',1,'add',0),(32,30,'博文列表','article/article',NULL,1,'list',0),(33,32,'删除',NULL,'article:delete',2,NULL,0),(34,32,'查看',NULL,'article:list',2,NULL,0),(38,43,'分类管理','operation/category',NULL,1,'category',6),(39,38,'查看',NULL,'operation:category:list,operation:category:info',2,NULL,6),(40,38,'新增',NULL,'operation:category:save',2,NULL,6),(41,38,'修改',NULL,'operation:category:update',2,NULL,6),(42,38,'删除',NULL,'operation:category:delete',2,NULL,6),(43,0,'运营管理',NULL,NULL,0,'operation',2),(45,1,'系统参数','sys/param',NULL,1,'param',4),(46,45,'查看',NULL,'sys:param:list,sys:param:info',2,NULL,6),(47,45,'新增',NULL,'sys:param:save',2,NULL,6),(48,45,'修改',NULL,'sys:param:update',2,NULL,6),(49,45,'删除',NULL,'sys:param:delete',2,NULL,6),(50,43,'标签管理','operation/tag',NULL,1,'tag',6),(51,50,'查看',NULL,'operation:tag:list,operation:tag:info',2,NULL,6),(52,50,'新增',NULL,'operation:tag:save',2,NULL,6),(53,50,'修改',NULL,'operation:tag:update',2,NULL,6),(54,50,'删除',NULL,'operation:tag:delete',2,NULL,6),(55,60,'评论管理','https://valine.osalien.com',NULL,1,'comment',6),(56,55,'查看',NULL,'comment:list,comment:info',2,NULL,6),(57,55,'新增',NULL,'comment:save',2,NULL,6),(58,55,'修改',NULL,'comment:update',2,NULL,6),(59,55,'删除',NULL,'comment:delete',2,NULL,6),(60,0,'评论管理',NULL,NULL,0,'comment',5),(61,66,'图书管理','book/book',NULL,1,'list',3),(62,61,'查看',NULL,'book:list,book:info',2,NULL,6),(63,61,'新增',NULL,'book:save',2,NULL,6),(64,61,'修改',NULL,'book:update',2,NULL,6),(65,61,'删除',NULL,'book:delete',2,NULL,6),(66,0,'阅读管理',NULL,NULL,0,'read',1),(67,66,'新增图书','book/book-add-or-update','',1,'add',1),(68,66,'笔记管理','book/note',NULL,1,'list',2),(69,68,'查看',NULL,'book:note:list,book:note:info',2,NULL,6),(70,68,'新增',NULL,'book:note:save',2,NULL,6),(71,68,'修改',NULL,'book:note:update',2,NULL,6),(72,68,'删除',NULL,'book:note:delete',2,NULL,6),(73,66,'新增笔记','book/note-add-or-update','',1,'add',0),(74,43,'友链管理','operation/link',NULL,1,'link',6),(75,74,'查看',NULL,'operation:link:list,operation:link:info',2,NULL,6),(76,74,'新增',NULL,'operation:link:save',2,NULL,6),(77,74,'修改',NULL,'operation:link:update',2,NULL,6),(78,74,'删除',NULL,'operation:link:delete',2,NULL,6),(79,43,'推荐管理','operation/recommend',NULL,1,'recommend',6),(80,79,'查看',NULL,'operation:recommend:list,operation:recommend:info',2,NULL,6),(81,79,'新增',NULL,'operation:recommend:save',2,NULL,6),(82,79,'修改',NULL,'operation:recommend:update',2,NULL,6),(83,79,'删除',NULL,'operation:recommend:delete',2,NULL,6);
/*!40000 ALTER TABLE `sys_menu` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_param`
--

DROP TABLE IF EXISTS `sys_param`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_param` (
  `id` int(11) DEFAULT NULL,
  `par_key` int(11) DEFAULT NULL,
  `par_value` varchar(255) DEFAULT NULL,
  `menu_url` varchar(255) DEFAULT NULL,
  `type` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='系统参数';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_param`
--

LOCK TABLES `sys_param` WRITE;
/*!40000 ALTER TABLE `sys_param` DISABLE KEYS */;
INSERT INTO `sys_param` VALUES (2,0,'一级','/operation-category','CATEGORY_RANK'),(3,1,'二级','/operation-category','CATEGORY_RANK'),(4,2,'三级','/operation-category','CATEGORY_RANK'),(7,0,'小图片','/article-addOrUpdate','ARTICLE_COVER_TYPE'),(8,1,'大图片','/article-addOrUpdate','ARTICLE_COVER_TYPE'),(9,2,'无图片','/article-addOrUpdate','ARTICLE_COVER_TYPE'),(10,0,'文章',NULL,'MODULE_TYPE'),(11,1,'图书',NULL,'MODULE_TYPE'),(12,2,'笔记',NULL,'MODULE_TYPE');
/*!40000 ALTER TABLE `sys_param` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_role`
--

DROP TABLE IF EXISTS `sys_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_role` (
  `role_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `role_name` varchar(100) DEFAULT NULL COMMENT '角色名称',
  `remark` varchar(100) DEFAULT NULL COMMENT '备注',
  `create_user_id` bigint(20) DEFAULT NULL COMMENT '创建者ID',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='角色';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_role`
--

LOCK TABLES `sys_role` WRITE;
/*!40000 ALTER TABLE `sys_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `sys_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_role_menu`
--

DROP TABLE IF EXISTS `sys_role_menu`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_role_menu` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `role_id` bigint(20) DEFAULT NULL COMMENT '角色ID',
  `menu_id` bigint(20) DEFAULT NULL COMMENT '菜单ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='角色与菜单对应关系';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_role_menu`
--

LOCK TABLES `sys_role_menu` WRITE;
/*!40000 ALTER TABLE `sys_role_menu` DISABLE KEYS */;
/*!40000 ALTER TABLE `sys_role_menu` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_user`
--

DROP TABLE IF EXISTS `sys_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_user` (
  `user_id` int(11) DEFAULT NULL,
  `username` tinytext,
  `password` varchar(255) DEFAULT NULL,
  `email` tinytext,
  `salt` tinytext,
  `create_user_id` tinytext,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `status` tinyint(4) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_user`
--

LOCK TABLES `sys_user` WRITE;
/*!40000 ALTER TABLE `sys_user` DISABLE KEYS */;
INSERT INTO `sys_user` VALUES (1,'admin','72d62f4fe31281677eb30aac311049fe5a3026924c3ad91f27b1ce1bd20c5a2d','me@osalien.com','YzcmCZNvbXocrsz9dm8e','1','2020-05-15 08:06:29',1);
/*!40000 ALTER TABLE `sys_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_user_role`
--

DROP TABLE IF EXISTS `sys_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_user_role` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `role_id` bigint(20) DEFAULT NULL COMMENT '角色ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户与角色对应关系';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_user_role`
--

LOCK TABLES `sys_user_role` WRITE;
/*!40000 ALTER TABLE `sys_user_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `sys_user_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tag`
--

DROP TABLE IF EXISTS `tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL COMMENT '标签名字',
  `type` int(11) DEFAULT NULL COMMENT '所属类别：0文章，1类别',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT='标签';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tag`
--

LOCK TABLES `tag` WRITE;
/*!40000 ALTER TABLE `tag` DISABLE KEYS */;
INSERT INTO `tag` VALUES (1,'本站相关',0),(7,'Java',0),(11,'数据库',0),(12,'关系型数据库',0),(13,'mysql',0),(14,'开源框架',0),(15,'源码解析',0),(16,'Spring',0),(17,'LeetCode',2),(18,'初级算法',2),(19,'算法',2),(20,'数组',2),(23,'LeetCode',1),(24,'锁',0),(25,'高并发',0),(26,'事务',0),(27,'Java Web',0),(28,'验证码',0),(29,'Java',1),(30,'故障排查',0);
/*!40000 ALTER TABLE `tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tag_link`
--

DROP TABLE IF EXISTS `tag_link`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tag_link` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `tag_id` int(11) DEFAULT NULL COMMENT '标签Id',
  `link_id` int(11) DEFAULT NULL COMMENT '关联Id',
  `type` int(11) DEFAULT NULL COMMENT '所属类别：0文章，1阅读',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=297 DEFAULT CHARSET=utf8 COMMENT='标签多对多维护表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tag_link`
--

LOCK TABLES `tag_link` WRITE;
/*!40000 ALTER TABLE `tag_link` DISABLE KEYS */;
INSERT INTO `tag_link` VALUES (251,7,11,0),(252,27,11,0),(253,28,11,0),(254,7,10,0),(255,11,10,0),(256,24,10,0),(257,25,10,0),(258,26,10,0),(260,11,7,0),(261,12,7,0),(262,13,7,0),(263,14,8,0),(264,15,8,0),(265,16,8,0),(266,1,1,0),(267,29,2,1),(268,23,1,1),(277,17,2,2),(278,19,2,2),(279,18,2,2),(280,20,2,2),(281,17,1,2),(282,19,1,2),(283,18,1,2),(284,20,1,2),(285,7,9,0),(286,30,9,0),(295,7,12,0),(296,30,12,0);
/*!40000 ALTER TABLE `tag_link` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-10-10 15:17:41
