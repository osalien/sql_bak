-- MySQL dump 10.13  Distrib 5.7.11, for linux-glibc2.5 (x86_64)
--
-- Host: localhost    Database: dbblog
-- ------------------------------------------------------
-- Server version	5.7.11

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(50) NOT NULL COMMENT '文章标题',
  `description` varchar(255) DEFAULT NULL COMMENT '文章描述',
  `author` varchar(50) DEFAULT NULL COMMENT '文章作者',
  `content` longtext COMMENT '文章内容',
  `content_format` longtext COMMENT 'html的content',
  `read_num` int(11) DEFAULT '0' COMMENT '阅读量',
  `comment_num` int(11) DEFAULT '0' COMMENT '评论量',
  `like_num` int(11) DEFAULT '0' COMMENT '点赞量',
  `cover_type` int(11) DEFAULT NULL COMMENT '文章展示类别,1:普通，2：大图片，3：无图片',
  `cover` text COMMENT '封面',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  `recommend` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否推荐文章',
  `category_id` varchar(50) DEFAULT NULL COMMENT '分类类别存在多级分类，用逗号隔开',
  `publish` tinyint(4) DEFAULT '0' COMMENT '发布状态',
  `top` tinyint(1) DEFAULT '0' COMMENT '是否置顶',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT='文章';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (1,'本站相关','我又岂是孤岛，来往航船不曾停泊，触礁沉没皆是心防。我只是孤岛，羊皮纸上不曾有过的坐标，唯风吹万里，白云相知。我盛满胜欲者的孤独，自负放在胸前，云雨来便慷慨赠予。','Coding实验室','### 简介\n一只有梦想的咸鱼，幻想着有一天能暴富  \n一个传说中的计算机程序猿，捞钱大法保平安  \n一个站在域名投资领域最底端的米农  \n目前在上海，可约不可撩๑乛◡乛๑  \nSize：1.75M...60KG...18CM ๑乛◡乛๑\n\n### 兴趣\n业余爱好嘛，喜欢听听歌，爬爬山，打打羽毛球球  \n计算机相关的呢，喜欢做做网站，做做开发  \n嗯，还喜欢新媒体运营（做过微信/QQ 公众号）\n\n### 擅长\n前端设计？ H5、Js、Jq、Vue、React...  \n后端开发？ Java、Nodejs、Mysql、Postgresql...  \n计算机&互联网相关的各种黑科技\n\n### 书籍\n《人工智能革命：超级智能时代的人类命运》  \n《天才在左，疯子在右》  \n《异类的天赋：天才、疯子和内向人格的成功密码》\n\n### 目标\n曾经想成为一个：全桟工程师  \n现在只想攒够可以实现目标的Money  \nemmm......  \n自问：最终想成为什么？  \n自答：????????????\n\n### 联系\n邮箱：me@osalien.com  \n\n### Coding实验室:\n![公众号二维码.jpg](http://oss.osalien.com/dbblog/20201012/c759f97988da46f2aa3f9dd96a8e3a18.jpg)\n','<h3 id=\"简介\">简介</h3>\n<p>一只有梦想的咸鱼，幻想着有一天能暴富<br>一个传说中的计算机程序猿，捞钱大法保平安<br>一个站在域名投资领域最底端的米农<br>目前在上海，可约不可撩๑乛◡乛๑<br>Size：1.75M...60KG...18CM ๑乛◡乛๑</p>\n<h3 id=\"兴趣\">兴趣</h3>\n<p>业余爱好嘛，喜欢听听歌，爬爬山，打打羽毛球球<br>计算机相关的呢，喜欢做做网站，做做开发<br>嗯，还喜欢新媒体运营（做过微信/QQ 公众号）</p>\n<h3 id=\"擅长\">擅长</h3>\n<p>前端设计？ H5、Js、Jq、Vue、React...<br>后端开发？ Java、Nodejs、Mysql、Postgresql...<br>计算机&amp;互联网相关的各种黑科技</p>\n<h3 id=\"书籍\">书籍</h3>\n<p>《人工智能革命：超级智能时代的人类命运》<br>《天才在左，疯子在右》<br>《异类的天赋：天才、疯子和内向人格的成功密码》</p>\n<h3 id=\"目标\">目标</h3>\n<p>曾经想成为一个：全桟工程师<br>现在只想攒够可以实现目标的Money<br>emmm......<br>自问：最终想成为什么？<br>自答：????????????</p>\n<h3 id=\"联系\">联系</h3>\n<p>邮箱：<a href=\"mailto:me@osalien.com\">me@osalien.com</a>  </p>\n<h3 id=\"coding实验室\">Coding实验室:</h3>\n<p><img src=\"http://oss.osalien.com/dbblog/20201012/c759f97988da46f2aa3f9dd96a8e3a18.jpg\" alt=\"公众号二维码.jpg\"></p>\n',747,0,35,2,NULL,'2017-12-31 16:00:00','2020-10-11 22:13:25',1,'1',1,1),(7,'Mysql双机热备','热备份指的是：High Available（HA）即高可用，而备份指的是Backup，数据备份的一种。这是两种不同的概念，应对的产品也是两种功能上完全不同的产品。热备份主要保障业务的连续性，实现的方法是故障点的转移。而备份，主要目的是为了防止数据丢失，而做的一份拷贝，所以备份强调的是数据恢复而不是应用的故障转移。','Coding实验室','### 一、概念\n\n#### 1、热备份和备份的区别\n\n&emsp;&emsp;热备份指的是：High Available（HA）即高可用，而备份指的是Backup，数据备份的一种。这是两种不同的概念，应对的产品也是两种功能上完全不同的产品。热备份主要保障业务的连续性，实现的方法是故障点的转移。而备份，主要目的是为了防止数据丢失，而做的一份拷贝，所以备份强调的是数据恢复而不是应用的故障转移。\n\n#### 2、什么是双机热备?　\n\n&emsp;&emsp;双机热备从广义上讲，就是对于重要的服务，使用两台服务器，互相备份，共同执行同一服务。当一台服务器出现故障时，可以由另一台服务器承担服务任务，从而在不需要人工干预的情况下，自动保证系统能持续提供服务。\n\n&emsp;&emsp;从狭义上讲，双机热备就是使用互为备份的两台服务器共同执行同一服务，其中一台主机为工作机（Primary Server），另一台主机为备份主机（Standby Server）。在系统正常情况下，工作机为应用系统提供服务，备份机监视工作机的运行情况（一般是通过心跳诊断，工作机同时也在检测备份机是否正常），当工作机出现异常，不能支持应用系统运营时，备份机主动接管工作机的工作，继续支持关键应用服务，保证系统不间断的运行。双机热备针对的是IT核心服务器、存储、网络路由交换的故障的高可用性解决方案。\n\n### 二、环境描述\n#### 1、master\n\n&emsp;系统：centos 7 \n\n&emsp;数据库：mysql 5.7.30\n\n&emsp;ip：192.168.0.123\n\n#### 2、slave\n\n&emsp;系统：centos 7  \n\n&emsp;数据库：mysql 5.7.30\n\n&emsp;ip：192.168.0.105\n\n    （注：主服务器的版本不能高于从服务器版本 ，两台服务器须处于同一局域网）\n\n### 三、主从热备实现\n\n#### 1、账户准备\n\n&emsp;①在master服务器上为从服务器建立一个连接帐户，该帐户必须授予REPLICATION SLAVE权限。进入mysql操作界面，输入以下SQL：\n\n```\ngrant replication slave on *.* to \'replicate\'@\'192.168.0.105\' identified by \'123456\';\n\nflush privileges;\n```\n&emsp;操作如图：　\n\n　![image.png](http://oss.osalien.com/dbblog/20200518/a55c974deb1b463c945c6a43205d055a.png)\n\n&emsp;②验证连接账户\n\n&emsp;在从服务器（slave）上用replicat帐户对主服务器（master）数据库进行访问，看是否可以连接成功。\n\n&emsp;在从服务器打开命令提示符，输入以下命令：\n\n```\nmysql -h192.168.0.123 -ureplicate -p123456\n```\n&emsp;如果出现下面的结果，则表示能登录成功，说明可以对这两台服务器进行双机热备进行操作。  \n\n![image.png](http://oss.osalien.com/dbblog/20200518/7da093a7d1b541e8aec90f5da63f6b8f.png)\n#### 2、master配置\n\n&emsp;①修改mysql配置文件。找到my.cnf配置文件打开后，在[mysqld]下修改即可：\n```\n[mysqld]\n\nserver-id = 123 #主ID，与从ID不能相同\n\nlog-bin=mysql-bin # 设定生成log文件名\n\nbinlog-do-db = test_db #设置同步数据库名\n\nreplicate-do-db=test_db   # 从服务器同步数据库名\n\nbinlog-ignore-db = mysql  #避免同步mysql用户配置\n```\n&emsp;②重启mysql服务\n\n&emsp;打开命令提示符，输入以下两条命令完成重启：\n```\nservice mysql stop\nservice mysql start\n```\n&emsp;③查看master服务器状态\n```\nshow master status;\n```\n&emsp;④锁表\n\n&emsp;目的是为了产生环境中不让进新的数据，好让从服务器定位同步位置，初次同步完成后，记得解锁\n```\nflush tables with read lock;\n```\n&emsp;步骤③④操作如图：  \n\n![image.png](http://oss.osalien.com/dbblog/20200518/ef398346fe4349fa8b60cd8ca28c26c0.png)\n#### 3、slave配置\n\n&emsp;①修改my.cnf配置文件\n```\nlog-bin=mysql-bin #设定生成log文件名\nserver-id=105 # 从ID，与主ID不能相同\nbinlog-do-db=test_db #设置同步数据库名\nbinlog-ignore-db=mysql #避免同步mysql用户配置\nreplicate-do-db=test_db # 从服务器同步数据库名\nreplicate-ignore-db = mysql,information_schema,performance_schema\n```\n&emsp;②重启mysql服务\n\n&emsp;③用change mster 语句指定同步位置\n\n&emsp;进入mysql操作界面后，输入如下指令：\n```\nstop slave;\nreset slave;\nchange master to master_host=\'192.168.0.123\',master_user=\'replicate\',master_password=\'123456\',master_log_file=\'mysql-bin.000124\',master_log_pos=107;\nstart slave;\n``` \n&emsp;\n```\n注：这里的master_log_file、master_log_pos必须和前面show master status查询结果保持一致\n```\n\n&emsp;操作如图：  \n![image.png](http://oss.osalien.com/dbblog/20200518/76da426c28094d8aaa0b7401c4b5ac0e.png)\n#### 4、解锁master表\n```\nunlock tables;\n```  \n\n至此，主从热备实现完成，可进行测试操作。','<h3 id=\"一、概念\">一、概念</h3>\n<h4 id=\"1、热备份和备份的区别\">1、热备份和备份的区别</h4>\n<p>&emsp;&emsp;热备份指的是：High Available（HA）即高可用，而备份指的是Backup，数据备份的一种。这是两种不同的概念，应对的产品也是两种功能上完全不同的产品。热备份主要保障业务的连续性，实现的方法是故障点的转移。而备份，主要目的是为了防止数据丢失，而做的一份拷贝，所以备份强调的是数据恢复而不是应用的故障转移。</p>\n<h4 id=\"2、什么是双机热备\">2、什么是双机热备?　</h4>\n<p>&emsp;&emsp;双机热备从广义上讲，就是对于重要的服务，使用两台服务器，互相备份，共同执行同一服务。当一台服务器出现故障时，可以由另一台服务器承担服务任务，从而在不需要人工干预的情况下，自动保证系统能持续提供服务。</p>\n<p>&emsp;&emsp;从狭义上讲，双机热备就是使用互为备份的两台服务器共同执行同一服务，其中一台主机为工作机（Primary Server），另一台主机为备份主机（Standby Server）。在系统正常情况下，工作机为应用系统提供服务，备份机监视工作机的运行情况（一般是通过心跳诊断，工作机同时也在检测备份机是否正常），当工作机出现异常，不能支持应用系统运营时，备份机主动接管工作机的工作，继续支持关键应用服务，保证系统不间断的运行。双机热备针对的是IT核心服务器、存储、网络路由交换的故障的高可用性解决方案。</p>\n<h3 id=\"二、环境描述\">二、环境描述</h3>\n<h4 id=\"1、master\">1、master</h4>\n<p>&emsp;系统：centos 7 </p>\n<p>&emsp;数据库：mysql 5.7.30</p>\n<p>&emsp;ip：192.168.0.123</p>\n<h4 id=\"2、slave\">2、slave</h4>\n<p>&emsp;系统：centos 7  </p>\n<p>&emsp;数据库：mysql 5.7.30</p>\n<p>&emsp;ip：192.168.0.105</p>\n<pre><code>（注：主服务器的版本不能高于从服务器版本 ，两台服务器须处于同一局域网）</code></pre><h3 id=\"三、主从热备实现\">三、主从热备实现</h3>\n<h4 id=\"1、账户准备\">1、账户准备</h4>\n<p>&emsp;①在master服务器上为从服务器建立一个连接帐户，该帐户必须授予REPLICATION SLAVE权限。进入mysql操作界面，输入以下SQL：</p>\n<pre><code>grant replication slave on *.* to &#39;replicate&#39;@&#39;192.168.0.105&#39; identified by &#39;123456&#39;;\n\nflush privileges;</code></pre><p>&emsp;操作如图：　</p>\n<p>　<img src=\"http://oss.osalien.com/dbblog/20200518/a55c974deb1b463c945c6a43205d055a.png\" alt=\"image.png\"></p>\n<p>&emsp;②验证连接账户</p>\n<p>&emsp;在从服务器（slave）上用replicat帐户对主服务器（master）数据库进行访问，看是否可以连接成功。</p>\n<p>&emsp;在从服务器打开命令提示符，输入以下命令：</p>\n<pre><code>mysql -h192.168.0.123 -ureplicate -p123456</code></pre><p>&emsp;如果出现下面的结果，则表示能登录成功，说明可以对这两台服务器进行双机热备进行操作。  </p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200518/7da093a7d1b541e8aec90f5da63f6b8f.png\" alt=\"image.png\"></p>\n<h4 id=\"2、master配置\">2、master配置</h4>\n<p>&emsp;①修改mysql配置文件。找到my.cnf配置文件打开后，在[mysqld]下修改即可：</p>\n<pre><code>[mysqld]\n\nserver-id = 123 #主ID，与从ID不能相同\n\nlog-bin=mysql-bin # 设定生成log文件名\n\nbinlog-do-db = test_db #设置同步数据库名\n\nreplicate-do-db=test_db   # 从服务器同步数据库名\n\nbinlog-ignore-db = mysql  #避免同步mysql用户配置</code></pre><p>&emsp;②重启mysql服务</p>\n<p>&emsp;打开命令提示符，输入以下两条命令完成重启：</p>\n<pre><code>service mysql stop\nservice mysql start</code></pre><p>&emsp;③查看master服务器状态</p>\n<pre><code>show master status;</code></pre><p>&emsp;④锁表</p>\n<p>&emsp;目的是为了产生环境中不让进新的数据，好让从服务器定位同步位置，初次同步完成后，记得解锁</p>\n<pre><code>flush tables with read lock;</code></pre><p>&emsp;步骤③④操作如图：  </p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200518/ef398346fe4349fa8b60cd8ca28c26c0.png\" alt=\"image.png\"></p>\n<h4 id=\"3、slave配置\">3、slave配置</h4>\n<p>&emsp;①修改my.cnf配置文件</p>\n<pre><code>log-bin=mysql-bin #设定生成log文件名\nserver-id=105 # 从ID，与主ID不能相同\nbinlog-do-db=test_db #设置同步数据库名\nbinlog-ignore-db=mysql #避免同步mysql用户配置\nreplicate-do-db=test_db # 从服务器同步数据库名\nreplicate-ignore-db = mysql,information_schema,performance_schema</code></pre><p>&emsp;②重启mysql服务</p>\n<p>&emsp;③用change mster 语句指定同步位置</p>\n<p>&emsp;进入mysql操作界面后，输入如下指令：</p>\n<pre><code>stop slave;\nreset slave;\nchange master to master_host=&#39;192.168.0.123&#39;,master_user=&#39;replicate&#39;,master_password=&#39;123456&#39;,master_log_file=&#39;mysql-bin.000124&#39;,master_log_pos=107;\nstart slave;</code></pre><p>&emsp;</p>\n<pre><code>注：这里的master_log_file、master_log_pos必须和前面show master status查询结果保持一致</code></pre><p>&emsp;操作如图：<br><img src=\"http://oss.osalien.com/dbblog/20200518/76da426c28094d8aaa0b7401c4b5ac0e.png\" alt=\"image.png\"></p>\n<h4 id=\"4、解锁master表\">4、解锁master表</h4>\n<pre><code>unlock tables;</code></pre><p>至此，主从热备实现完成，可进行测试操作。</p>\n',237,0,38,2,NULL,'2019-01-18 00:49:23','2020-09-30 00:49:04',1,'45,17,19',1,0),(8,'Spring IOC 容器源码分析','Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。','javadoop','Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。\n\n本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。\n\n阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。\n\n希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。\n\n\n## 引言\n\n先看下最基本的启动 Spring 容器的例子：\n\n```java\npublic static void main(String[] args) {\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationfile.xml\");\n}\n```\n\n以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。\n\n```java\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-context</artifactId>\n  <version>4.3.11.RELEASE</version>\n</dependency>\n```\n\n> spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。\n\n多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。\n\n废话说完，我们继续。`ApplicationContext context = new ClassPathXmlApplicationContext(...)` 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：\n\n![image.png](http://oss.osalien.com/dbblog/20200520/967eae0f814441f6ae52d3b8d1e6116d.png)\n\n> 读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。\n>\n> 当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。\n\n我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 **FileSystemXmlApplicationContext** 和 **AnnotationConfigApplicationContext** 这两个类。\n\n**1、FileSystemXmlApplicationContext** 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。\n\n**2、AnnotationConfigApplicationContext** 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。\n\n不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。\n\n我们先来一个简单的例子来看看怎么实例化 ApplicationContext。\n\n首先，定义一个接口：\n\n```java\npublic interface MessageService {\n    String getMessage();\n}\n```\n\n定义接口实现类：\n\n```java\npublic class MessageServiceImpl implements MessageService {\n\n    public String getMessage() {\n        return \"hello world\";\n    }\n}\n```\n\n接下来，我们在 **resources** 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\">\n\n    <bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"/>\n</beans>\n```\n\n这样，我们就可以跑起来了：\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        // 用我们的配置文件来启动一个 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\");\n      \n        System.out.println(\"context 启动成功\");\n      \n        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式\n        MessageService messageService = context.getBean(MessageService.class);\n        // 这句将输出: hello world\n        System.out.println(messageService.getMessage());\n    }\n}\n```\n\n以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。\n\n## BeanFactory 简介\n\nBeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。\n\n初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：\n\n![image.png](http://oss.osalien.com/dbblog/20200520/2de3ac3554d84c9eabff1d50eed3e5c8.png)\n\n我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。\n\n1. ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。\n2. ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。\n3. AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。\n4. ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。\n5. 请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。\n\n\n然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。\n\n## 启动过程分析\n\n下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。\n\n第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。\n\n```java\npublic class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {\n  private Resource[] configResources;\n  \n  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法\n  public ClassPathXmlApplicationContext(ApplicationContext parent) {\n    super(parent);\n  }\n  ...\n  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)\n      throws BeansException {\n\n    super(parent);\n    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)\n    setConfigLocations(configLocations);\n    if (refresh) {\n      refresh(); // 核心方法\n    }\n  }\n    ...\n}\n```\n\n接下来，就是 `refresh()`，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。\n\n往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n     \n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n        \n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset \'active\' flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring\'s core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n下面，我们开始一步步来肢解这个 refresh() 方法。\n\n### 创建 Bean 容器前的准备工作\n\n这个比较简单，直接看代码中的几个注释即可。\n\n```java\nprotected void prepareRefresh() {\n   // 记录启动时间，\n   // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型\n   this.startupDate = System.currentTimeMillis();\n   this.closed.set(false);\n   this.active.set(true);\n\n   if (logger.isInfoEnabled()) {\n      logger.info(\"Refreshing \" + this);\n   }\n\n   // Initialize any placeholder property sources in the context environment\n   initPropertySources();\n\n   // 校验 xml 配置文件\n   getEnvironment().validateRequiredProperties();\n\n   this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();\n}\n```\n\n### 创建 Bean 容器，加载并注册 Bean\n\n我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。\n\n注意，**这个方法是全文最重要的部分之一**，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。\n\n当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。\n\n// AbstractApplicationContext.java\n\n```java\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等\n   refreshBeanFactory();\n  \n   // 返回刚刚创建的 BeanFactory\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n   }\n   return beanFactory;\n}\n```\n\n// AbstractRefreshableApplicationContext.java 120\n\n```java\n@Override\nprotected final void refreshBeanFactory() throws BeansException {\n   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory\n   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前\n   // ApplicationContext 是否有 BeanFactory\n   if (hasBeanFactory()) {\n      destroyBeans();\n      closeBeanFactory();\n   }\n   try {\n      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。\n      DefaultListableBeanFactory beanFactory = createBeanFactory();\n      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到\n      beanFactory.setSerializationId(getId());\n     \n      // 下面这两个方法很重要，别跟丢了，具体细节之后说\n      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用\n      customizeBeanFactory(beanFactory);\n     \n      // 加载 Bean 到 BeanFactory 中\n      loadBeanDefinitions(beanFactory);\n      synchronized (this.beanFactoryMonitor) {\n         this.beanFactory = beanFactory;\n      }\n   }\n   catch (IOException ex) {\n      throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex);\n   }\n}\n```\n\n> 看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。\n\n我们说说为什么选择实例化 **DefaultListableBeanFactory** ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：\n\n![image.png](http://oss.osalien.com/dbblog/20200520/cbfc0b05edac444098b395de90f5e463.png)\n\n我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。\n\n> 如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？\n>\n> 之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。\n>\n> 那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。\n\n在继续往下之前，我们需要先了解 BeanDefinition。**我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？**\n\n这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。\n\n所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。\n\n> BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。\n\n#### BeanDefinition 接口定义\n\n我们来看下 BeanDefinition 的接口定义：\n\n```java\npublic interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {\n\n   // 我们可以看到，默认只提供 sington 和 prototype 两种，\n   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，\n   // 不过，它们属于基于 web 的扩展。\n   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;\n   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;\n\n   // 比较不重要，直接跳过吧\n   int ROLE_APPLICATION = 0;\n   int ROLE_SUPPORT = 1;\n   int ROLE_INFRASTRUCTURE = 2;\n\n   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍\n   // 一句话就是：继承父 Bean 的配置信息而已\n   void setParentName(String parentName);\n  \n   // 获取父 Bean\n   String getParentName();\n  \n   // 设置 Bean 的类名称，将来是要通过反射来生成实例的\n   void setBeanClassName(String beanClassName);\n   \n   // 获取 Bean 的类名称\n   String getBeanClassName();\n\n \n   // 设置 bean 的 scope\n   void setScope(String scope);\n\n   String getScope();\n\n   // 设置是否懒加载\n   void setLazyInit(boolean lazyInit);\n   \n   boolean isLazyInit();\n\n   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，\n   // 是 depends-on=\"\" 属性设置的值。\n   void setDependsOn(String... dependsOn);\n\n   // 返回该 Bean 的所有依赖\n   String[] getDependsOn();\n\n   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，\n   // 如果根据名称注入，即使这边设置了 false，也是可以的\n   void setAutowireCandidate(boolean autowireCandidate);\n\n   // 该 Bean 是否可以注入到其他 Bean 中\n   boolean isAutowireCandidate();\n\n   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean\n   void setPrimary(boolean primary);\n\n   // 是否是 primary 的\n   boolean isPrimary();\n\n   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录\n   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的\n   void setFactoryBeanName(String factoryBeanName);\n   // 获取工厂名称\n   String getFactoryBeanName();\n   // 指定工厂类中的 工厂方法名称\n   void setFactoryMethodName(String factoryMethodName);\n   // 获取工厂类中的 工厂方法名称\n   String getFactoryMethodName();\n\n   // 构造器参数\n   ConstructorArgumentValues getConstructorArgumentValues();\n\n   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到\n   MutablePropertyValues getPropertyValues();\n\n   // 是否 singleton\n   boolean isSingleton();\n\n   // 是否 prototype\n   boolean isPrototype();\n\n   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，\n   // 常用于作为 父bean 用于继承，其实也很少用......\n   boolean isAbstract();\n\n   int getRole();\n   String getDescription();\n   String getResourceDescription();\n   BeanDefinition getOriginatingBeanDefinition();\n}\n```\n\n> 这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。\n>\n> 这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。\n\n有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：\n\n```java\ncustomizeBeanFactory(beanFactory);\nloadBeanDefinitions(beanFactory);\n```\n\n虽然只有两个方法，但路还很长啊。。。\n\n#### customizeBeanFactory\n\ncustomizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。\n\n```java\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n   if (this.allowBeanDefinitionOverriding != null) {\n      // 是否允许 Bean 定义覆盖\n      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n   }\n   if (this.allowCircularReferences != null) {\n      // 是否允许 Bean 间的循环依赖\n      beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n   }\n}\n```\n\nBeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\n循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。\n\n默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。\n\n至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。\n\n之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。\n\n#### 加载 Bean: loadBeanDefinitions\n\n接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。\n\n读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。\n\n// AbstractXmlApplicationContext.java 80\n\n```java\n/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/\n@Override\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader\n   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\n   // Configure the bean definition reader with this context\'s\n   // resource loading environment.\n   beanDefinitionReader.setEnvironment(this.getEnvironment());\n   beanDefinitionReader.setResourceLoader(this);\n   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，\n   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧\n   initBeanDefinitionReader(beanDefinitionReader);\n   // 重点来了，继续往下\n   loadBeanDefinitions(beanDefinitionReader);\n}\n```\n\n现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。\n\n// AbstractXmlApplicationContext.java 120\n\n```java\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n   Resource[] configResources = getConfigResources();\n   if (configResources != null) {\n      // 往下看\n      reader.loadBeanDefinitions(configResources);\n   }\n   String[] configLocations = getConfigLocations();\n   if (configLocations != null) {\n      // 2\n      reader.loadBeanDefinitions(configLocations);\n   }\n}\n\n// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里\n@Override\npublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {\n   Assert.notNull(resources, \"Resource array must not be null\");\n   int counter = 0;\n   // 注意这里是个 for 循环，也就是每个文件是一个 resource\n   for (Resource resource : resources) {\n      // 继续往下看\n      counter += loadBeanDefinitions(resource);\n   }\n   // 最后返回 counter，表示总共加载了多少的 BeanDefinition\n   return counter;\n}\n\n// XmlBeanDefinitionReader 303\n@Override\npublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n   return loadBeanDefinitions(new EncodedResource(resource));\n}\n\n// XmlBeanDefinitionReader 314\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n   Assert.notNull(encodedResource, \"EncodedResource must not be null\");\n   if (logger.isInfoEnabled()) {\n      logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource());\n   }\n   // 用一个 ThreadLocal 来存放配置文件资源\n   Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();\n   if (currentResources == null) {\n      currentResources = new HashSet<EncodedResource>(4);\n      this.resourcesCurrentlyBeingLoaded.set(currentResources);\n   }\n   if (!currentResources.add(encodedResource)) {\n      throw new BeanDefinitionStoreException(\n            \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\");\n   }\n   try {\n      InputStream inputStream = encodedResource.getResource().getInputStream();\n      try {\n         InputSource inputSource = new InputSource(inputStream);\n         if (encodedResource.getEncoding() != null) {\n            inputSource.setEncoding(encodedResource.getEncoding());\n         }\n         // 核心部分是这里，往下面看\n         return doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n      }\n      finally {\n         inputStream.close();\n      }\n   }\n   catch (IOException ex) {\n      throw new BeanDefinitionStoreException(\n            \"IOException parsing XML document from \" + encodedResource.getResource(), ex);\n   }\n   finally {\n      currentResources.remove(encodedResource);\n      if (currentResources.isEmpty()) {\n         this.resourcesCurrentlyBeingLoaded.remove();\n      }\n   }\n}\n\n// 还在这个文件中，第 388 行\nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n      throws BeanDefinitionStoreException {\n   try {\n      // 这里就不看了，将 xml 文件转换为 Document 对象\n      Document doc = doLoadDocument(inputSource, resource);\n      // 继续\n      return registerBeanDefinitions(doc, resource);\n   }\n   catch (...\n}\n// 还在这个文件中，第 505 行\n// 返回值：返回从当前配置文件加载了多少数量的 Bean\npublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n   int countBefore = getRegistry().getBeanDefinitionCount();\n   // 这里\n   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n   return getRegistry().getBeanDefinitionCount() - countBefore;\n}\n// DefaultBeanDefinitionDocumentReader 90\n@Override\npublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n   this.readerContext = readerContext;\n   logger.debug(\"Loading bean definitions\");\n   Element root = doc.getDocumentElement();\n   // 从 xml 根节点开始解析文件\n   doRegisterBeanDefinitions(root);\n}         \n```\n\n经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：\n\n##### doRegisterBeanDefinitions：\n\n```java\n// DefaultBeanDefinitionDocumentReader 116\nprotected void doRegisterBeanDefinitions(Element root) {\n   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，\n   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，\n   // 因为 <beans /> 内部是可以定义 <beans /> 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 <beans /> 节点，从源码分析的角度，我们当做根节点就好了\n   BeanDefinitionParserDelegate parent = this.delegate;\n   this.delegate = createDelegate(getReaderContext(), root, parent);\n\n   if (this.delegate.isDefaultNamespace(root)) {\n      // 这块说的是根节点 <beans ... profile=\"dev\" /> 中的 profile 是否是当前环境需要的，\n      // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 <beans /> 解析\n      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区\n      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n      if (StringUtils.hasText(profileSpec)) {\n         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n         if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n            if (logger.isInfoEnabled()) {\n               logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec +\n                     \"] not matching: \" + getReaderContext().getResource());\n            }\n            return;\n         }\n      }\n   }\n\n   preProcessXml(root); // 钩子\n   // 往下看\n   parseBeanDefinitions(root, this.delegate);\n   postProcessXml(root); // 钩子\n\n   this.delegate = parent;\n}\n```\n\npreProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。\n\n这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。\n\n接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :\n\n```java\n// default namespace 涉及到的就四个标签 <import />、<alias />、<bean /> 和 <beans />，\n// 其他的属于 custom 的\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n   if (delegate.isDefaultNamespace(root)) {\n      NodeList nl = root.getChildNodes();\n      for (int i = 0; i < nl.getLength(); i++) {\n         Node node = nl.item(i);\n         if (node instanceof Element) {\n            Element ele = (Element) node;\n            if (delegate.isDefaultNamespace(ele)) {\n               // 解析 default namespace 下面的几个元素\n               parseDefaultElement(ele, delegate);\n            }\n            else {\n               // 解析其他 namespace 的元素\n               delegate.parseCustomElement(ele);\n            }\n         }\n      }\n   }\n   else {\n      delegate.parseCustomElement(root);\n   }\n}\n```\n\n从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。\n\nparseDefaultElement(ele, delegate) 代表解析的节点是 `<import />`、`<alias />`、`<bean />`、`<beans />` 这几个。\n\n> 这里的四个标签之所以是 **default** 的，是因为它们是处于这个 namespace 下定义的：\n>\n> ```\n> http://www.springframework.org/schema/beans\n> ```\n>\n> 又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 **xmlns** 就是咯。\n>\n> ```xml\n> <beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n>        xmlns=\"http://www.springframework.org/schema/beans\"\n>        xsi:schemaLocation=\"\n>             http://www.springframework.org/schema/beans\n>           http://www.springframework.org/schema/beans/spring-beans.xsd\"\n>        default-autowire=\"byName\">\n> ```\n>\n> 而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 `<mvc />`、`<task />`、`<context />`、`<aop />`等。\n>\n> 这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。\n>\n> 假如读者想分析 `<context:property-placeholder location=\"classpath:xx.properties\" />` 的实现原理，就应该到 ContextNamespaceHandler 中找答案。\n>\n> ```xml\n> <beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n>       xmlns=\"http://www.springframework.org/schema/beans\"\n>       xmlns:context=\"http://www.springframework.org/schema/context\"\n>       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n>       xsi:schemaLocation=\"\n>            http://www.springframework.org/schema/beans \n>            http://www.springframework.org/schema/beans/spring-beans.xsd\n>            http://www.springframework.org/schema/context\n>            http://www.springframework.org/schema/context/spring-context.xsd\n>            http://www.springframework.org/schema/mvc   \n>            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \n>        \"\n>       default-autowire=\"byName\">\n> ```\n> 同理，以后你要是碰到 `<dubbo />` 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。\n\n回过神来，看看处理 default 标签的方法：\n\n```java\nprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n      // 处理 <import /> 标签\n      importBeanDefinitionResource(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n      // 处理 <alias /> 标签定义\n      // <alias name=\"fromName\" alias=\"toName\"/>\n      processAliasRegistration(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n      // 处理 <bean /> 标签定义，这也算是我们的重点吧\n      processBeanDefinition(ele, delegate);\n   }\n   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n      // 如果碰到的是嵌套的 <beans /> 标签，需要递归\n      doRegisterBeanDefinitions(ele);\n   }\n}\n```\n\n如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 `<bean />` 标签出来说。\n\n##### processBeanDefinition 解析 bean 标签\n\n下面是 processBeanDefinition 解析 `<bean />` 标签：\n\n// DefaultBeanDefinitionDocumentReader 298\n\n```java\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 <bean /> 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n  \n   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的\n  \n   if (bdHolder != null) {\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // Register the final decorated instance.\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(\"Failed to register bean definition with name \'\" +\n               bdHolder.getBeanName() + \"\'\", ele, ex);\n      }\n      // Send registration event.\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}\n```\n\n继续往下看怎么解析之前，我们先看下 **`<bean />`** 标签中可以定义哪些属性：\n\n| Property                 |                                    |\n| ------------------------ | ---------------------------------- |\n| class                    | 类的全限定名                             |\n| name                     | 可指定 id、name(用逗号、分号、空格分隔)           |\n| scope                    | 作用域                                |\n| constructor arguments    | 指定构造参数                             |\n| properties               | 设置属性的值                             |\n| autowiring mode          | no(默认值)、byName、byType、 constructor |\n| lazy-initialization mode | 是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了) |\n| initialization method    | bean 属性设置完成后，会调用这个方法               |\n| destruction method       | bean 销毁后的回调方法                      |\n\n上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。\n\n简单地说就是像下面这样子：\n\n```xml\n<bean id=\"exampleBean\" name=\"name1, name2, name3\" class=\"com.javadoop.ExampleBean\"\n      scope=\"singleton\" lazy-init=\"true\" init-method=\"init\" destroy-method=\"cleanup\">\n  \n    <!-- 可以用下面三种形式指定构造参数 -->\n    <constructor-arg type=\"int\" value=\"7500000\"/>\n    <constructor-arg name=\"years\" value=\"7500000\"/>\n    <constructor-arg index=\"0\" value=\"7500000\"/>\n  \n    <!-- property 的几种情况 -->\n    <property name=\"beanOne\">\n        <ref bean=\"anotherExampleBean\"/>\n    </property>\n    <property name=\"beanTwo\" ref=\"yetAnotherBean\"/>\n    <property name=\"integerProperty\" value=\"1\"/>\n</bean>\n```\n\n当然，除了上面举例出来的这些，还有 factory-bean、factory-method、`<lockup-method />`、`<replaced-method />`、`<meta />`、`<qualifier />` 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。\n\n有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。\n\n// BeanDefinitionParserDelegate 428\n\n```java\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {\n    return parseBeanDefinitionElement(ele, null);\n}\n\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {\n   String id = ele.getAttribute(ID_ATTRIBUTE);\n   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n   List<String> aliases = new ArrayList<String>();\n      \n   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，\n   // 当然，如果你不定义 name 属性的话，就是空的了\n   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了\n   if (StringUtils.hasLength(nameAttr)) {\n      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n      aliases.addAll(Arrays.asList(nameArr));\n   }\n\n   String beanName = id;\n   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName\n   if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n      beanName = aliases.remove(0);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"No XML \'id\' specified - using \'\" + beanName +\n               \"\' as bean name and \" + aliases + \" as aliases\");\n      }\n   }\n\n   if (containingBean == null) {\n      checkNameUniqueness(beanName, aliases, ele);\n   }\n  \n   // 根据 <bean ...>...</bean> 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,\n   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。\n   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n   \n   // 到这里，整个 <bean /> 标签就算解析结束了，一个 BeanDefinition 就形成了。\n   if (beanDefinition != null) {\n      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生\n      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要\n      if (!StringUtils.hasText(beanName)) {\n         try {\n            if (containingBean != null) {// 按照我们的思路，这里 containingBean 是 null 的\n               beanName = BeanDefinitionReaderUtils.generateBeanName(\n                     beanDefinition, this.readerContext.getRegistry(), true);\n            }\n            else {\n               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：\n               //   1. beanName 为：com.javadoop.example.MessageServiceImpl#0\n               //   2. beanClassName 为：com.javadoop.example.MessageServiceImpl\n              \n               beanName = this.readerContext.generateBeanName(beanDefinition);\n               \n               String beanClassName = beanDefinition.getBeanClassName();\n               if (beanClassName != null &&\n                     beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&\n                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n                  // 把 beanClassName 设置为 Bean 的别名\n                  aliases.add(beanClassName);\n               }\n            }\n            if (logger.isDebugEnabled()) {\n               logger.debug(\"Neither XML \'id\' nor \'name\' specified - \" +\n                     \"using generated bean name [\" + beanName + \"]\");\n            }\n         }\n         catch (Exception ex) {\n            error(ex.getMessage(), ele);\n            return null;\n         }\n      }\n      String[] aliasesArray = StringUtils.toStringArray(aliases);\n      // 返回 BeanDefinitionHolder\n      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n   }\n\n   return null;\n}\n```\n\n然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：\n\n```java\npublic AbstractBeanDefinition parseBeanDefinitionElement(\n      Element ele, String beanName, BeanDefinition containingBean) {\n\n   this.parseState.push(new BeanEntry(beanName));\n\n   String className = null;\n   if (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n   }\n\n   try {\n      String parent = null;\n      if (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n         parent = ele.getAttribute(PARENT_ATTRIBUTE);\n      }\n      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了\n      AbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中\n      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n    \n      /**\n       * 下面的一堆是解析 <bean>......</bean> 内部的子元素，\n       * 解析出来以后的信息都放到 bd 的属性中\n       */\n     \n      // 解析 <meta />\n      parseMetaElements(ele, bd);\n      // 解析 <lookup-method />\n      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n      // 解析 <replaced-method />\n      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n    // 解析 <constructor-arg />\n      parseConstructorArgElements(ele, bd);\n      // 解析 <property />\n      parsePropertyElements(ele, bd);\n      // 解析 <qualifier />\n      parseQualifierElements(ele, bd);\n\n      bd.setResource(this.readerContext.getResource());\n      bd.setSource(extractSource(ele));\n\n      return bd;\n   }\n   catch (ClassNotFoundException ex) {\n      error(\"Bean class [\" + className + \"] not found\", ele, ex);\n   }\n   catch (NoClassDefFoundError err) {\n      error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n   }\n   catch (Throwable ex) {\n      error(\"Unexpected failure during bean definition parsing\", ele, ex);\n   }\n   finally {\n      this.parseState.pop();\n   }\n\n   return null;\n}\n```\n\n到这里，我们已经完成了根据 `<bean />` 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。\n\n我们回到解析 `<bean />` 的入口方法:\n\n```java\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 <bean /> 节点转换为 BeanDefinitionHolder，就是上面说的一堆\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n   if (bdHolder != null) {\n      // 如果有自定义属性的话，进行相应的解析，先忽略\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // 我们把这步叫做 注册Bean 吧\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(\"Failed to register bean definition with name \'\" +\n               bdHolder.getBeanName() + \"\'\", ele, ex);\n      }\n      // 注册完成后，发送事件，本文不展开说这个\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}\n```\n\n大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 `<bean />` 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：\n\n```java\npublic class BeanDefinitionHolder implements BeanMetadataElement {\n\n  private final BeanDefinition beanDefinition;\n\n  private final String beanName;\n\n  private final String[] aliases;\n...\n```\n\n然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。\n\n下面，我们开始说说注册 Bean 吧。\n\n##### 注册 Bean\n\n// BeanDefinitionReaderUtils 143\n\n```java\npublic static void registerBeanDefinition(\n      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n      throws BeanDefinitionStoreException {\n\n   String beanName = definitionHolder.getBeanName();\n   // 注册这个 Bean\n   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n\n   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了\n   String[] aliases = definitionHolder.getAliases();\n   if (aliases != null) {\n      for (String alias : aliases) {\n         // alias -> beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，\n         // 获取的时候，会先将 alias 转换为 beanName，然后再查找\n         registry.registerAlias(beanName, alias);\n      }\n   }\n}\n```\n\n别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。\n\n// DefaultListableBeanFactory 793\n\n```java\n@Override\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n      throws BeanDefinitionStoreException {\n\n   Assert.hasText(beanName, \"Bean name must not be empty\");\n   Assert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n   if (beanDefinition instanceof AbstractBeanDefinition) {\n      try {\n         ((AbstractBeanDefinition) beanDefinition).validate();\n      }\n      catch (BeanDefinitionValidationException ex) {\n         throw new BeanDefinitionStoreException(...);\n      }\n   }\n\n   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding\n   BeanDefinition oldBeanDefinition;\n  \n   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中\n   oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n  \n   // 处理重复名称的 Bean 定义的情况\n   if (oldBeanDefinition != null) {\n      if (!isAllowBeanDefinitionOverriding()) {\n         // 如果不允许覆盖的话，抛异常\n         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...\n      }\n      else if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {\n         // log...用框架定义的 Bean 覆盖用户自定义的 Bean \n      }\n      else if (!beanDefinition.equals(oldBeanDefinition)) {\n         // log...用新的 Bean 覆盖旧的 Bean\n      }\n      else {\n         // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean\n      }\n      // 覆盖\n      this.beanDefinitionMap.put(beanName, beanDefinition);\n   }\n   else {\n      // 判断是否已经有其他的 Bean 开始初始化了.\n      // 注意，\"注册Bean\" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，\n      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans\n      if (hasBeanCreationStarted()) {\n         // Cannot modify startup-time collection elements anymore (for stable iteration)\n         synchronized (this.beanDefinitionMap) {\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n            List<String> updatedDefinitions = new ArrayList<String>(this.beanDefinitionNames.size() + 1);\n            updatedDefinitions.addAll(this.beanDefinitionNames);\n            updatedDefinitions.add(beanName);\n            this.beanDefinitionNames = updatedDefinitions;\n            if (this.manualSingletonNames.contains(beanName)) {\n               Set<String> updatedSingletons = new LinkedHashSet<String>(this.manualSingletonNames);\n               updatedSingletons.remove(beanName);\n               this.manualSingletonNames = updatedSingletons;\n            }\n         }\n      }\n      else {\n         // 最正常的应该是进到这个分支。\n        \n         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition\n         this.beanDefinitionMap.put(beanName, beanDefinition);\n         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字\n         this.beanDefinitionNames.add(beanName);\n         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，\n         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的\n         // 手动指的是通过调用以下方法注册的 bean ：\n         //     registerSingleton(String beanName, Object singletonObject)\n         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面\"手动\"注册一些 Bean，\n         // 如 \"environment\"、\"systemProperties\" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的\n         this.manualSingletonNames.remove(beanName);\n      }\n      // 这个不重要，在预初始化的时候会用到，不必管它。\n      this.frozenBeanDefinitionNames = null;\n   }\n\n   if (oldBeanDefinition != null || containsSingleton(beanName)) {\n      resetBeanDefinition(beanName);\n   }\n}\n```\n\n总结一下，到这里已经初始化了 Bean 容器，`<bean />` 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。\n\n--------- 分割线 ---------\n\n到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。\n\n### Bean 容器实例化完成后\n\n说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。\n\n考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n     \n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n        \n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法\n         invokeBeanFactoryPostProcessors(beanFactory);          \n         \n          \n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成，不展开\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset \'active\' flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring\'s core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n### 准备 Bean 容器: prepareBeanFactory\n\n之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会\"手动\"注册一些特殊的 bean。\n\n这里简单介绍下 prepareBeanFactory(factory) 方法：\n\n```java\n/**\n * Configure the factory\'s standard context characteristics,\n * such as the context\'s ClassLoader and post-processors.\n * @param beanFactory the BeanFactory to configure\n */\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，\n   // 这里设置为加载当前 ApplicationContext 类的类加载器\n   beanFactory.setBeanClassLoader(getClassLoader());\n    \n   // 设置 BeanExpressionResolver\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n   // \n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // 添加一个 BeanPostProcessor，这个 processor 比较简单：\n   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，\n   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware\n   // 注意：它不仅仅回调 ApplicationContextAware，\n   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n  \n   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，\n   // Spring 会通过其他方式来处理这些依赖。\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   /**\n    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，\n    * 之前我们说过，\"当前 ApplicationContext 持有一个 BeanFactory\"，这里解释了第一行。\n    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource\n    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext\n    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean\n    */\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，\n   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器\n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它\n   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，\n   //    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj\n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   /**\n    * 从下面几行代码我们可以知道，Spring 往往很 \"智能\" 就是因为它会帮我们默认注册一些有用的 bean，\n    * 我们也可以选择覆盖\n    */\n  \n   // 如果没有定义 \"environment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n   // 如果没有定义 \"systemProperties\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n   // 如果没有定义 \"systemEnvironment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}\n```\n\n在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。\n\n### 初始化所有的 singleton beans\n\n我们的重点当然是 `finishBeanFactoryInitialization(beanFactory);` 这个巨头了，这里会负责初始化所有的 singleton beans。\n\n注意，后面的描述中，我都会使用**初始化**或**预初始化**来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。\n\n我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 `environment`、`systemProperties` 等。\n\n剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。\n\n// AbstractApplicationContext.java 834\n\n```java\n// 初始化剩余的 singleton beans\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n\n   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了\n   // 什么，看代码这里没有初始化 Bean 啊！\n   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧\n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n\n   // Register a default embedded value resolver if no bean post-processor\n   // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n   // at this point, primarily for resolution in annotation attribute values.\n   if (!beanFactory.hasEmbeddedValueResolver()) {\n      beanFactory.addEmbeddedValueResolver(new StringValueResolver() {\n         @Override\n         public String resolveStringValue(String strVal) {\n            return getEnvironment().resolvePlaceholders(strVal);\n         }\n      });\n   }\n\n   // 先初始化 LoadTimeWeaverAware 类型的 Bean\n   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧\n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n   for (String weaverAwareName : weaverAwareNames) {\n      getBean(weaverAwareName);\n   }\n\n   // Stop using the temporary ClassLoader for type matching.\n   beanFactory.setTempClassLoader(null);\n\n   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，\n   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。\n   beanFactory.freezeConfiguration();\n\n   // 开始初始化\n   beanFactory.preInstantiateSingletons();\n}\n```\n\n从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。\n\n#### preInstantiateSingletons\n\n// DefaultListableBeanFactory 728\n\n```java\n@Override\npublic void preInstantiateSingletons() throws BeansException {\n   if (this.logger.isDebugEnabled()) {\n      this.logger.debug(\"Pre-instantiating singletons in \" + this);\n   }\n   // this.beanDefinitionNames 保存了所有的 beanNames\n   List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);\n\n   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作\n   for (String beanName : beanNames) {\n     \n      // 合并父 Bean 中的配置，注意 <bean id=\"\" class=\"\" parent=\"\" /> 中的 parent，用的不多吧，\n      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 \"Bean 继承\"，不了解的请到附录中看一下\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n     \n      // 非抽象、非懒加载的 singletons。如果配置了 \'abstract = true\'，那是不需要初始化的\n      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)\n         if (isFactoryBean(beanName)) {\n            // FactoryBean 的话，在 beanName 前面加上 ‘&’ 符号。再调用 getBean，getBean 方法别急\n            final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);\n            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过\n            boolean isEagerInit;\n            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n               isEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n                  @Override\n                  public Boolean run() {\n                     return ((SmartFactoryBean<?>) factory).isEagerInit();\n                  }\n               }, getAccessControlContext());\n            }\n            else {\n               isEagerInit = (factory instanceof SmartFactoryBean &&\n                     ((SmartFactoryBean<?>) factory).isEagerInit());\n            }\n            if (isEagerInit) {\n               \n               getBean(beanName);\n            }\n         }\n         else {\n            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了\n            getBean(beanName);\n         }\n      }\n   }\n\n   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化\n   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略\n   for (String beanName : beanNames) {\n      Object singletonInstance = getSingleton(beanName);\n      if (singletonInstance instanceof SmartInitializingSingleton) {\n         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n         if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged(new PrivilegedAction<Object>() {\n               @Override\n               public Object run() {\n                  smartSingleton.afterSingletonsInstantiated();\n                  return null;\n               }\n            }, getAccessControlContext());\n         }\n         else {\n            smartSingleton.afterSingletonsInstantiated();\n         }\n      }\n   }\n}\n```\n\n接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。\n\n#### getBean\n\n在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。\n\n// AbstractBeanFactory 196\n\n```java\n@Override\npublic Object getBean(String name) throws BeansException {\n   return doGetBean(name, null, null, false);\n}\n\n// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，\n// 已经初始化过了就从容器中直接返回，否则就先初始化再返回\n@SuppressWarnings(\"unchecked\")\nprotected <T> T doGetBean(\n      final String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly)\n      throws BeansException {\n   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&’)，\n   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的\n   final String beanName = transformedBeanName(name);\n  \n   // 注意跟着这个，这个是返回值\n   Object bean; \n\n   // 检查下是不是已经创建过了\n   Object sharedInstance = getSingleton(beanName);\n  \n   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，\n   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean\n   if (sharedInstance != null && args == null) {\n      if (logger.isDebugEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.debug(\"...\");\n         }\n         else {\n            logger.debug(\"Returning cached instance of singleton bean \'\" + beanName + \"\'\");\n         }\n      }\n      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，\n      // 如果是 FactoryBean 的话，返回它创建的那个实例对象\n      // (FactoryBean 知识，读者若不清楚请移步附录)\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   }\n\n   else {\n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，\n         // 往往是因为陷入了循环引用\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // 检查一下这个 BeanDefinition 在容器中是否存在\n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有\n         String nameToLookup = originalBeanName(name);\n         if (args != null) {\n            // 返回父容器的查询结果\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         }\n         else {\n            // No args -> delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         }\n      }\n\n      if (!typeCheckOnly) {\n         // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。\n         markBeanAsCreated(beanName);\n      }\n\n      /*\n       * 稍稍总结一下：\n       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；\n       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。\n       */\n      try {\n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n         checkMergedBeanDefinition(mbd, beanName, args);\n\n         // 先初始化依赖的所有 Bean，这个很好理解。\n         // 注意，这里的依赖指的是 depends-on 中定义的依赖\n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Circular depends-on relationship between \'\" + beanName + \"\' and \'\" + dep + \"\'\");\n               }\n               // 注册一下依赖关系\n               registerDependentBean(dep, beanName);\n               // 先初始化被依赖项\n               getBean(dep);\n            }\n         }\n\n         // 如果是 singleton scope 的，创建 singleton 的实例\n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {\n               @Override\n               public Object getObject() throws BeansException {\n                  try {\n                     // 执行创建 Bean，详情后面再说\n                     return createBean(beanName, mbd, args);\n                  }\n                  catch (BeansException ex) {\n                     destroySingleton(beanName);\n                     throw ex;\n                  }\n               }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         }\n\n         // 如果是 prototype scope 的，创建 prototype 的实例\n         else if (mbd.isPrototype()) {\n            // It\'s a prototype -> create a new instance.\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               // 执行创建 Bean\n               prototypeInstance = createBean(beanName, mbd, args);\n            }\n            finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         }\n\n         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理\n         else {\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(\"No Scope registered for scope name \'\" + scopeName + \"\'\");\n            }\n            try {\n               Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n                  @Override\n                  public Object getObject() throws BeansException {\n                     beforePrototypeCreation(beanName);\n                     try {\n                        // 执行创建 Bean\n                        return createBean(beanName, mbd, args);\n                     }\n                     finally {\n                        afterPrototypeCreation(beanName);\n                     }\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            }\n            catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     \"Scope \'\" + scopeName + \"\' is not active for the current thread; consider \" +\n                     \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n                     ex);\n            }\n         }\n      }\n      catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n\n   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了\n   if (requiredType != null && bean != null && !requiredType.isInstance(bean)) {\n      try {\n         return getTypeConverter().convertIfNecessary(bean, requiredType);\n      }\n      catch (TypeMismatchException ex) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Failed to convert bean \'\" + name + \"\' to required type \'\" +\n                  ClassUtils.getQualifiedName(requiredType) + \"\'\", ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n      }\n   }\n   return (T) bean;\n}\n```\n\n大家应该也猜到了，接下来当然是分析 createBean 方法：\n\n```java\nprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;\n```\n\n第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。\n\n这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。\n\n主要是为了以下场景，采用 @Autowired 注解注入属性值：\n\n```java\npublic class MessageServiceImpl implements MessageService {\n    @Autowired\n    private UserService userService;\n  \n    public String getMessage() {\n        return userService.getMessage();\n    }\n}\n```\n\n```xml\n<bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\" />\n```\n\n以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。\n\n好了，读者要知道这么回事就可以了，继续向前。\n\n// AbstractAutowireCapableBeanFactory 447\n\n```java\n/**\n * Central method of this class: creates a bean instance,\n * populates the bean instance, applies post-processors, etc.\n * @see #doCreateBean\n */\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating instance of bean \'\" + beanName + \"\'\");\n   }\n   RootBeanDefinition mbdToUse = mbd;\n\n   // 确保 BeanDefinition 中的 Class 被加载\n   Class<?> resolvedClass = resolveBeanClass(mbd, beanName);\n   if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n      mbdToUse = new RootBeanDefinition(mbd);\n      mbdToUse.setBeanClass(resolvedClass);\n   }\n\n   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 <lookup-method /> \n   // 和 <replaced-method />，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。\n   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看\n   try {\n      mbdToUse.prepareMethodOverrides();\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n            beanName, \"Validation of method overrides failed\", ex);\n   }\n\n   try {\n      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，\n      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过\n      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n      if (bean != null) {\n         return bean; \n      }\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n            \"BeanPostProcessor before instantiation of bean failed\", ex);\n   }\n   // 重头戏，创建 bean\n   Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Finished creating instance of bean \'\" + beanName + \"\'\");\n   }\n   return beanInstance;\n}\n```\n\n#### 创建 Bean\n\n我们继续往里看 doCreateBean 这个方法：\n\n```java\n/**\n * Actually create the specified bean. Pre-creation processing has already happened\n * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n * <p>Differentiates between default bean instantiation, use of a\n * factory method, and autowiring a constructor.\n * @param beanName the name of the bean\n * @param mbd the merged bean definition for the bean\n * @param args explicit arguments to use for constructor or factory method invocation\n * @return a new instance of the bean\n * @throws BeanCreationException if the bean could not be created\n * @see #instantiateBean\n * @see #instantiateUsingFactoryMethod\n * @see #autowireConstructor\n */\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)\n      throws BeanCreationException {\n\n   // Instantiate the bean.\n   BeanWrapper instanceWrapper = null;\n   if (mbd.isSingleton()) {\n      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n   }\n   if (instanceWrapper == null) {\n      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说\n      instanceWrapper = createBeanInstance(beanName, mbd, args);\n   }\n   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 \"bean 实例\"\n   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);\n   // 类型\n   Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);\n   mbd.resolvedTargetType = beanType;\n\n   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor\n   synchronized (mbd.postProcessingLock) {\n      if (!mbd.postProcessed) {\n         try {\n            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的\n            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n         }\n         catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                  \"Post-processing of merged bean definition failed\", ex);\n         }\n         mbd.postProcessed = true;\n      }\n   }\n\n   // Eagerly cache singletons to be able to resolve circular references\n   // even when triggered by lifecycle interfaces like BeanFactoryAware.\n   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧\n   boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n         isSingletonCurrentlyInCreation(beanName));\n   if (earlySingletonExposure) {\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Eagerly caching bean \'\" + beanName +\n               \"\' to allow for resolving potential circular references\");\n      }\n      addSingletonFactory(beanName, new ObjectFactory<Object>() {\n         @Override\n         public Object getObject() throws BeansException {\n            return getEarlyBeanReference(beanName, mbd, bean);\n         }\n      });\n   }\n\n   // Initialize the bean instance.\n   Object exposedObject = bean;\n   try {\n      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值\n      populateBean(beanName, mbd, instanceWrapper);\n      if (exposedObject != null) {\n         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？\n         // 这里就是处理 bean 初始化完成后的各种回调\n         exposedObject = initializeBean(beanName, exposedObject, mbd);\n      }\n   }\n   catch (Throwable ex) {\n      if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n         throw (BeanCreationException) ex;\n      }\n      else {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n      }\n   }\n\n   if (earlySingletonExposure) {\n      // \n      Object earlySingletonReference = getSingleton(beanName, false);\n      if (earlySingletonReference != null) {\n         if (exposedObject == bean) {\n            exposedObject = earlySingletonReference;\n         }\n         else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n            String[] dependentBeans = getDependentBeans(beanName);\n            Set<String> actualDependentBeans = new LinkedHashSet<String>(dependentBeans.length);\n            for (String dependentBean : dependentBeans) {\n               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                  actualDependentBeans.add(dependentBean);\n               }\n            }\n            if (!actualDependentBeans.isEmpty()) {\n               throw new BeanCurrentlyInCreationException(beanName,\n                     \"Bean with name \'\" + beanName + \"\' has been injected into other beans [\" +\n                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                     \"] in its raw version as part of a circular reference, but has eventually been \" +\n                     \"wrapped. This means that said other beans do not use the final version of the \" +\n                     \"bean. This is often the result of over-eager type matching - consider using \" +\n                     \"\'getBeanNamesOfType\' with the \'allowEagerInit\' flag turned off, for example.\");\n            }\n         }\n      }\n   }\n\n   // Register bean as disposable.\n   try {\n      registerDisposableBeanIfNecessary(beanName, bean, mbd);\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n   }\n\n   return exposedObject;\n}\n```\n\n到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。\n\n接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 \n\n注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。\n\n##### 创建 Bean 实例\n\n我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。\n\n```java\nprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {\n   // 确保已经加载了此 class\n   Class<?> beanClass = resolveBeanClass(mbd, beanName);\n\n   // 校验一下这个类的访问权限\n   if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {\n      throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n            \"Bean class isn\'t public, and non-public access not allowed: \" + beanClass.getName());\n   }\n\n   if (mbd.getFactoryMethodName() != null)  {\n      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean\n      return instantiateUsingFactoryMethod(beanName, mbd, args);\n   }\n\n   // 如果不是第一次创建，比如第二次创建 prototype bean。\n   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化\n   boolean resolved = false;\n   boolean autowireNecessary = false;\n   if (args == null) {\n      synchronized (mbd.constructorArgumentLock) {\n         if (mbd.resolvedConstructorOrFactoryMethod != null) {\n            resolved = true;\n            autowireNecessary = mbd.constructorArgumentsResolved;\n         }\n      }\n   }\n   if (resolved) {\n      if (autowireNecessary) {\n         // 构造函数依赖注入\n         return autowireConstructor(beanName, mbd, null, null);\n      }\n      else {\n         // 无参构造函数\n         return instantiateBean(beanName, mbd);\n      }\n   }\n\n   // 判断是否采用有参构造函数\n   Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n   if (ctors != null ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n      // 构造函数依赖注入\n      return autowireConstructor(beanName, mbd, ctors, args);\n   }\n\n   // 调用无参构造函数\n   return instantiateBean(beanName, mbd);\n}\n```\n\n挑个简单的**无参构造函数**构造实例来看看：\n\n```java\nprotected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n   try {\n      Object beanInstance;\n      final BeanFactory parent = this;\n      if (System.getSecurityManager() != null) {\n         beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n               \n               return getInstantiationStrategy().instantiate(mbd, beanName, parent);\n            }\n         }, getAccessControlContext());\n      }\n      else {\n         // 实例化\n         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);\n      }\n      // 包装一下，返回\n      BeanWrapper bw = new BeanWrapperImpl(beanInstance);\n      initBeanWrapper(bw);\n      return bw;\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n   }\n}\n```\n\n我们可以看到，关键的地方在于：\n\n```java\nbeanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);\n```\n\n这里会进行实际的实例化过程，我们进去看看:\n\n// SimpleInstantiationStrategy 59\n\n```java\n@Override\npublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {\n\n   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,\n   // 方法覆写 请参见附录\"方法注入\"中对 lookup-method 和 replaced-method 的介绍\n   if (bd.getMethodOverrides().isEmpty()) {\n      Constructor<?> constructorToUse;\n      synchronized (bd.constructorArgumentLock) {\n         constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;\n         if (constructorToUse == null) {\n            final Class<?> clazz = bd.getBeanClass();\n            if (clazz.isInterface()) {\n               throw new BeanInstantiationException(clazz, \"Specified class is an interface\");\n            }\n            try {\n               if (System.getSecurityManager() != null) {\n                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction<Constructor<?>>() {\n                     @Override\n                     public Constructor<?> run() throws Exception {\n                        return clazz.getDeclaredConstructor((Class[]) null);\n                     }\n                  });\n               }\n               else {\n                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);\n               }\n               bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n            }\n            catch (Throwable ex) {\n               throw new BeanInstantiationException(clazz, \"No default constructor found\", ex);\n            }\n         }\n      }\n      // 利用构造方法进行实例化\n      return BeanUtils.instantiateClass(constructorToUse);\n   }\n   else {\n      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。\n      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持\n      return instantiateWithMethodInjection(bd, beanName, owner);\n   }\n}\n```\n\n到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。\n\n##### bean 属性注入\n\n看完了 createBeanInstance(...) 方法，我们来看看 populateBean(...) 方法，该方法负责进行属性设值，处理依赖。\n\n// AbstractAutowireCapableBeanFactory 1203\n\n```java\nprotected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {\n   // bean 实例的所有属性都在这里了\n   PropertyValues pvs = mbd.getPropertyValues();\n\n   if (bw == null) {\n      if (!pvs.isEmpty()) {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n      }\n      else {\n         // Skip property population phase for null instance.\n         return;\n      }\n   }\n\n   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，\n   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，\n   // 我也没找到有实际的使用，所以我们暂且忽略这块吧\n   boolean continueWithPropertyPopulation = true;\n   if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n      for (BeanPostProcessor bp : getBeanPostProcessors()) {\n         if (bp instanceof InstantiationAwareBeanPostProcessor) {\n            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n            // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理\n            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n               continueWithPropertyPopulation = false;\n               break;\n            }\n         }\n      }\n   }\n\n   if (!continueWithPropertyPopulation) {\n      return;\n   }\n\n   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n         autowireByName(beanName, mbd, bw, newPvs);\n      }\n\n      // 通过类型装配。复杂一些\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n         autowireByType(beanName, mbd, bw, newPvs);\n      }\n\n      pvs = newPvs;\n   }\n\n   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n   if (hasInstAwareBpps || needsDepCheck) {\n      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n      if (hasInstAwareBpps) {\n         for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor\n               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究\n               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n               if (pvs == null) {\n                  return;\n               }\n            }\n         }\n      }\n      if (needsDepCheck) {\n         checkDependencies(beanName, mbd, filteredPds, pvs);\n      }\n   }\n   // 设置 bean 实例的属性值\n   applyPropertyValues(beanName, mbd, bw, pvs);\n}\n```\n\n##### initializeBean\n\n属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。\n\n```java\nprotected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n   if (System.getSecurityManager() != null) {\n      AccessController.doPrivileged(new PrivilegedAction<Object>() {\n         @Override\n         public Object run() {\n            invokeAwareMethods(beanName, bean);\n            return null;\n         }\n      }, getAccessControlContext());\n   }\n   else {\n      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调\n      invokeAwareMethods(beanName, bean);\n   }\n\n   Object wrappedBean = bean;\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessBeforeInitialization 回调\n      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n   }\n\n   try {\n      // 处理 bean 中定义的 init-method，\n      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法\n      invokeInitMethods(beanName, wrappedBean, mbd);\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            (mbd != null ? mbd.getResourceDescription() : null),\n            beanName, \"Invocation of init method failed\", ex);\n   }\n\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessAfterInitialization 回调\n      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n   }\n   return wrappedBean;\n}\n```\n\n大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？\n\n## 附录\n\n### id 和 name\n\n每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。\n\n我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。\n\n```java\nbeanFactory.getBean(\"beanName or alias\");\n```\n\n在配置 `<bean />` 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。\n\n```xml\n<bean id=\"messageService\" name=\"m1, m2, m3\" class=\"com.javadoop.example.MessageServiceImpl\">\n```\n\n以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。\n\n```xml\n<bean name=\"m1, m2, m3\" class=\"com.javadoop.example.MessageServiceImpl\" />\n```\n\n以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。\n\n```xml\n<bean class=\"com.javadoop.example.MessageServiceImpl\">\n```\n\nbeanName 为：com.javadoop.example.MessageServiceImpl#0，\n\n别名 1 个，为： com.javadoop.example.MessageServiceImpl\n\n```xml\n<bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\">\n```\n\n以上配置的结果就是：beanName 为 messageService，没有别名。\n\n### 配置是否允许 Bean 覆盖、是否允许循环依赖\n\n我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\n可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。\n\n循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。\n\n它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。\n\n添加这两个属性的作者 Juergen Hoeller 在这个 [jira](https://jira.spring.io/browse/SPR-4374) 的讨论中说明了怎么配置这两个属性。\n\n```java\npublic class NoBeanOverridingContextLoader extends ContextLoader {\n \n  @Override\n  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) {\n    super.customizeContext(servletContext, applicationContext);\n    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;\n    arac.setAllowBeanDefinitionOverriding(false);\n  }\n}\n```\n\n```java\npublic class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener {\n \n  @Override\n  protected ContextLoader createContextLoader() {\n    return new NoBeanOverridingContextLoader();\n  }\n  \n}\n```\n\n```xml\n<listener>\n    <listener-class>com.javadoop.MyContextLoaderListener</listener-class>  \n</listener>\n```\n\n如果以上方式不能满足你的需求，请参考这个链接：[解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题](http://blog.csdn.net/zgmzyr/article/details/39380477)\n\n### profile\n\n我们可以把不同环境的配置分别配置到单独的文件中，举个例子：\n\n```xml\n<beans profile=\"development\"\n    xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n    xsi:schemaLocation=\"...\">\n\n    <jdbc:embedded-database id=\"dataSource\">\n        <jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/>\n        <jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n    </jdbc:embedded-database>\n</beans>\n```\n```xml\n<beans profile=\"production\"\n    xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xsi:schemaLocation=\"...\">\n\n    <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n</beans>\n```\n\n应该不必做过多解释了吧，看每个文件第一行的 profile=\"\"。\n\n当然，我们也可以在一个配置文件中使用：\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xsi:schemaLocation=\"...\">\n\n    <beans profile=\"development\">\n        <jdbc:embedded-database id=\"dataSource\">\n            <jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/>\n            <jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n        </jdbc:embedded-database>\n    </beans>\n\n    <beans profile=\"production\">\n        <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n    </beans>\n</beans>\n```\n\n理解起来也很简单吧。\n\n接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？\n\nSpring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。\n\n最简单的方式莫过于在程序启动的时候指定：\n\n```shell\n-Dspring.profiles.active=\"profile1,profile2\"\n```\n\n> profile 可以激活多个\n\n当然，我们也可以通过代码的形式从 Environment 中设置 profile：\n\n```java\nAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles(\"development\");\nctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\nctx.refresh(); // 重启\n```\n\n如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：\n\n```shell\njava -Dspring.profiles.active=prod -jar JavaDoop.jar\n```\n\n如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。\n\n### 工厂模式生成 Bean\n\n请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。\n\n设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。\n\n静态工厂：\n\n```xml\n<bean id=\"clientService\"\n    class=\"examples.ClientService\"\n    factory-method=\"createInstance\"/>\n```\n\n```java\npublic class ClientService {\n    private static ClientService clientService = new ClientService();\n    private ClientService() {}\n\n    // 静态方法\n    public static ClientService createInstance() {\n        return clientService;\n    }\n}\n```\n\n实例工厂：\n\n```xml\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n    <!-- inject any dependencies required by this locator bean -->\n</bean>\n\n<bean id=\"clientService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createClientServiceInstance\"/>\n\n<bean id=\"accountService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createAccountServiceInstance\"/>\n```\n\n```java\npublic class DefaultServiceLocator {\n\n    private static ClientService clientService = new ClientServiceImpl();\n\n    private static AccountService accountService = new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() {\n        return clientService;\n    }\n\n    public AccountService createAccountServiceInstance() {\n        return accountService;\n    }\n}\n```\n### FactoryBean\n\nFactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。\n\n```java\npublic interface FactoryBean<T> {\n    T getObject() throws Exception;\n    Class<T> getObjectType();\n    boolean isSingleton();\n}\n```\n\n```java\npublic class Person { \n    private Car car ;\n    private void setCar(Car car){ this.car = car;  }  \n}\n```\n\n我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：\n\n```java\npublic class MyCarFactoryBean implements FactoryBean<Car>{\n    private String make; \n    private int year ;\n    \n    public void setMake(String m){ this.make =m ; }\n    \n    public void setYear(int y){ this.year = y; }\n    \n    public Car getObject(){ \n      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种\n      CarBuilder cb = CarBuilder.car();\n      \n      if(year!=0) cb.setYear(this.year);\n      if(StringUtils.hasText(this.make)) cb.setMake( this.make ); \n      return cb.factory(); \n    }\n    \n    public Class<Car> getObjectType() { return Car.class ; } \n    \n    public boolean isSingleton() { return false; }\n}\n```\n\n我们看看装配的时候是怎么配置的：\n\n```xml\n<bean class = \"com.javadoop.MyCarFactoryBean\" id = \"car\">\n  <property name = \"make\" value =\"Honda\"/>\n  <property name = \"year\" value =\"1984\"/>\n</bean>\n<bean class = \"com.javadoop.Person\" id = \"josh\">\n  <property name = \"car\" ref = \"car\"/>\n</bean>\n```\n\n看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。\n\n说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？\n\n```java\n@Configuration \npublic class CarConfiguration { \n\n    @Bean \n    public MyCarFactoryBean carFactoryBean(){ \n      MyCarFactoryBean cfb = new MyCarFactoryBean();\n      cfb.setMake(\"Honda\");\n      cfb.setYear(1984);\n      return cfb;\n    }\n\n    @Bean\n    public Person aPerson(){ \n    Person person = new Person();\n      // 注意这里的不同\n    person.setCar(carFactoryBean().getObject());\n    return person; \n    } \n}\n```\n\n这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。\n\n### 初始化 Bean 的回调\n\n有以下四种方案：\n\n```xml\n<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/>\n```\n\n```java\npublic class AnotherExampleBean implements InitializingBean {\n\n    public void afterPropertiesSet() {\n        // do some initialization work\n    }\n}\n```\n\n```java\n@Bean(initMethod = \"init\")\npublic Foo foo() {\n    return new Foo();\n}\n```\n\n```java\n@PostConstruct\npublic void init() {\n    \n}\n```\n\n### 销毁 Bean 的回调\n\n```xml\n<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/>\n```\n\n```java\npublic class AnotherExampleBean implements DisposableBean {\n\n    public void destroy() {\n        // do some destruction work (like releasing pooled connections)\n    }\n}\n```\n\n```java\n@Bean(destroyMethod = \"cleanup\")\npublic Bar bar() {\n    return new Bar();\n}\n```\n\n```java\n@PreDestroy\npublic void cleanup() {\n    \n}\n```\n\n### ConversionService\n\n既然文中说到了这个，顺便提一下好了。\n\n最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。\n\n像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。\n\n```xml\n<bean id=\"conversionService\"\n  class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n  <property name=\"converters\">\n    <list>\n      <bean class=\"com.javadoop.learning.utils.StringToEnumConverterFactory\"/>\n    </list>\n  </property>\n</bean>\n```\n\nConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。\n\n下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。\n\n来看一个很简单的例子，这样比什么都管用。\n\n```java\npublic class StringToDateConverter implements Converter<String, Date> {\n\n    @Override\n    public Date convert(String source) {\n        try {\n            return DateUtils.parseDate(source, \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"HH:mm:ss\", \"HH:mm\");\n        } catch (ParseException e) {\n            return null;\n        }\n    }\n}\n```\n\n只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。\n\n### Bean 继承\n\n在初始化 Bean 的地方，我们说过了这个：\n\n```java\nRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n```\n\n这里涉及到的就是 `<bean parent=\"\" />` 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。\n\n首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。\n\nSpring 中提供了继承自 AbstractBeanDefinition 的 `ChildBeanDefinition` 来表示 child bean。\n\n看如下一个例子:\n\n```java\n<bean id=\"inheritedTestBean\" abstract=\"true\" class=\"org.springframework.beans.TestBean\">\n    <property name=\"name\" value=\"parent\"/>\n    <property name=\"age\" value=\"1\"/>\n</bean>\n\n<bean id=\"inheritsWithDifferentClass\" class=\"org.springframework.beans.DerivedTestBean\"\n        parent=\"inheritedTestBean\" init-method=\"initialize\">\n        \n    <property name=\"name\" value=\"override\"/>\n</bean>\n```\n\nparent bean 设置了 `abstract=\"true\"` 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。\n\nchild bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。\n\n当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。\n\n比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。\n\n```java\n<bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\">\n    <property name=\"name\" value=\"parent\"/>\n    <property name=\"age\" value=\"1\"/>\n</bean>\n```\n### 方法注入\n\n一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。\n\n但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。\n\n一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。\n\n另一种解决方案就是这里要介绍的通过使用 Lookup method。\n\n#### lookup-method\n\n我们来看一下 Spring Reference 中提供的一个例子：\n\n```java\npackage fiona.apple;\n\n// no more Spring imports!\n\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        // grab a new instance of the appropriate Command interface\n        Command command = createCommand();\n        // set the state on the (hopefully brand new) Command instance\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    // okay... but where is the implementation of this method?\n    protected abstract Command createCommand();\n}\n```\n\nxml 配置 `<lookup-method />`：\n\n```xml\n<!-- a stateful bean deployed as a prototype (non-singleton) -->\n<bean id=\"myCommand\" class=\"fiona.apple.AsyncCommand\" scope=\"prototype\">\n    <!-- inject dependencies here as required -->\n</bean>\n\n<!-- commandProcessor uses statefulCommandHelper -->\n<bean id=\"commandManager\" class=\"fiona.apple.CommandManager\">\n    <lookup-method name=\"createCommand\" bean=\"myCommand\"/>\n</bean>\n```\n\nSpring 采用 **CGLIB 生成字节码**的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。\n\nlookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 `<lookup-method />` 了，其他不变：\n\n```java\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup(\"myCommand\")\n    protected abstract Command createCommand();\n}\n```\n\n> 注意，既然用了注解，要配置注解扫描：`<context:component-scan base-package=\"com.javadoop\" />`\n\n甚至，我们可以像下面这样：\n\n```java\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup\n    protected abstract MyCommand createCommand();\n}\n```\n\n> 上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。\n\n#### replaced-method\n\n记住它的功能，就是替换掉 bean 中的一些方法。\n\n```java\npublic class MyValueCalculator {\n\n    public String computeValue(String input) {\n        // some real code...\n    }\n\n    // some other methods...\n}\n```\n\n方法覆写，注意要实现 MethodReplacer 接口：\n\n```java\npublic class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer {\n\n    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {\n        // get the input value, work with it, and return a computed result\n        String input = (String) args[0];\n        ...\n        return ...;\n    }\n}\n```\n\n配置也很简单：\n\n```xml\n<bean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\">\n    <!-- 定义 computeValue 这个方法要被替换掉 -->\n    <replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\">\n        <arg-type>String</arg-type>\n    </replaced-method>\n</bean>\n\n<bean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/>\n```\n\n> arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。\n\n### BeanPostProcessor\n\n应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：\n\n```java\npublic interface BeanPostProcessor {\n\n   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\n   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n\n}\n```\n\n看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。\n\n首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。\n\n我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。\n\n那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。\n\n最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？\n\n如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。\n\n首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。\n\n## 总结\n\n按理说，总结应该写在附录前面，我就不讲究了。\n\n在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。\n\n本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。\n\n（全文完）\n','<p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。</p>\n<p>本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。</p>\n<p>阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。</p>\n<p>希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。</p>\n<h2 id=\"引言\">引言</h2>\n<p>先看下最基本的启动 Spring 容器的例子：</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationfile.xml&quot;);\n}</code></pre>\n<p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n  &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<blockquote>\n<p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>\n</blockquote>\n<p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。</p>\n<p>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code> 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200520/967eae0f814441f6ae52d3b8d1e6116d.png\" alt=\"image.png\"></p>\n<blockquote>\n<p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。</p>\n<p>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p>\n</blockquote>\n<p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 <strong>FileSystemXmlApplicationContext</strong> 和 <strong>AnnotationConfigApplicationContext</strong> 这两个类。</p>\n<p><strong>1、FileSystemXmlApplicationContext</strong> 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p>\n<p><strong>2、AnnotationConfigApplicationContext</strong> 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p>\n<p>不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p>\n<p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p>\n<p>首先，定义一个接口：</p>\n<pre><code class=\"language-java\">public interface MessageService {\n    String getMessage();\n}</code></pre>\n<p>定义接口实现类：</p>\n<pre><code class=\"language-java\">public class MessageServiceImpl implements MessageService {\n\n    public String getMessage() {\n        return &quot;hello world&quot;;\n    }\n}</code></pre>\n<p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; default-autowire=&quot;byName&quot;&gt;\n\n    &lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;/&gt;\n&lt;/beans&gt;</code></pre>\n<p>这样，我们就可以跑起来了：</p>\n<pre><code class=\"language-java\">public class App {\n    public static void main(String[] args) {\n        // 用我们的配置文件来启动一个 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);\n\n        System.out.println(&quot;context 启动成功&quot;);\n\n        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式\n        MessageService messageService = context.getBean(MessageService.class);\n        // 这句将输出: hello world\n        System.out.println(messageService.getMessage());\n    }\n}</code></pre>\n<p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p>\n<h2 id=\"beanfactory-简介\">BeanFactory 简介</h2>\n<p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p>\n<p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200520/2de3ac3554d84c9eabff1d50eed3e5c8.png\" alt=\"image.png\"></p>\n<p>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p>\n<ol>\n<li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li>\n<li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li>\n<li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li>\n<li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li>\n<li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。</li>\n</ol>\n<p>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</p>\n<h2 id=\"启动过程分析\">启动过程分析</h2>\n<p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p>\n<p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p>\n<pre><code class=\"language-java\">public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {\n  private Resource[] configResources;\n\n  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法\n  public ClassPathXmlApplicationContext(ApplicationContext parent) {\n    super(parent);\n  }\n  ...\n  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)\n      throws BeansException {\n\n    super(parent);\n    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)\n    setConfigLocations(configLocations);\n    if (refresh) {\n      refresh(); // 核心方法\n    }\n  }\n    ...\n}</code></pre>\n<p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p>\n<p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p>\n<pre><code class=\"language-java\">@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n\n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n\n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(&quot;Exception encountered during context initialization - &quot; +\n                  &quot;cancelling refresh attempt: &quot; + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset &#39;active&#39; flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring&#39;s core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}</code></pre>\n<p>下面，我们开始一步步来肢解这个 refresh() 方法。</p>\n<h3 id=\"创建-bean-容器前的准备工作\">创建 Bean 容器前的准备工作</h3>\n<p>这个比较简单，直接看代码中的几个注释即可。</p>\n<pre><code class=\"language-java\">protected void prepareRefresh() {\n   // 记录启动时间，\n   // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型\n   this.startupDate = System.currentTimeMillis();\n   this.closed.set(false);\n   this.active.set(true);\n\n   if (logger.isInfoEnabled()) {\n      logger.info(&quot;Refreshing &quot; + this);\n   }\n\n   // Initialize any placeholder property sources in the context environment\n   initPropertySources();\n\n   // 校验 xml 配置文件\n   getEnvironment().validateRequiredProperties();\n\n   this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();\n}</code></pre>\n<h3 id=\"创建-bean-容器，加载并注册-bean\">创建 Bean 容器，加载并注册 Bean</h3>\n<p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p>\n<p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p>\n<p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p>\n<p>// AbstractApplicationContext.java</p>\n<pre><code class=\"language-java\">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等\n   refreshBeanFactory();\n\n   // 返回刚刚创建的 BeanFactory\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (logger.isDebugEnabled()) {\n      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);\n   }\n   return beanFactory;\n}</code></pre>\n<p>// AbstractRefreshableApplicationContext.java 120</p>\n<pre><code class=\"language-java\">@Override\nprotected final void refreshBeanFactory() throws BeansException {\n   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory\n   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前\n   // ApplicationContext 是否有 BeanFactory\n   if (hasBeanFactory()) {\n      destroyBeans();\n      closeBeanFactory();\n   }\n   try {\n      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。\n      DefaultListableBeanFactory beanFactory = createBeanFactory();\n      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到\n      beanFactory.setSerializationId(getId());\n\n      // 下面这两个方法很重要，别跟丢了，具体细节之后说\n      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用\n      customizeBeanFactory(beanFactory);\n\n      // 加载 Bean 到 BeanFactory 中\n      loadBeanDefinitions(beanFactory);\n      synchronized (this.beanFactoryMonitor) {\n         this.beanFactory = beanFactory;\n      }\n   }\n   catch (IOException ex) {\n      throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);\n   }\n}</code></pre>\n<blockquote>\n<p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>\n</blockquote>\n<p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200520/cbfc0b05edac444098b395de90f5e463.png\" alt=\"image.png\"></p>\n<p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p>\n<blockquote>\n<p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？</p>\n<p>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。</p>\n<p>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。</p>\n</blockquote>\n<p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p>\n<p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p>\n<p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p>\n<blockquote>\n<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>\n</blockquote>\n<h4 id=\"beandefinition-接口定义\">BeanDefinition 接口定义</h4>\n<p>我们来看下 BeanDefinition 的接口定义：</p>\n<pre><code class=\"language-java\">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {\n\n   // 我们可以看到，默认只提供 sington 和 prototype 两种，\n   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，\n   // 不过，它们属于基于 web 的扩展。\n   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;\n   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;\n\n   // 比较不重要，直接跳过吧\n   int ROLE_APPLICATION = 0;\n   int ROLE_SUPPORT = 1;\n   int ROLE_INFRASTRUCTURE = 2;\n\n   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍\n   // 一句话就是：继承父 Bean 的配置信息而已\n   void setParentName(String parentName);\n\n   // 获取父 Bean\n   String getParentName();\n\n   // 设置 Bean 的类名称，将来是要通过反射来生成实例的\n   void setBeanClassName(String beanClassName);\n\n   // 获取 Bean 的类名称\n   String getBeanClassName();\n\n\n   // 设置 bean 的 scope\n   void setScope(String scope);\n\n   String getScope();\n\n   // 设置是否懒加载\n   void setLazyInit(boolean lazyInit);\n\n   boolean isLazyInit();\n\n   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，\n   // 是 depends-on=&quot;&quot; 属性设置的值。\n   void setDependsOn(String... dependsOn);\n\n   // 返回该 Bean 的所有依赖\n   String[] getDependsOn();\n\n   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，\n   // 如果根据名称注入，即使这边设置了 false，也是可以的\n   void setAutowireCandidate(boolean autowireCandidate);\n\n   // 该 Bean 是否可以注入到其他 Bean 中\n   boolean isAutowireCandidate();\n\n   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean\n   void setPrimary(boolean primary);\n\n   // 是否是 primary 的\n   boolean isPrimary();\n\n   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录\n   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的\n   void setFactoryBeanName(String factoryBeanName);\n   // 获取工厂名称\n   String getFactoryBeanName();\n   // 指定工厂类中的 工厂方法名称\n   void setFactoryMethodName(String factoryMethodName);\n   // 获取工厂类中的 工厂方法名称\n   String getFactoryMethodName();\n\n   // 构造器参数\n   ConstructorArgumentValues getConstructorArgumentValues();\n\n   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到\n   MutablePropertyValues getPropertyValues();\n\n   // 是否 singleton\n   boolean isSingleton();\n\n   // 是否 prototype\n   boolean isPrototype();\n\n   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，\n   // 常用于作为 父bean 用于继承，其实也很少用......\n   boolean isAbstract();\n\n   int getRole();\n   String getDescription();\n   String getResourceDescription();\n   BeanDefinition getOriginatingBeanDefinition();\n}</code></pre>\n<blockquote>\n<p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。</p>\n<p>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p>\n</blockquote>\n<p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p>\n<pre><code class=\"language-java\">customizeBeanFactory(beanFactory);\nloadBeanDefinitions(beanFactory);</code></pre>\n<p>虽然只有两个方法，但路还很长啊。。。</p>\n<h4 id=\"customizebeanfactory\">customizeBeanFactory</h4>\n<p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p>\n<pre><code class=\"language-java\">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n   if (this.allowBeanDefinitionOverriding != null) {\n      // 是否允许 Bean 定义覆盖\n      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n   }\n   if (this.allowCircularReferences != null) {\n      // 是否允许 Bean 间的循环依赖\n      beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n   }\n}</code></pre>\n<p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>\n<p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>\n<p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p>\n<p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p>\n<p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p>\n<h4 id=\"加载-bean-loadbeandefinitions\">加载 Bean: loadBeanDefinitions</h4>\n<p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p>\n<p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p>\n<p>// AbstractXmlApplicationContext.java 80</p>\n<pre><code class=\"language-java\">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/\n@Override\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader\n   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\n   // Configure the bean definition reader with this context&#39;s\n   // resource loading environment.\n   beanDefinitionReader.setEnvironment(this.getEnvironment());\n   beanDefinitionReader.setResourceLoader(this);\n   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，\n   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧\n   initBeanDefinitionReader(beanDefinitionReader);\n   // 重点来了，继续往下\n   loadBeanDefinitions(beanDefinitionReader);\n}</code></pre>\n<p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p>\n<p>// AbstractXmlApplicationContext.java 120</p>\n<pre><code class=\"language-java\">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n   Resource[] configResources = getConfigResources();\n   if (configResources != null) {\n      // 往下看\n      reader.loadBeanDefinitions(configResources);\n   }\n   String[] configLocations = getConfigLocations();\n   if (configLocations != null) {\n      // 2\n      reader.loadBeanDefinitions(configLocations);\n   }\n}\n\n// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里\n@Override\npublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {\n   Assert.notNull(resources, &quot;Resource array must not be null&quot;);\n   int counter = 0;\n   // 注意这里是个 for 循环，也就是每个文件是一个 resource\n   for (Resource resource : resources) {\n      // 继续往下看\n      counter += loadBeanDefinitions(resource);\n   }\n   // 最后返回 counter，表示总共加载了多少的 BeanDefinition\n   return counter;\n}\n\n// XmlBeanDefinitionReader 303\n@Override\npublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n   return loadBeanDefinitions(new EncodedResource(resource));\n}\n\n// XmlBeanDefinitionReader 314\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n   Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);\n   if (logger.isInfoEnabled()) {\n      logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());\n   }\n   // 用一个 ThreadLocal 来存放配置文件资源\n   Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();\n   if (currentResources == null) {\n      currentResources = new HashSet&lt;EncodedResource&gt;(4);\n      this.resourcesCurrentlyBeingLoaded.set(currentResources);\n   }\n   if (!currentResources.add(encodedResource)) {\n      throw new BeanDefinitionStoreException(\n            &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);\n   }\n   try {\n      InputStream inputStream = encodedResource.getResource().getInputStream();\n      try {\n         InputSource inputSource = new InputSource(inputStream);\n         if (encodedResource.getEncoding() != null) {\n            inputSource.setEncoding(encodedResource.getEncoding());\n         }\n         // 核心部分是这里，往下面看\n         return doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n      }\n      finally {\n         inputStream.close();\n      }\n   }\n   catch (IOException ex) {\n      throw new BeanDefinitionStoreException(\n            &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);\n   }\n   finally {\n      currentResources.remove(encodedResource);\n      if (currentResources.isEmpty()) {\n         this.resourcesCurrentlyBeingLoaded.remove();\n      }\n   }\n}\n\n// 还在这个文件中，第 388 行\nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n      throws BeanDefinitionStoreException {\n   try {\n      // 这里就不看了，将 xml 文件转换为 Document 对象\n      Document doc = doLoadDocument(inputSource, resource);\n      // 继续\n      return registerBeanDefinitions(doc, resource);\n   }\n   catch (...\n}\n// 还在这个文件中，第 505 行\n// 返回值：返回从当前配置文件加载了多少数量的 Bean\npublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n   int countBefore = getRegistry().getBeanDefinitionCount();\n   // 这里\n   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n   return getRegistry().getBeanDefinitionCount() - countBefore;\n}\n// DefaultBeanDefinitionDocumentReader 90\n@Override\npublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n   this.readerContext = readerContext;\n   logger.debug(&quot;Loading bean definitions&quot;);\n   Element root = doc.getDocumentElement();\n   // 从 xml 根节点开始解析文件\n   doRegisterBeanDefinitions(root);\n}         </code></pre>\n<p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p>\n<h5 id=\"doregisterbeandefinitions：\">doRegisterBeanDefinitions：</h5>\n<pre><code class=\"language-java\">// DefaultBeanDefinitionDocumentReader 116\nprotected void doRegisterBeanDefinitions(Element root) {\n   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，\n   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，\n   // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了\n   BeanDefinitionParserDelegate parent = this.delegate;\n   this.delegate = createDelegate(getReaderContext(), root, parent);\n\n   if (this.delegate.isDefaultNamespace(root)) {\n      // 这块说的是根节点 &lt;beans ... profile=&quot;dev&quot; /&gt; 中的 profile 是否是当前环境需要的，\n      // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析\n      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区\n      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n      if (StringUtils.hasText(profileSpec)) {\n         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n         if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n            if (logger.isInfoEnabled()) {\n               logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +\n                     &quot;] not matching: &quot; + getReaderContext().getResource());\n            }\n            return;\n         }\n      }\n   }\n\n   preProcessXml(root); // 钩子\n   // 往下看\n   parseBeanDefinitions(root, this.delegate);\n   postProcessXml(root); // 钩子\n\n   this.delegate = parent;\n}</code></pre>\n<p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p>\n<p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p>\n<p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p>\n<pre><code class=\"language-java\">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，\n// 其他的属于 custom 的\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n   if (delegate.isDefaultNamespace(root)) {\n      NodeList nl = root.getChildNodes();\n      for (int i = 0; i &lt; nl.getLength(); i++) {\n         Node node = nl.item(i);\n         if (node instanceof Element) {\n            Element ele = (Element) node;\n            if (delegate.isDefaultNamespace(ele)) {\n               // 解析 default namespace 下面的几个元素\n               parseDefaultElement(ele, delegate);\n            }\n            else {\n               // 解析其他 namespace 的元素\n               delegate.parseCustomElement(ele);\n            }\n         }\n      }\n   }\n   else {\n      delegate.parseCustomElement(root);\n   }\n}</code></pre>\n<p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p>\n<p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;beans /&gt;</code> 这几个。</p>\n<blockquote>\n<p>这里的四个标签之所以是 <strong>default</strong> 的，是因为它们是处于这个 namespace 下定义的：</p>\n<pre><code>http://www.springframework.org/schema/beans</code></pre><p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 <strong>xmlns</strong> 就是咯。</p>\n<pre><code class=\"language-xml\">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xsi:schemaLocation=&quot;\n            http://www.springframework.org/schema/beans\n          http://www.springframework.org/schema/beans/spring-beans.xsd&quot;\n       default-autowire=&quot;byName&quot;&gt;</code></pre>\n<p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code>&lt;mvc /&gt;</code>、<code>&lt;task /&gt;</code>、<code>&lt;context /&gt;</code>、<code>&lt;aop /&gt;</code>等。</p>\n<p>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。</p>\n<p>假如读者想分析 <code>&lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt;</code> 的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p>\n<pre><code class=\"language-xml\">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n      xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n      xsi:schemaLocation=&quot;\n           http://www.springframework.org/schema/beans \n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/context\n           http://www.springframework.org/schema/context/spring-context.xsd\n           http://www.springframework.org/schema/mvc   \n           http://www.springframework.org/schema/mvc/spring-mvc.xsd  \n       &quot;\n      default-autowire=&quot;byName&quot;&gt;</code></pre>\n<p>同理，以后你要是碰到 <code>&lt;dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。</p>\n</blockquote>\n<p>回过神来，看看处理 default 标签的方法：</p>\n<pre><code class=\"language-java\">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n      // 处理 &lt;import /&gt; 标签\n      importBeanDefinitionResource(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n      // 处理 &lt;alias /&gt; 标签定义\n      // &lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;\n      processAliasRegistration(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n      // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧\n      processBeanDefinition(ele, delegate);\n   }\n   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n      // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归\n      doRegisterBeanDefinitions(ele);\n   }\n}</code></pre>\n<p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <code>&lt;bean /&gt;</code> 标签出来说。</p>\n<h5 id=\"processbeandefinition-解析-bean-标签\">processBeanDefinition 解析 bean 标签</h5>\n<p>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p>\n<p>// DefaultBeanDefinitionDocumentReader 298</p>\n<pre><code class=\"language-java\">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\n   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的\n\n   if (bdHolder != null) {\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // Register the final decorated instance.\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +\n               bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n      }\n      // Send registration event.\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}</code></pre>\n<p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>class</td>\n<td>类的全限定名</td>\n</tr>\n<tr>\n<td>name</td>\n<td>可指定 id、name(用逗号、分号、空格分隔)</td>\n</tr>\n<tr>\n<td>scope</td>\n<td>作用域</td>\n</tr>\n<tr>\n<td>constructor arguments</td>\n<td>指定构造参数</td>\n</tr>\n<tr>\n<td>properties</td>\n<td>设置属性的值</td>\n</tr>\n<tr>\n<td>autowiring mode</td>\n<td>no(默认值)、byName、byType、 constructor</td>\n</tr>\n<tr>\n<td>lazy-initialization mode</td>\n<td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td>\n</tr>\n<tr>\n<td>initialization method</td>\n<td>bean 属性设置完成后，会调用这个方法</td>\n</tr>\n<tr>\n<td>destruction method</td>\n<td>bean 销毁后的回调方法</td>\n</tr>\n</tbody></table>\n<p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p>\n<p>简单地说就是像下面这样子：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;exampleBean&quot; name=&quot;name1, name2, name3&quot; class=&quot;com.javadoop.ExampleBean&quot;\n      scope=&quot;singleton&quot; lazy-init=&quot;true&quot; init-method=&quot;init&quot; destroy-method=&quot;cleanup&quot;&gt;\n\n    &lt;!-- 可以用下面三种形式指定构造参数 --&gt;\n    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;\n    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;\n    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;\n\n    &lt;!-- property 的几种情况 --&gt;\n    &lt;property name=&quot;beanOne&quot;&gt;\n        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt;\n    &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;</code>、<code>&lt;replaced-method /&gt;</code>、<code>&lt;meta /&gt;</code>、<code>&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p>\n<p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p>\n<p>// BeanDefinitionParserDelegate 428</p>\n<pre><code class=\"language-java\">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {\n    return parseBeanDefinitionElement(ele, null);\n}\n\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {\n   String id = ele.getAttribute(ID_ATTRIBUTE);\n   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n   List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();\n\n   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，\n   // 当然，如果你不定义 name 属性的话，就是空的了\n   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了\n   if (StringUtils.hasLength(nameAttr)) {\n      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n      aliases.addAll(Arrays.asList(nameArr));\n   }\n\n   String beanName = id;\n   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName\n   if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {\n      beanName = aliases.remove(0);\n      if (logger.isDebugEnabled()) {\n         logger.debug(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +\n               &quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);\n      }\n   }\n\n   if (containingBean == null) {\n      checkNameUniqueness(beanName, aliases, ele);\n   }\n\n   // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,\n   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。\n   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n\n   // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。\n   if (beanDefinition != null) {\n      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生\n      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要\n      if (!StringUtils.hasText(beanName)) {\n         try {\n            if (containingBean != null) {// 按照我们的思路，这里 containingBean 是 null 的\n               beanName = BeanDefinitionReaderUtils.generateBeanName(\n                     beanDefinition, this.readerContext.getRegistry(), true);\n            }\n            else {\n               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：\n               //   1. beanName 为：com.javadoop.example.MessageServiceImpl#0\n               //   2. beanClassName 为：com.javadoop.example.MessageServiceImpl\n\n               beanName = this.readerContext.generateBeanName(beanDefinition);\n\n               String beanClassName = beanDefinition.getBeanClassName();\n               if (beanClassName != null &amp;&amp;\n                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;\n                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n                  // 把 beanClassName 设置为 Bean 的别名\n                  aliases.add(beanClassName);\n               }\n            }\n            if (logger.isDebugEnabled()) {\n               logger.debug(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +\n                     &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);\n            }\n         }\n         catch (Exception ex) {\n            error(ex.getMessage(), ele);\n            return null;\n         }\n      }\n      String[] aliasesArray = StringUtils.toStringArray(aliases);\n      // 返回 BeanDefinitionHolder\n      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n   }\n\n   return null;\n}</code></pre>\n<p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p>\n<pre><code class=\"language-java\">public AbstractBeanDefinition parseBeanDefinitionElement(\n      Element ele, String beanName, BeanDefinition containingBean) {\n\n   this.parseState.push(new BeanEntry(beanName));\n\n   String className = null;\n   if (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n   }\n\n   try {\n      String parent = null;\n      if (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n         parent = ele.getAttribute(PARENT_ATTRIBUTE);\n      }\n      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了\n      AbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中\n      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n      /**\n       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，\n       * 解析出来以后的信息都放到 bd 的属性中\n       */\n\n      // 解析 &lt;meta /&gt;\n      parseMetaElements(ele, bd);\n      // 解析 &lt;lookup-method /&gt;\n      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n      // 解析 &lt;replaced-method /&gt;\n      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n    // 解析 &lt;constructor-arg /&gt;\n      parseConstructorArgElements(ele, bd);\n      // 解析 &lt;property /&gt;\n      parsePropertyElements(ele, bd);\n      // 解析 &lt;qualifier /&gt;\n      parseQualifierElements(ele, bd);\n\n      bd.setResource(this.readerContext.getResource());\n      bd.setSource(extractSource(ele));\n\n      return bd;\n   }\n   catch (ClassNotFoundException ex) {\n      error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);\n   }\n   catch (NoClassDefFoundError err) {\n      error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);\n   }\n   catch (Throwable ex) {\n      error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);\n   }\n   finally {\n      this.parseState.pop();\n   }\n\n   return null;\n}</code></pre>\n<p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p>\n<p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p>\n<pre><code class=\"language-java\">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n   if (bdHolder != null) {\n      // 如果有自定义属性的话，进行相应的解析，先忽略\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // 我们把这步叫做 注册Bean 吧\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +\n               bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n      }\n      // 注册完成后，发送事件，本文不展开说这个\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}</code></pre>\n<p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p>\n<pre><code class=\"language-java\">public class BeanDefinitionHolder implements BeanMetadataElement {\n\n  private final BeanDefinition beanDefinition;\n\n  private final String beanName;\n\n  private final String[] aliases;\n...</code></pre>\n<p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p>\n<p>下面，我们开始说说注册 Bean 吧。</p>\n<h5 id=\"注册-bean\">注册 Bean</h5>\n<p>// BeanDefinitionReaderUtils 143</p>\n<pre><code class=\"language-java\">public static void registerBeanDefinition(\n      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n      throws BeanDefinitionStoreException {\n\n   String beanName = definitionHolder.getBeanName();\n   // 注册这个 Bean\n   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n\n   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了\n   String[] aliases = definitionHolder.getAliases();\n   if (aliases != null) {\n      for (String alias : aliases) {\n         // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，\n         // 获取的时候，会先将 alias 转换为 beanName，然后再查找\n         registry.registerAlias(beanName, alias);\n      }\n   }\n}</code></pre>\n<p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p>\n<p>// DefaultListableBeanFactory 793</p>\n<pre><code class=\"language-java\">@Override\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n      throws BeanDefinitionStoreException {\n\n   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);\n   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);\n\n   if (beanDefinition instanceof AbstractBeanDefinition) {\n      try {\n         ((AbstractBeanDefinition) beanDefinition).validate();\n      }\n      catch (BeanDefinitionValidationException ex) {\n         throw new BeanDefinitionStoreException(...);\n      }\n   }\n\n   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding\n   BeanDefinition oldBeanDefinition;\n\n   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中\n   oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n\n   // 处理重复名称的 Bean 定义的情况\n   if (oldBeanDefinition != null) {\n      if (!isAllowBeanDefinitionOverriding()) {\n         // 如果不允许覆盖的话，抛异常\n         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...\n      }\n      else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) {\n         // log...用框架定义的 Bean 覆盖用户自定义的 Bean \n      }\n      else if (!beanDefinition.equals(oldBeanDefinition)) {\n         // log...用新的 Bean 覆盖旧的 Bean\n      }\n      else {\n         // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean\n      }\n      // 覆盖\n      this.beanDefinitionMap.put(beanName, beanDefinition);\n   }\n   else {\n      // 判断是否已经有其他的 Bean 开始初始化了.\n      // 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，\n      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans\n      if (hasBeanCreationStarted()) {\n         // Cannot modify startup-time collection elements anymore (for stable iteration)\n         synchronized (this.beanDefinitionMap) {\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);\n            updatedDefinitions.addAll(this.beanDefinitionNames);\n            updatedDefinitions.add(beanName);\n            this.beanDefinitionNames = updatedDefinitions;\n            if (this.manualSingletonNames.contains(beanName)) {\n               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);\n               updatedSingletons.remove(beanName);\n               this.manualSingletonNames = updatedSingletons;\n            }\n         }\n      }\n      else {\n         // 最正常的应该是进到这个分支。\n\n         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition\n         this.beanDefinitionMap.put(beanName, beanDefinition);\n         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字\n         this.beanDefinitionNames.add(beanName);\n         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，\n         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的\n         // 手动指的是通过调用以下方法注册的 bean ：\n         //     registerSingleton(String beanName, Object singletonObject)\n         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，\n         // 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的\n         this.manualSingletonNames.remove(beanName);\n      }\n      // 这个不重要，在预初始化的时候会用到，不必管它。\n      this.frozenBeanDefinitionNames = null;\n   }\n\n   if (oldBeanDefinition != null || containsSingleton(beanName)) {\n      resetBeanDefinition(beanName);\n   }\n}</code></pre>\n<p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>\n<p>--------- 分割线 ---------</p>\n<p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p>\n<h3 id=\"bean-容器实例化完成后\">Bean 容器实例化完成后</h3>\n<p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p>\n<p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p>\n<pre><code class=\"language-java\">@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n\n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n\n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法\n         invokeBeanFactoryPostProcessors(beanFactory);          \n\n\n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成，不展开\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(&quot;Exception encountered during context initialization - &quot; +\n                  &quot;cancelling refresh attempt: &quot; + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset &#39;active&#39; flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring&#39;s core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}</code></pre>\n<h3 id=\"准备-bean-容器-preparebeanfactory\">准备 Bean 容器: prepareBeanFactory</h3>\n<p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会&quot;手动&quot;注册一些特殊的 bean。</p>\n<p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p>\n<pre><code class=\"language-java\">/**\n * Configure the factory&#39;s standard context characteristics,\n * such as the context&#39;s ClassLoader and post-processors.\n * @param beanFactory the BeanFactory to configure\n */\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，\n   // 这里设置为加载当前 ApplicationContext 类的类加载器\n   beanFactory.setBeanClassLoader(getClassLoader());\n\n   // 设置 BeanExpressionResolver\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n   // \n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // 添加一个 BeanPostProcessor，这个 processor 比较简单：\n   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，\n   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware\n   // 注意：它不仅仅回调 ApplicationContextAware，\n   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\n   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，\n   // Spring 会通过其他方式来处理这些依赖。\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   /**\n    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，\n    * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行。\n    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource\n    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext\n    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean\n    */\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，\n   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器\n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它\n   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，\n   //    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj\n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   /**\n    * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean，\n    * 我们也可以选择覆盖\n    */\n\n   // 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个\n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n   // 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n   // 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}</code></pre>\n<p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p>\n<h3 id=\"初始化所有的-singleton-beans\">初始化所有的 singleton beans</h3>\n<p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p>\n<p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p>\n<p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p>\n<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p>\n<p>// AbstractApplicationContext.java 834</p>\n<pre><code class=\"language-java\">// 初始化剩余的 singleton beans\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n\n   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了\n   // 什么，看代码这里没有初始化 Bean 啊！\n   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧\n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n\n   // Register a default embedded value resolver if no bean post-processor\n   // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n   // at this point, primarily for resolution in annotation attribute values.\n   if (!beanFactory.hasEmbeddedValueResolver()) {\n      beanFactory.addEmbeddedValueResolver(new StringValueResolver() {\n         @Override\n         public String resolveStringValue(String strVal) {\n            return getEnvironment().resolvePlaceholders(strVal);\n         }\n      });\n   }\n\n   // 先初始化 LoadTimeWeaverAware 类型的 Bean\n   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧\n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n   for (String weaverAwareName : weaverAwareNames) {\n      getBean(weaverAwareName);\n   }\n\n   // Stop using the temporary ClassLoader for type matching.\n   beanFactory.setTempClassLoader(null);\n\n   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，\n   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。\n   beanFactory.freezeConfiguration();\n\n   // 开始初始化\n   beanFactory.preInstantiateSingletons();\n}</code></pre>\n<p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p>\n<h4 id=\"preinstantiatesingletons\">preInstantiateSingletons</h4>\n<p>// DefaultListableBeanFactory 728</p>\n<pre><code class=\"language-java\">@Override\npublic void preInstantiateSingletons() throws BeansException {\n   if (this.logger.isDebugEnabled()) {\n      this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);\n   }\n   // this.beanDefinitionNames 保存了所有的 beanNames\n   List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);\n\n   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作\n   for (String beanName : beanNames) {\n\n      // 合并父 Bean 中的配置，注意 &lt;bean id=&quot;&quot; class=&quot;&quot; parent=&quot;&quot; /&gt; 中的 parent，用的不多吧，\n      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 &quot;Bean 继承&quot;，不了解的请到附录中看一下\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\n      // 非抽象、非懒加载的 singletons。如果配置了 &#39;abstract = true&#39;，那是不需要初始化的\n      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {\n         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)\n         if (isFactoryBean(beanName)) {\n            // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急\n            final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);\n            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过\n            boolean isEagerInit;\n            if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {\n               isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {\n                  @Override\n                  public Boolean run() {\n                     return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();\n                  }\n               }, getAccessControlContext());\n            }\n            else {\n               isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;\n                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());\n            }\n            if (isEagerInit) {\n\n               getBean(beanName);\n            }\n         }\n         else {\n            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了\n            getBean(beanName);\n         }\n      }\n   }\n\n   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化\n   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略\n   for (String beanName : beanNames) {\n      Object singletonInstance = getSingleton(beanName);\n      if (singletonInstance instanceof SmartInitializingSingleton) {\n         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n         if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {\n               @Override\n               public Object run() {\n                  smartSingleton.afterSingletonsInstantiated();\n                  return null;\n               }\n            }, getAccessControlContext());\n         }\n         else {\n            smartSingleton.afterSingletonsInstantiated();\n         }\n      }\n   }\n}</code></pre>\n<p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p>\n<h4 id=\"getbean\">getBean</h4>\n<p>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p>\n<p>// AbstractBeanFactory 196</p>\n<pre><code class=\"language-java\">@Override\npublic Object getBean(String name) throws BeansException {\n   return doGetBean(name, null, null, false);\n}\n\n// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，\n// 已经初始化过了就从容器中直接返回，否则就先初始化再返回\n@SuppressWarnings(&quot;unchecked&quot;)\nprotected &lt;T&gt; T doGetBean(\n      final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)\n      throws BeansException {\n   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，\n   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的\n   final String beanName = transformedBeanName(name);\n\n   // 注意跟着这个，这个是返回值\n   Object bean; \n\n   // 检查下是不是已经创建过了\n   Object sharedInstance = getSingleton(beanName);\n\n   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，\n   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean\n   if (sharedInstance != null &amp;&amp; args == null) {\n      if (logger.isDebugEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.debug(&quot;...&quot;);\n         }\n         else {\n            logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n         }\n      }\n      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，\n      // 如果是 FactoryBean 的话，返回它创建的那个实例对象\n      // (FactoryBean 知识，读者若不清楚请移步附录)\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   }\n\n   else {\n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，\n         // 往往是因为陷入了循环引用\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // 检查一下这个 BeanDefinition 在容器中是否存在\n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有\n         String nameToLookup = originalBeanName(name);\n         if (args != null) {\n            // 返回父容器的查询结果\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         }\n         else {\n            // No args -&gt; delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         }\n      }\n\n      if (!typeCheckOnly) {\n         // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。\n         markBeanAsCreated(beanName);\n      }\n\n      /*\n       * 稍稍总结一下：\n       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；\n       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。\n       */\n      try {\n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n         checkMergedBeanDefinition(mbd, beanName, args);\n\n         // 先初始化依赖的所有 Bean，这个很好理解。\n         // 注意，这里的依赖指的是 depends-on 中定义的依赖\n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\n               }\n               // 注册一下依赖关系\n               registerDependentBean(dep, beanName);\n               // 先初始化被依赖项\n               getBean(dep);\n            }\n         }\n\n         // 如果是 singleton scope 的，创建 singleton 的实例\n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {\n               @Override\n               public Object getObject() throws BeansException {\n                  try {\n                     // 执行创建 Bean，详情后面再说\n                     return createBean(beanName, mbd, args);\n                  }\n                  catch (BeansException ex) {\n                     destroySingleton(beanName);\n                     throw ex;\n                  }\n               }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         }\n\n         // 如果是 prototype scope 的，创建 prototype 的实例\n         else if (mbd.isPrototype()) {\n            // It&#39;s a prototype -&gt; create a new instance.\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               // 执行创建 Bean\n               prototypeInstance = createBean(beanName, mbd, args);\n            }\n            finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         }\n\n         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理\n         else {\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);\n            }\n            try {\n               Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() {\n                  @Override\n                  public Object getObject() throws BeansException {\n                     beforePrototypeCreation(beanName);\n                     try {\n                        // 执行创建 Bean\n                        return createBean(beanName, mbd, args);\n                     }\n                     finally {\n                        afterPrototypeCreation(beanName);\n                     }\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            }\n            catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +\n                     &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,\n                     ex);\n            }\n         }\n      }\n      catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n\n   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了\n   if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) {\n      try {\n         return getTypeConverter().convertIfNecessary(bean, requiredType);\n      }\n      catch (TypeMismatchException ex) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +\n                  ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n      }\n   }\n   return (T) bean;\n}</code></pre>\n<p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p>\n<pre><code class=\"language-java\">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;</code></pre>\n<p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p>\n<p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p>\n<p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p>\n<pre><code class=\"language-java\">public class MessageServiceImpl implements MessageService {\n    @Autowired\n    private UserService userService;\n\n    public String getMessage() {\n        return userService.getMessage();\n    }\n}</code></pre>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt;</code></pre>\n<p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p>\n<p>好了，读者要知道这么回事就可以了，继续向前。</p>\n<p>// AbstractAutowireCapableBeanFactory 447</p>\n<pre><code class=\"language-java\">/**\n * Central method of this class: creates a bean instance,\n * populates the bean instance, applies post-processors, etc.\n * @see #doCreateBean\n */\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {\n   if (logger.isDebugEnabled()) {\n      logger.debug(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n   }\n   RootBeanDefinition mbdToUse = mbd;\n\n   // 确保 BeanDefinition 中的 Class 被加载\n   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);\n   if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {\n      mbdToUse = new RootBeanDefinition(mbd);\n      mbdToUse.setBeanClass(resolvedClass);\n   }\n\n   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; \n   // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。\n   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看\n   try {\n      mbdToUse.prepareMethodOverrides();\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n            beanName, &quot;Validation of method overrides failed&quot;, ex);\n   }\n\n   try {\n      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，\n      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过\n      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n      if (bean != null) {\n         return bean; \n      }\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n            &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);\n   }\n   // 重头戏，创建 bean\n   Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n   if (logger.isDebugEnabled()) {\n      logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n   }\n   return beanInstance;\n}</code></pre>\n<h4 id=\"创建-bean\">创建 Bean</h4>\n<p>我们继续往里看 doCreateBean 这个方法：</p>\n<pre><code class=\"language-java\">/**\n * Actually create the specified bean. Pre-creation processing has already happened\n * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n * &lt;p&gt;Differentiates between default bean instantiation, use of a\n * factory method, and autowiring a constructor.\n * @param beanName the name of the bean\n * @param mbd the merged bean definition for the bean\n * @param args explicit arguments to use for constructor or factory method invocation\n * @return a new instance of the bean\n * @throws BeanCreationException if the bean could not be created\n * @see #instantiateBean\n * @see #instantiateUsingFactoryMethod\n * @see #autowireConstructor\n */\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)\n      throws BeanCreationException {\n\n   // Instantiate the bean.\n   BeanWrapper instanceWrapper = null;\n   if (mbd.isSingleton()) {\n      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n   }\n   if (instanceWrapper == null) {\n      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说\n      instanceWrapper = createBeanInstance(beanName, mbd, args);\n   }\n   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 &quot;bean 实例&quot;\n   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);\n   // 类型\n   Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);\n   mbd.resolvedTargetType = beanType;\n\n   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor\n   synchronized (mbd.postProcessingLock) {\n      if (!mbd.postProcessed) {\n         try {\n            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的\n            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n         }\n         catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                  &quot;Post-processing of merged bean definition failed&quot;, ex);\n         }\n         mbd.postProcessed = true;\n      }\n   }\n\n   // Eagerly cache singletons to be able to resolve circular references\n   // even when triggered by lifecycle interfaces like BeanFactoryAware.\n   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧\n   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;\n         isSingletonCurrentlyInCreation(beanName));\n   if (earlySingletonExposure) {\n      if (logger.isDebugEnabled()) {\n         logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +\n               &quot;&#39; to allow for resolving potential circular references&quot;);\n      }\n      addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() {\n         @Override\n         public Object getObject() throws BeansException {\n            return getEarlyBeanReference(beanName, mbd, bean);\n         }\n      });\n   }\n\n   // Initialize the bean instance.\n   Object exposedObject = bean;\n   try {\n      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值\n      populateBean(beanName, mbd, instanceWrapper);\n      if (exposedObject != null) {\n         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？\n         // 这里就是处理 bean 初始化完成后的各种回调\n         exposedObject = initializeBean(beanName, exposedObject, mbd);\n      }\n   }\n   catch (Throwable ex) {\n      if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {\n         throw (BeanCreationException) ex;\n      }\n      else {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);\n      }\n   }\n\n   if (earlySingletonExposure) {\n      // \n      Object earlySingletonReference = getSingleton(beanName, false);\n      if (earlySingletonReference != null) {\n         if (exposedObject == bean) {\n            exposedObject = earlySingletonReference;\n         }\n         else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {\n            String[] dependentBeans = getDependentBeans(beanName);\n            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);\n            for (String dependentBean : dependentBeans) {\n               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                  actualDependentBeans.add(dependentBean);\n               }\n            }\n            if (!actualDependentBeans.isEmpty()) {\n               throw new BeanCurrentlyInCreationException(beanName,\n                     &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +\n                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                     &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +\n                     &quot;wrapped. This means that said other beans do not use the final version of the &quot; +\n                     &quot;bean. This is often the result of over-eager type matching - consider using &quot; +\n                     &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);\n            }\n         }\n      }\n   }\n\n   // Register bean as disposable.\n   try {\n      registerDisposableBeanIfNecessary(beanName, bean, mbd);\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);\n   }\n\n   return exposedObject;\n}</code></pre>\n<p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p>\n<p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 </p>\n<p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p>\n<h5 id=\"创建-bean-实例\">创建 Bean 实例</h5>\n<p>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p>\n<pre><code class=\"language-java\">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {\n   // 确保已经加载了此 class\n   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);\n\n   // 校验一下这个类的访问权限\n   if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {\n      throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n            &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());\n   }\n\n   if (mbd.getFactoryMethodName() != null)  {\n      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean\n      return instantiateUsingFactoryMethod(beanName, mbd, args);\n   }\n\n   // 如果不是第一次创建，比如第二次创建 prototype bean。\n   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化\n   boolean resolved = false;\n   boolean autowireNecessary = false;\n   if (args == null) {\n      synchronized (mbd.constructorArgumentLock) {\n         if (mbd.resolvedConstructorOrFactoryMethod != null) {\n            resolved = true;\n            autowireNecessary = mbd.constructorArgumentsResolved;\n         }\n      }\n   }\n   if (resolved) {\n      if (autowireNecessary) {\n         // 构造函数依赖注入\n         return autowireConstructor(beanName, mbd, null, null);\n      }\n      else {\n         // 无参构造函数\n         return instantiateBean(beanName, mbd);\n      }\n   }\n\n   // 判断是否采用有参构造函数\n   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n   if (ctors != null ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n      // 构造函数依赖注入\n      return autowireConstructor(beanName, mbd, ctors, args);\n   }\n\n   // 调用无参构造函数\n   return instantiateBean(beanName, mbd);\n}</code></pre>\n<p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p>\n<pre><code class=\"language-java\">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n   try {\n      Object beanInstance;\n      final BeanFactory parent = this;\n      if (System.getSecurityManager() != null) {\n         beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {\n            @Override\n            public Object run() {\n\n               return getInstantiationStrategy().instantiate(mbd, beanName, parent);\n            }\n         }, getAccessControlContext());\n      }\n      else {\n         // 实例化\n         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);\n      }\n      // 包装一下，返回\n      BeanWrapper bw = new BeanWrapperImpl(beanInstance);\n      initBeanWrapper(bw);\n      return bw;\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);\n   }\n}</code></pre>\n<p>我们可以看到，关键的地方在于：</p>\n<pre><code class=\"language-java\">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</code></pre>\n<p>这里会进行实际的实例化过程，我们进去看看:</p>\n<p>// SimpleInstantiationStrategy 59</p>\n<pre><code class=\"language-java\">@Override\npublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {\n\n   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,\n   // 方法覆写 请参见附录&quot;方法注入&quot;中对 lookup-method 和 replaced-method 的介绍\n   if (bd.getMethodOverrides().isEmpty()) {\n      Constructor&lt;?&gt; constructorToUse;\n      synchronized (bd.constructorArgumentLock) {\n         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;\n         if (constructorToUse == null) {\n            final Class&lt;?&gt; clazz = bd.getBeanClass();\n            if (clazz.isInterface()) {\n               throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);\n            }\n            try {\n               if (System.getSecurityManager() != null) {\n                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() {\n                     @Override\n                     public Constructor&lt;?&gt; run() throws Exception {\n                        return clazz.getDeclaredConstructor((Class[]) null);\n                     }\n                  });\n               }\n               else {\n                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);\n               }\n               bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n            }\n            catch (Throwable ex) {\n               throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);\n            }\n         }\n      }\n      // 利用构造方法进行实例化\n      return BeanUtils.instantiateClass(constructorToUse);\n   }\n   else {\n      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。\n      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持\n      return instantiateWithMethodInjection(bd, beanName, owner);\n   }\n}</code></pre>\n<p>到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。</p>\n<h5 id=\"bean-属性注入\">bean 属性注入</h5>\n<p>看完了 createBeanInstance(...) 方法，我们来看看 populateBean(...) 方法，该方法负责进行属性设值，处理依赖。</p>\n<p>// AbstractAutowireCapableBeanFactory 1203</p>\n<pre><code class=\"language-java\">protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {\n   // bean 实例的所有属性都在这里了\n   PropertyValues pvs = mbd.getPropertyValues();\n\n   if (bw == null) {\n      if (!pvs.isEmpty()) {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);\n      }\n      else {\n         // Skip property population phase for null instance.\n         return;\n      }\n   }\n\n   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，\n   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，\n   // 我也没找到有实际的使用，所以我们暂且忽略这块吧\n   boolean continueWithPropertyPopulation = true;\n   if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n      for (BeanPostProcessor bp : getBeanPostProcessors()) {\n         if (bp instanceof InstantiationAwareBeanPostProcessor) {\n            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n            // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理\n            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n               continueWithPropertyPopulation = false;\n               break;\n            }\n         }\n      }\n   }\n\n   if (!continueWithPropertyPopulation) {\n      return;\n   }\n\n   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n         autowireByName(beanName, mbd, bw, newPvs);\n      }\n\n      // 通过类型装配。复杂一些\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n         autowireByType(beanName, mbd, bw, newPvs);\n      }\n\n      pvs = newPvs;\n   }\n\n   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n   if (hasInstAwareBpps || needsDepCheck) {\n      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n      if (hasInstAwareBpps) {\n         for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor\n               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究\n               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n               if (pvs == null) {\n                  return;\n               }\n            }\n         }\n      }\n      if (needsDepCheck) {\n         checkDependencies(beanName, mbd, filteredPds, pvs);\n      }\n   }\n   // 设置 bean 实例的属性值\n   applyPropertyValues(beanName, mbd, bw, pvs);\n}</code></pre>\n<h5 id=\"initializebean\">initializeBean</h5>\n<p>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p>\n<pre><code class=\"language-java\">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n   if (System.getSecurityManager() != null) {\n      AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {\n         @Override\n         public Object run() {\n            invokeAwareMethods(beanName, bean);\n            return null;\n         }\n      }, getAccessControlContext());\n   }\n   else {\n      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调\n      invokeAwareMethods(beanName, bean);\n   }\n\n   Object wrappedBean = bean;\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessBeforeInitialization 回调\n      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n   }\n\n   try {\n      // 处理 bean 中定义的 init-method，\n      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法\n      invokeInitMethods(beanName, wrappedBean, mbd);\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            (mbd != null ? mbd.getResourceDescription() : null),\n            beanName, &quot;Invocation of init method failed&quot;, ex);\n   }\n\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessAfterInitialization 回调\n      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n   }\n   return wrappedBean;\n}</code></pre>\n<p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p>\n<h2 id=\"附录\">附录</h2>\n<h3 id=\"id-和-name\">id 和 name</h3>\n<p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p>\n<p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p>\n<pre><code class=\"language-java\">beanFactory.getBean(&quot;beanName or alias&quot;);</code></pre>\n<p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;messageService&quot; name=&quot;m1, m2, m3&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</code></pre>\n<p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p>\n<pre><code class=\"language-xml\">&lt;bean name=&quot;m1, m2, m3&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt;</code></pre>\n<p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p>\n<pre><code class=\"language-xml\">&lt;bean class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</code></pre>\n<p>beanName 为：com.javadoop.example.MessageServiceImpl#0，</p>\n<p>别名 1 个，为： com.javadoop.example.MessageServiceImpl</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</code></pre>\n<p>以上配置的结果就是：beanName 为 messageService，没有别名。</p>\n<h3 id=\"配置是否允许-bean-覆盖、是否允许循环依赖\">配置是否允许 Bean 覆盖、是否允许循环依赖</h3>\n<p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>\n<p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p>\n<p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p>\n<p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p>\n<p>添加这两个属性的作者 Juergen Hoeller 在这个 <a href=\"https://jira.spring.io/browse/SPR-4374\">jira</a> 的讨论中说明了怎么配置这两个属性。</p>\n<pre><code class=\"language-java\">public class NoBeanOverridingContextLoader extends ContextLoader {\n\n  @Override\n  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) {\n    super.customizeContext(servletContext, applicationContext);\n    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;\n    arac.setAllowBeanDefinitionOverriding(false);\n  }\n}</code></pre>\n<pre><code class=\"language-java\">public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener {\n\n  @Override\n  protected ContextLoader createContextLoader() {\n    return new NoBeanOverridingContextLoader();\n  }\n\n}</code></pre>\n<pre><code class=\"language-xml\">&lt;listener&gt;\n    &lt;listener-class&gt;com.javadoop.MyContextLoaderListener&lt;/listener-class&gt;  \n&lt;/listener&gt;</code></pre>\n<p>如果以上方式不能满足你的需求，请参考这个链接：<a href=\"http://blog.csdn.net/zgmzyr/article/details/39380477\">解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题</a></p>\n<h3 id=\"profile\">profile</h3>\n<p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p>\n<pre><code class=\"language-xml\">&lt;beans profile=&quot;development&quot;\n    xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;\n    xsi:schemaLocation=&quot;...&quot;&gt;\n\n    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;\n        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;\n        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;\n    &lt;/jdbc:embedded-database&gt;\n&lt;/beans&gt;</code></pre>\n<pre><code class=\"language-xml\">&lt;beans profile=&quot;production&quot;\n    xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;\n    xsi:schemaLocation=&quot;...&quot;&gt;\n\n    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;\n&lt;/beans&gt;</code></pre>\n<p>应该不必做过多解释了吧，看每个文件第一行的 profile=&quot;&quot;。</p>\n<p>当然，我们也可以在一个配置文件中使用：</p>\n<pre><code class=\"language-xml\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;\n    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;\n    xsi:schemaLocation=&quot;...&quot;&gt;\n\n    &lt;beans profile=&quot;development&quot;&gt;\n        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;\n            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;\n            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;\n        &lt;/jdbc:embedded-database&gt;\n    &lt;/beans&gt;\n\n    &lt;beans profile=&quot;production&quot;&gt;\n        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;\n    &lt;/beans&gt;\n&lt;/beans&gt;</code></pre>\n<p>理解起来也很简单吧。</p>\n<p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p>\n<p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p>\n<p>最简单的方式莫过于在程序启动的时候指定：</p>\n<pre><code class=\"language-shell\">-Dspring.profiles.active=&quot;profile1,profile2&quot;</code></pre>\n<blockquote>\n<p>profile 可以激活多个</p>\n</blockquote>\n<p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p>\n<pre><code class=\"language-java\">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles(&quot;development&quot;);\nctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\nctx.refresh(); // 重启</code></pre>\n<p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p>\n<pre><code class=\"language-shell\">java -Dspring.profiles.active=prod -jar JavaDoop.jar</code></pre>\n<p>如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。</p>\n<h3 id=\"工厂模式生成-bean\">工厂模式生成 Bean</h3>\n<p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p>\n<p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p>\n<p>静态工厂：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;clientService&quot;\n    class=&quot;examples.ClientService&quot;\n    factory-method=&quot;createInstance&quot;/&gt;</code></pre>\n<pre><code class=\"language-java\">public class ClientService {\n    private static ClientService clientService = new ClientService();\n    private ClientService() {}\n\n    // 静态方法\n    public static ClientService createInstance() {\n        return clientService;\n    }\n}</code></pre>\n<p>实例工厂：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;\n    &lt;!-- inject any dependencies required by this locator bean --&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;clientService&quot;\n    factory-bean=&quot;serviceLocator&quot;\n    factory-method=&quot;createClientServiceInstance&quot;/&gt;\n\n&lt;bean id=&quot;accountService&quot;\n    factory-bean=&quot;serviceLocator&quot;\n    factory-method=&quot;createAccountServiceInstance&quot;/&gt;</code></pre>\n<pre><code class=\"language-java\">public class DefaultServiceLocator {\n\n    private static ClientService clientService = new ClientServiceImpl();\n\n    private static AccountService accountService = new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() {\n        return clientService;\n    }\n\n    public AccountService createAccountServiceInstance() {\n        return accountService;\n    }\n}</code></pre>\n<h3 id=\"factorybean\">FactoryBean</h3>\n<p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p>\n<pre><code class=\"language-java\">public interface FactoryBean&lt;T&gt; {\n    T getObject() throws Exception;\n    Class&lt;T&gt; getObjectType();\n    boolean isSingleton();\n}</code></pre>\n<pre><code class=\"language-java\">public class Person { \n    private Car car ;\n    private void setCar(Car car){ this.car = car;  }  \n}</code></pre>\n<p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p>\n<pre><code class=\"language-java\">public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;{\n    private String make; \n    private int year ;\n\n    public void setMake(String m){ this.make =m ; }\n\n    public void setYear(int y){ this.year = y; }\n\n    public Car getObject(){ \n      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种\n      CarBuilder cb = CarBuilder.car();\n\n      if(year!=0) cb.setYear(this.year);\n      if(StringUtils.hasText(this.make)) cb.setMake( this.make ); \n      return cb.factory(); \n    }\n\n    public Class&lt;Car&gt; getObjectType() { return Car.class ; } \n\n    public boolean isSingleton() { return false; }\n}</code></pre>\n<p>我们看看装配的时候是怎么配置的：</p>\n<pre><code class=\"language-xml\">&lt;bean class = &quot;com.javadoop.MyCarFactoryBean&quot; id = &quot;car&quot;&gt;\n  &lt;property name = &quot;make&quot; value =&quot;Honda&quot;/&gt;\n  &lt;property name = &quot;year&quot; value =&quot;1984&quot;/&gt;\n&lt;/bean&gt;\n&lt;bean class = &quot;com.javadoop.Person&quot; id = &quot;josh&quot;&gt;\n  &lt;property name = &quot;car&quot; ref = &quot;car&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p>\n<p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？</p>\n<pre><code class=\"language-java\">@Configuration \npublic class CarConfiguration { \n\n    @Bean \n    public MyCarFactoryBean carFactoryBean(){ \n      MyCarFactoryBean cfb = new MyCarFactoryBean();\n      cfb.setMake(&quot;Honda&quot;);\n      cfb.setYear(1984);\n      return cfb;\n    }\n\n    @Bean\n    public Person aPerson(){ \n    Person person = new Person();\n      // 注意这里的不同\n    person.setCar(carFactoryBean().getObject());\n    return person; \n    } \n}</code></pre>\n<p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p>\n<h3 id=\"初始化-bean-的回调\">初始化 Bean 的回调</h3>\n<p>有以下四种方案：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;</code></pre>\n<pre><code class=\"language-java\">public class AnotherExampleBean implements InitializingBean {\n\n    public void afterPropertiesSet() {\n        // do some initialization work\n    }\n}</code></pre>\n<pre><code class=\"language-java\">@Bean(initMethod = &quot;init&quot;)\npublic Foo foo() {\n    return new Foo();\n}</code></pre>\n<pre><code class=\"language-java\">@PostConstruct\npublic void init() {\n\n}</code></pre>\n<h3 id=\"销毁-bean-的回调\">销毁 Bean 的回调</h3>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;</code></pre>\n<pre><code class=\"language-java\">public class AnotherExampleBean implements DisposableBean {\n\n    public void destroy() {\n        // do some destruction work (like releasing pooled connections)\n    }\n}</code></pre>\n<pre><code class=\"language-java\">@Bean(destroyMethod = &quot;cleanup&quot;)\npublic Bar bar() {\n    return new Bar();\n}</code></pre>\n<pre><code class=\"language-java\">@PreDestroy\npublic void cleanup() {\n\n}</code></pre>\n<h3 id=\"conversionservice\">ConversionService</h3>\n<p>既然文中说到了这个，顺便提一下好了。</p>\n<p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p>\n<p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;conversionService&quot;\n  class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;\n  &lt;property name=&quot;converters&quot;&gt;\n    &lt;list&gt;\n      &lt;bean class=&quot;com.javadoop.learning.utils.StringToEnumConverterFactory&quot;/&gt;\n    &lt;/list&gt;\n  &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p>\n<p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p>\n<p>来看一个很简单的例子，这样比什么都管用。</p>\n<pre><code class=\"language-java\">public class StringToDateConverter implements Converter&lt;String, Date&gt; {\n\n    @Override\n    public Date convert(String source) {\n        try {\n            return DateUtils.parseDate(source, &quot;yyyy-MM-dd&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd HH:mm&quot;, &quot;HH:mm:ss&quot;, &quot;HH:mm&quot;);\n        } catch (ParseException e) {\n            return null;\n        }\n    }\n}</code></pre>\n<p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p>\n<h3 id=\"bean-继承\">Bean 继承</h3>\n<p>在初始化 Bean 的地方，我们说过了这个：</p>\n<pre><code class=\"language-java\">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</code></pre>\n<p>这里涉及到的就是 <code>&lt;bean parent=&quot;&quot; /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p>\n<p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p>\n<p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p>\n<p>看如下一个例子:</p>\n<pre><code class=\"language-java\">&lt;bean id=&quot;inheritedTestBean&quot; abstract=&quot;true&quot; class=&quot;org.springframework.beans.TestBean&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;\n    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;inheritsWithDifferentClass&quot; class=&quot;org.springframework.beans.DerivedTestBean&quot;\n        parent=&quot;inheritedTestBean&quot; init-method=&quot;initialize&quot;&gt;\n\n    &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<p>parent bean 设置了 <code>abstract=&quot;true&quot;</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p>\n<p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p>\n<p>当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p>\n<p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p>\n<pre><code class=\"language-java\">&lt;bean id=&quot;inheritedTestBeanWithoutClass&quot; abstract=&quot;true&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;\n    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<h3 id=\"方法注入\">方法注入</h3>\n<p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p>\n<p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p>\n<p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p>\n<p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p>\n<h4 id=\"lookup-method\">lookup-method</h4>\n<p>我们来看一下 Spring Reference 中提供的一个例子：</p>\n<pre><code class=\"language-java\">package fiona.apple;\n\n// no more Spring imports!\n\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        // grab a new instance of the appropriate Command interface\n        Command command = createCommand();\n        // set the state on the (hopefully brand new) Command instance\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    // okay... but where is the implementation of this method?\n    protected abstract Command createCommand();\n}</code></pre>\n<p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p>\n<pre><code class=\"language-xml\">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;\n&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt;\n    &lt;!-- inject dependencies here as required --&gt;\n&lt;/bean&gt;\n\n&lt;!-- commandProcessor uses statefulCommandHelper --&gt;\n&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt;\n    &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<p>Spring 采用 <strong>CGLIB 生成字节码</strong>的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p>\n<p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p>\n<pre><code class=\"language-java\">public abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup(&quot;myCommand&quot;)\n    protected abstract Command createCommand();\n}</code></pre>\n<blockquote>\n<p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt;</code></p>\n</blockquote>\n<p>甚至，我们可以像下面这样：</p>\n<pre><code class=\"language-java\">public abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup\n    protected abstract MyCommand createCommand();\n}</code></pre>\n<blockquote>\n<p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p>\n</blockquote>\n<h4 id=\"replaced-method\">replaced-method</h4>\n<p>记住它的功能，就是替换掉 bean 中的一些方法。</p>\n<pre><code class=\"language-java\">public class MyValueCalculator {\n\n    public String computeValue(String input) {\n        // some real code...\n    }\n\n    // some other methods...\n}</code></pre>\n<p>方法覆写，注意要实现 MethodReplacer 接口：</p>\n<pre><code class=\"language-java\">public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer {\n\n    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {\n        // get the input value, work with it, and return a computed result\n        String input = (String) args[0];\n        ...\n        return ...;\n    }\n}</code></pre>\n<p>配置也很简单：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt;\n    &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;\n    &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt;\n        &lt;arg-type&gt;String&lt;/arg-type&gt;\n    &lt;/replaced-method&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt;</code></pre>\n<blockquote>\n<p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p>\n</blockquote>\n<h3 id=\"beanpostprocessor\">BeanPostProcessor</h3>\n<p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p>\n<pre><code class=\"language-java\">public interface BeanPostProcessor {\n\n   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\n   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n\n}</code></pre>\n<p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p>\n<p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p>\n<p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p>\n<p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p>\n<p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p>\n<p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p>\n<p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p>\n<h2 id=\"总结\">总结</h2>\n<p>按理说，总结应该写在附录前面，我就不讲究了。</p>\n<p>在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。</p>\n<p>本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。</p>\n<p>（全文完）</p>\n',345,0,105,2,NULL,'2018-05-01 00:49:23','2020-09-30 00:49:19',1,'32,44,48',1,0),(9,'Java 线上故障如何完整排查？','线上故障主要会包括 CPU、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如 jstack、jmap 等工具也是不囿于一个方面的问题的，基本上出问题就是 df、free、top 三连，然后依次 jstack、jmap 伺候，具体问题具体分析即可。','fredalxin','线上故障主要会包括 CPU、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如 jstack、jmap 等工具也是不囿于一个方面的问题的，基本上出问题就是 df、free、top 三连，然后依次 jstack、jmap 伺候，具体问题具体分析即可。\n\n#### CPU\n\n一般来讲我们首先会排查 CPU 方面的问题。CPU 异常往往还是比较好定位的。原因包括业务逻辑问题(死循环)、频繁 gc 以及上下文切换过多。而最常见的往往是业务逻辑(或者框架逻辑)导致的，可以使用 jstack 来分析对应的堆栈情况。\n\n#### 使用 jstack 分析 CPU 问题\n\n我们先用 ps 命令找到对应进程的 pid(如果你有好几个目标进程，可以先用 top 看一下哪个占用比较高)。\n\n接着用top -H -p pid来找到 CPU 使用率比较高的一些线程\n\n![image.png](http://oss.osalien.com/dbblog/20200927/d33c397f46b145fc86679540e5be2904.png)\n\n然后将占用最高的 pid 转换为 16 进制printf \'%x\\n\' pid得到 nid\n\n![image.png](http://oss.osalien.com/dbblog/20200927/6760c82f80f44c27828a3ba9f60c614d.png)\n\n接着直接在 jstack 中找到相应的堆栈信息jstack pid |grep \'nid\' -C5 –color\n\n![image.png](http://oss.osalien.com/dbblog/20200927/22650688578a4f6a93ab5ea615627c2b.png)\n\n可以看到我们已经找到了 nid 为 0x42 的堆栈信息，接着只要仔细分析一番即可。\n\n当然更常见的是我们对整个 jstack 文件进行分析，通常我们会比较关注 WAITING 和 TIMED_WAITING 的部分，BLOCKED 就不用说了。我们可以使用命令cat jstack.log | grep \"java.lang.Thread.State\" | sort -nr | uniq -c来对 jstack 的状态有一个整体的把握，如果 WAITING 之类的特别多，那么多半是有问题啦。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/2963c48aa1544016b0e11e29a0aaff48.png)\n\n#### 频繁 gc\n\n当然我们还是会使用 jstack 来分析问题，但有时候我们可以先确定下 gc 是不是太频繁，使用jstat -gc pid 1000命令来对 gc 分代变化情况进行观察，1000 表示采样间隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU 分别代表两个 Survivor 区、Eden 区、老年代、元数据区的容量和使用量。YGC/YGT、FGC/FGCT、GCT 则代表 YoungGc、FullGc 的耗时和次数以及总耗时。如果看到 gc 比较频繁，再针对 gc 方面做进一步分析，具体可以参考一下 gc 章节的描述。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/3fadb753db7b4568993bb3e6344b1af4.png)\n\n#### 上下文切换\n\n针对频繁上下文问题，我们可以使用vmstat命令来进行查看\n\n![image.png](http://oss.osalien.com/dbblog/20200927/c449faf67d734bdc8ab4563e9de8d384.png)\n\ncs(context switch)一列则代表了上下文切换的次数。\n\n如果我们希望对特定的 pid 进行监控那么可以使用 pidstat -w pid命令，cswch 和 nvcswch 表示自愿及非自愿切换。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/fd00a2f8bd544565ba51d68b6d14c863.png)\n\n#### 磁盘\n\n磁盘问题和 CPU 一样是属于比较基础的。首先是磁盘空间方面，我们直接使用df -hl来查看文件系统状态\n\n![image.png](http://oss.osalien.com/dbblog/20200927/23e2dc95130f44e591df06636e8e4ebb.png)\n\n更多时候，磁盘问题还是性能上的问题。我们可以通过 iostatiostat -d -k -x来进行分析\n\n![image.png](http://oss.osalien.com/dbblog/20200927/1f27ecf8dd69422596392f12fccf3105.png)\n\n最后一列%util可以看到每块磁盘写入的程度，而rrqpm/s以及wrqm/s分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。\n\n另外我们还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用 iotop 命令来进行定位文件读写的来源。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/f9705cad7ea746f1a2cd9bbea9dd351f.png)\n\n不过这边拿到的是 tid，我们要转换成 pid，可以通过 readlink 来找到 pidreadlink -f /proc/*/task/tid/../..。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/235332789b2e473ebfb1aa19880a4242.png)\n\n找到 pid 之后就可以看这个进程具体的读写情况cat /proc/pid/io\n\n![image.png](http://oss.osalien.com/dbblog/20200927/4e9e0e65e2f2498baf3d4ffb58cede5e.png)\n\n我们还可以通过 lsof 命令来确定具体的文件读写情况lsof -p pid\n\n![image.png](http://oss.osalien.com/dbblog/20200927/eb46b64979434f62b96245f4682a51c1.png)\n\n#### 内存\n\n内存问题排查起来相对比 CPU 麻烦一些，场景也比较多。主要包括 OOM、GC 问题和堆外内存。一般来讲，我们会先用free命令先来检查一发内存的各种情况。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/8e4e7c787d8840949eb04d4021fd464d.png)\n\n#### 堆内内存\n\n内存问题大多还都是堆内内存问题。表象上主要分为 OOM 和 Stack Overflow。\n\n#### OOM\n\nJMV 中的内存不足，OOM 大致可以分为以下几种：\n\nException in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread\n\n这个意思是没有足够的内存空间给线程分配 Java 栈，基本上还是线程池代码写的有问题，比如说忘记 shutdown，所以说应该首先从代码层面来寻找问题，使用 jstack 或者 jmap。如果一切都正常，JVM 方面可以通过指定Xss来减少单个 thread stack 的大小。另外也可以在系统层面，可以通过修改/etc/security/limits.confnofile 和 nproc 来增大 os 对线程的限制\n\n![image.png](http://oss.osalien.com/dbblog/20200927/2c72af00da7b4aaba4099b915bfdde3b.png)\n\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\n这个意思是堆的内存占用已经达到-Xmx 设置的最大值，应该是最常见的 OOM 错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过 jstack 和 jmap 去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。\n\nCaused by: java.lang.OutOfMemoryError: Meta space\n\n这个意思是元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值，排查思路和上面的一致，参数方面可以通过XX:MaxPermSize来进行调整(这里就不说 1.8 以前的永久代了)。\n\n#### Stack Overflow\n栈内存溢出，这个大家见到也比较多。\n\nException in thread \"main\" java.lang.StackOverflowError\n\n表示线程栈需要的内存大于 Xss 值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起 OOM。\n\n#### 使用 JMAP 定位代码内存泄漏\n\n上述关于 OOM 和 Stack Overflo 的代码排查方面，我们一般使用 JMAPjmap -dump:format=b,file=filename pid来导出 dump 文件\n\n![image.png](http://oss.osalien.com/dbblog/20200927/db465142011f4e1685e175d0a04db8d6.png)\n\n通过 mat(Eclipse Memory Analysis Tools)导入 dump 文件进行分析，内存泄漏问题一般我们直接选 Leak Suspects 即可，mat 给出了内存泄漏的建议。另外也可以选择 Top Consumers 来查看最大对象报告。和线程相关的问题可以选择 thread overview 进行分析。除此之外就是选择 Histogram 类概览来自己慢慢分析，大家可以搜搜 mat 的相关教程。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/47c7b39e77a0471e80262e6ade5133ed.png)\n\n日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都 new 对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发 gc；ByteBuffer 缓存分配不合理等都会造成代码 OOM。\n\n另一方面，我们可以在启动参数中指定-XX:+HeapDumpOnOutOfMemoryError来保存 OOM 时的 dump 文件。\n\n#### gc 问题和线程\n\ngc 问题除了影响 CPU 也会影响内存，排查思路也是一致的。一般先使用 jstat 来查看分代变化情况，比如 youngGC 或者 fullGC 次数是不是太多呀；EU、OU 等指标增长是不是异常呀等。\n\n线程的话太多而且不被及时 gc 也会引发 oom，大部分就是之前说的unable to create new native thread。除了 jstack 细细分析 dump 文件外，我们一般先会看下总体线程，通过pstreee -p pid |wc -l。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/c71f1d2b672d4a64a46db2053357b973.png)\n\n或者直接通过查看/proc/pid/task的数量即为线程数量。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/3607e378a2774679a7ff8964164d31ba.png)\n\n#### 堆外内存\n\n如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用 Netty 导致的，那错误日志里可能会出现OutOfDirectMemoryError错误，如果直接是 DirectByteBuffer，那会报OutOfMemoryError: Direct buffer memory。\n\n堆外内存溢出往往是和 NIO 的使用相关，一般我们先通过 pmap 来查看下进程占用的内存情况pmap -x pid | sort -rn -k3 | head -30，这段意思是查看对应 pid 倒序前 30 大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/e1a9f722b6234ecab47cec2cca393680.png)\n\n我们如果确定有可疑的内存端，需要通过 gdb 来分析gdb --batch --pid {pid} -ex \"dump memory filename.dump {内存起始地址} {内存起始地址+内存块大小}\"\n\n![image.png](http://oss.osalien.com/dbblog/20200927/c632856b2f4945f195a0bc9f958e314d.png)\n\n获取 dump 文件后可用 heaxdump 进行查看hexdump -C filename | less，不过大多数看到的都是二进制乱码。\n\nNMT 是 Java7U40 引入的 HotSpot 新特性，配合 jcmd 命令我们就可以看到具体内存组成了。需要在启动参数中加入 -XX:NativeMemoryTracking=summary 或者 -XX:NativeMemoryTracking=detail，会有略微性能损耗。\n\n一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线jcmd pid VM.native_memory baseline。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/4a6cf290ef724e2aa9b0f7d49efa4df6.png)\n\n然后等放一段时间后再去看看内存增长的情况，通过jcmd pid VM.native_memory detail.diff(summary.diff)做一下 summary 或者 detail 级别的 diff。\n![image.png](http://oss.osalien.com/dbblog/20200927/41290e8a8eba44eda50321ccbf0200ee.png)\n\n![image.png](http://oss.osalien.com/dbblog/20200927/5a5a1aacb7724a88a02a969fe47c6ddf.png)\n\n可以看到 jcmd 分析出来的内存十分详细，包括堆内、线程以及 gc(所以上述其他内存异常其实都可以用 nmt 来分析)，这边堆外内存我们重点关注 Internal 的内存增长，如果增长十分明显的话那就是有问题了。\n\ndetail 级别的话还会有具体内存段的增长情况，如下图。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/7d33fe50bc084327a175d3349a073410.png)\n\n此外在系统层面，我们还可以使用 strace 命令来监控内存分配 strace -f -e \"brk,mmap,munmap\" -p pid\n\n这边内存分配信息主要包括了 pid 和内存地址。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/199815eca3ec4628bf708b8efe94c442.png)\n\n不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如 DirectByteBuffer 分配内存的话，是需要 full GC 或者手动 system.gc 来进行回收的(所以最好不要使用-XX:+DisableExplicitGC)。那么其实我们可以跟踪一下 DirectByteBuffer 对象的内存情况，通过jmap -histo:live pid手动触发 fullGC 来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过-XX:MaxDirectMemorySize进行调整。如果没有什么变化，那就要使用 jmap 去分析那些不能被 gc 的对象，以及和 DirectByteBuffer 之间的引用关系了。\n\n#### GC 问题\n\n堆内内存泄漏总是和 GC 异常相伴。不过 GC 问题不只是和内存问题相关，还有可能引起 CPU 负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下 GC 相关问题。\n\n我们在 CPU 章介绍了使用 jstat 来获取当前 GC 分代变化信息。而更多时候，我们是通过 GC 日志来排查问题的，在启动参数中加上-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps来开启 GC 日志。\n\n常见的 Young GC、Full GC 日志含义在此就不做赘述了。\n\n针对 gc 日志，我们就能大致推断出 youngGC 与 fullGC 是否过于频繁或者耗时过长，从而对症下药。我们下面将对 G1 垃圾收集器来做分析，这边也建议大家使用 G1-XX:+UseG1GC。\n\n#### youngGC 过频繁\n\nyoungGC 频繁一般是短周期小对象较多，先考虑是不是 Eden 区/新生代设置的太小了，看能否通过调整-Xmn、-XX:SurvivorRatio 等参数设置来解决问题。如果参数正常，但是 young gc 频率还是太高，就需要使用 Jmap 和 MAT 对 dump 文件进行进一步排查了。\n\n#### youngGC 耗时过长\n\n耗时过长问题就要看 GC 日志里耗时耗在哪一块了。以 G1 日志为例，可以关注 Root Scanning、Object Copy、Ref Proc 等阶段。Ref Proc 耗时长，就要注意引用相关的对象。Root Scanning 耗时长，就要注意线程数、跨代引用。Object Copy 则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的 Root Scanning 和正常时间段比增长较多，那就是起的线程太多了。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/947a26cadcc04bc8a870144179c62c39.png)\n\n#### 触发 fullGC\n\nG1 中更多的还是 mixedGC，但 mixedGC 可以和 youngGC 思路一样去排查。触发 fullGC 了一般都会有问题，G1 会退化使用 Serial 收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。\n\nfullGC 的原因可能包括以下这些，以及参数调整方面的一些思路：\n\n- 并发阶段失败：在并发标记阶段，MixGC 之前老年代就被填满了，那么这时候 G1 就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数-XX:ConcGCThreads。\n\n- 晋升失败：在 GC 的时候没有足够的内存供存活/晋升对象使用，所以触发了 Full GC。这时候可以通过-XX:G1ReservePercent来增加预留内存百分比，减少-XX:InitiatingHeapOccupancyPercent来提前启动标记，-XX:ConcGCThreads来增加标记线程数也是可以的。\n\n- 大对象分配失败：大对象找不到合适的 region 空间进行分配，就会进行 fullGC，这种情况下可以增大内存或者增大-XX:G1HeapRegionSize。\n\n- 程序主动执行 System.gc()：不要随便写就对了。\n\n另外，我们可以在启动参数中配置-XX:HeapDumpPath=/xxx/dump.hprof来 dump fullGC 相关的文件，并通过 jinfo 来进行 gc 前后的 dump\n\n```\njinfo -flag +HeapDumpBeforeFullGC pid\njinfo -flag +HeapDumpAfterFullGC pid\n```\n\n这样得到 2 份 dump 文件，对比后主要关注被 gc 掉的问题对象来定位问题。\n\n#### 网络\n\n涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从 tcp 层、应用层以及工具的使用等方面进行阐述。\n\n#### 超时\n\n超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。\n\n- 读写超时。readTimeout/writeTimeout，有些框架叫做 so_timeout 或者 socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa 的超时指的也是读超时。读写超时一般都只针对客户端设置。\n\n- 连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边 connectionTimeout 就有些五花八门了，Jetty 中表示空闲连接清理时间，Tomcat 则表示连接维持的最大时间。\n\n- 其他。包括连接获取超时 connectionAcquireTimeout 和空闲连接清理超时 idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。\n\n我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。\n\n在实际开发中，我们关心最多的应该是接口的读写超时了。\n\n如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的 tcp 连接。而如果接口设置的过短，那么接口超时就会非常频繁。\n\n服务端接口明明 rt 降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。\n\n#### TCP 队列溢出\n\ntcp 队列溢出是个相对底层的错误，它可能会造成超时、rst 等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/5a70a907d7e947709d3cc8f98c3a2af5.png)\n\n如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在 server 收到 client 的 syn 后，把消息放到 syns queue，回复 syn+ack 给 client，server 收到 client 的 ack，如果这时 accept queue 没满，那就从 syns queue 拿出暂存的信息放入 accept queue 中，否则按 tcp_abort_on_overflow 指示的执行。\n\ntcp_abort_on_overflow 0 表示如果三次握手第三步的时候 accept queue 满了那么 server 扔掉 client 发过来的 ack。tcp_abort_on_overflow 1 则表示第三步的时候如果全连接队列满了，server 发送一个 rst 包给 client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多connection reset / connection reset by peer。\n\n那么在实际开发中，我们怎么能快速定位到 tcp 队列溢出呢？\n\nnetstat 命令，执行 netstat -s | egrep \"listen|LISTEN\"\n\n![image.png](http://oss.osalien.com/dbblog/20200927/7429f7ac0a034cce958bb62d5404599d.png)\n\n如上图所示，overflowed 表示全连接队列溢出的次数，sockets dropped 表示半连接队列溢出的次数。\n\n#### ss 命令，执行 ss -lnt\n\n![image.png](http://oss.osalien.com/dbblog/20200927/528542ca39d84222b64ee4479f373e07.png)\n\n上面看到 Send-Q 表示第三列的 listen 端口上的全连接队列最大为 5，第一列 Recv-Q 为全连接队列当前使用了多少。\n\n接着我们看看怎么设置全连接、半连接队列大小吧：\n\n全连接队列的大小取决于 min(backlog, somaxconn)。backlog 是在 socket 创建的时候传入的，somaxconn 是一个 os 级别的系统参数。而半连接队列的大小取决于 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。\n\n在日常开发中，我们往往使用 servlet 容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在 Tomcat 中 backlog 叫做acceptCount，在 Jetty 里面则是acceptQueueSize。\n\n#### RST 异常\n\nRST 包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。\n\n在实际开发中，我们往往会看到connection reset / connection reset by peer错误，这种情况就是 RST 包导致的。\n\n#### 端口不存在\n\n如果像不存在的端口发出建立连接 SYN 请求，那么服务端发现自己并没有这个端口则会直接返回一个 RST 报文，用于中断连接。\n\n#### 主动代替 FIN 终止连接\n\n一般来说，正常的连接关闭都是需要通过 FIN 报文实现，然而我们也可以用 RST 报文来代替 FIN，表示直接终止连接。实际开发中，可设置 SO_LINGER 数值来控制，这种往往是故意的，来跳过 TIMED_WAIT，提供交互效率，不闲就慎用。\n\n**客户端或服务端有一边发生了异常，该方向对端发送 RST 以告知关闭连接**\n\n我们上面讲的 tcp 队列溢出发送 RST 包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。\n\n**接收到的 TCP 报文不在已知的 TCP 连接内**\n\n比如，一方机器由于网络实在太差 TCP 报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的 TCP 报文，但由于对应的 TCP 连接已不存在，那么会直接发一个 RST 包以便开启新的连接。\n\n**一方长期未收到另一方的确认报文，在一定时间或重传次数后发出 RST 报文**\n\n这种大多也和网络环境相关了，网络环境差可能会导致更多的 RST 报文。\n\n之前说过 RST 报文多会导致程序报错，在一个已关闭的连接上读操作会报connection reset，而在一个已关闭的连接上写操作则会报connection reset by peer。通常我们可能还会看到broken pipe错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到 RST，报出connection reset错后继续读写数据报的错，这个在 glibc 源码注释中也有介绍。\n\n我们在排查故障时候怎么确定有 RST 包的存在呢？当然是使用 tcpdump 命令进行抓包，并使用 wireshark 进行简单分析了。tcpdump -i en0 tcp -w xxx.cap，en0 表示监听的网卡。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/940bcfd015b04240bf8bc050ece98c8d.png)\n\n接下来我们通过 wireshark 打开抓到的包，可能就能看到如下图所示，红色的就表示 RST 包了。\n\n![image.png](http://oss.osalien.com/dbblog/20200927/7a07046d13824178980f1dcc28ff227f.png)\n\n#### TIME_WAIT 和 CLOSE_WAIT\n\nTIME_WAIT 和 CLOSE_WAIT 是啥意思相信大家都知道。\n\n在线上时，我们可以直接用命令netstat -n | awk \'/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}\'来查看 time-wait 和 close_wait 的数量\n\n用 ss 命令会更快ss -ant | awk \'{++S[$1]} END {for(a in S) print a, S[a]}\'\n\n![image.png](http://oss.osalien.com/dbblog/20200927/2e9d2d2362704767bcf15172774c2ac3.png)\n\n#### TIME_WAIT\n\ntime_wait 的存在一是为了丢失的数据包被后面连接复用，二是为了在 2MSL 的时间范围内正常关闭连接。它的存在其实会大大减少 RST 包的出现。\n\n过多的 time_wait 在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:\n\n```\n#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭\n\nnet.ipv4.tcp_tw_reuse = 1\n\n#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭\n\nnet.ipv4.tcp_tw_recycle = 1\n```\n\n当然我们不要忘记在 NAT 环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小tcp_max_tw_buckets，超过这个数的 time_wait 都会被干掉，不过这也会导致报time wait bucket table overflow的错。\n\n#### CLOSE_WAIT\n\nclose_wait 往往都是因为应用程序写的有问题，没有在 ACK 后再次发起 FIN 报文。close_wait 出现的概率甚至比 time_wait 要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。\n\n想要定位这类问题，最好是通过 jstack 来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。\n\n开发同学说应用上线后 CLOSE_WAIT 就一直增多，直到挂掉为止，jstack 后找到比较可疑的堆栈是大部分线程都卡在了countdownlatch.await方法，找开发同学了解后得知使用了多线程但是确没有 catch 异常，修改后发现异常仅仅是最简单的升级 sdk 后常出现的class not found。\n','<p>线上故障主要会包括 CPU、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如 jstack、jmap 等工具也是不囿于一个方面的问题的，基本上出问题就是 df、free、top 三连，然后依次 jstack、jmap 伺候，具体问题具体分析即可。</p>\n<h4 id=\"cpu\">CPU</h4>\n<p>一般来讲我们首先会排查 CPU 方面的问题。CPU 异常往往还是比较好定位的。原因包括业务逻辑问题(死循环)、频繁 gc 以及上下文切换过多。而最常见的往往是业务逻辑(或者框架逻辑)导致的，可以使用 jstack 来分析对应的堆栈情况。</p>\n<h4 id=\"使用-jstack-分析-cpu-问题\">使用 jstack 分析 CPU 问题</h4>\n<p>我们先用 ps 命令找到对应进程的 pid(如果你有好几个目标进程，可以先用 top 看一下哪个占用比较高)。</p>\n<p>接着用top -H -p pid来找到 CPU 使用率比较高的一些线程</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/d33c397f46b145fc86679540e5be2904.png\" alt=\"image.png\"></p>\n<p>然后将占用最高的 pid 转换为 16 进制printf &#39;%x\\n&#39; pid得到 nid</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/6760c82f80f44c27828a3ba9f60c614d.png\" alt=\"image.png\"></p>\n<p>接着直接在 jstack 中找到相应的堆栈信息jstack pid |grep &#39;nid&#39; -C5 –color</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/22650688578a4f6a93ab5ea615627c2b.png\" alt=\"image.png\"></p>\n<p>可以看到我们已经找到了 nid 为 0x42 的堆栈信息，接着只要仔细分析一番即可。</p>\n<p>当然更常见的是我们对整个 jstack 文件进行分析，通常我们会比较关注 WAITING 和 TIMED_WAITING 的部分，BLOCKED 就不用说了。我们可以使用命令cat jstack.log | grep &quot;java.lang.Thread.State&quot; | sort -nr | uniq -c来对 jstack 的状态有一个整体的把握，如果 WAITING 之类的特别多，那么多半是有问题啦。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/2963c48aa1544016b0e11e29a0aaff48.png\" alt=\"image.png\"></p>\n<h4 id=\"频繁-gc\">频繁 gc</h4>\n<p>当然我们还是会使用 jstack 来分析问题，但有时候我们可以先确定下 gc 是不是太频繁，使用jstat -gc pid 1000命令来对 gc 分代变化情况进行观察，1000 表示采样间隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU 分别代表两个 Survivor 区、Eden 区、老年代、元数据区的容量和使用量。YGC/YGT、FGC/FGCT、GCT 则代表 YoungGc、FullGc 的耗时和次数以及总耗时。如果看到 gc 比较频繁，再针对 gc 方面做进一步分析，具体可以参考一下 gc 章节的描述。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/3fadb753db7b4568993bb3e6344b1af4.png\" alt=\"image.png\"></p>\n<h4 id=\"上下文切换\">上下文切换</h4>\n<p>针对频繁上下文问题，我们可以使用vmstat命令来进行查看</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/c449faf67d734bdc8ab4563e9de8d384.png\" alt=\"image.png\"></p>\n<p>cs(context switch)一列则代表了上下文切换的次数。</p>\n<p>如果我们希望对特定的 pid 进行监控那么可以使用 pidstat -w pid命令，cswch 和 nvcswch 表示自愿及非自愿切换。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/fd00a2f8bd544565ba51d68b6d14c863.png\" alt=\"image.png\"></p>\n<h4 id=\"磁盘\">磁盘</h4>\n<p>磁盘问题和 CPU 一样是属于比较基础的。首先是磁盘空间方面，我们直接使用df -hl来查看文件系统状态</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/23e2dc95130f44e591df06636e8e4ebb.png\" alt=\"image.png\"></p>\n<p>更多时候，磁盘问题还是性能上的问题。我们可以通过 iostatiostat -d -k -x来进行分析</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/1f27ecf8dd69422596392f12fccf3105.png\" alt=\"image.png\"></p>\n<p>最后一列%util可以看到每块磁盘写入的程度，而rrqpm/s以及wrqm/s分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。</p>\n<p>另外我们还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用 iotop 命令来进行定位文件读写的来源。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/f9705cad7ea746f1a2cd9bbea9dd351f.png\" alt=\"image.png\"></p>\n<p>不过这边拿到的是 tid，我们要转换成 pid，可以通过 readlink 来找到 pidreadlink -f /proc/*/task/tid/../..。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/235332789b2e473ebfb1aa19880a4242.png\" alt=\"image.png\"></p>\n<p>找到 pid 之后就可以看这个进程具体的读写情况cat /proc/pid/io</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/4e9e0e65e2f2498baf3d4ffb58cede5e.png\" alt=\"image.png\"></p>\n<p>我们还可以通过 lsof 命令来确定具体的文件读写情况lsof -p pid</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/eb46b64979434f62b96245f4682a51c1.png\" alt=\"image.png\"></p>\n<h4 id=\"内存\">内存</h4>\n<p>内存问题排查起来相对比 CPU 麻烦一些，场景也比较多。主要包括 OOM、GC 问题和堆外内存。一般来讲，我们会先用free命令先来检查一发内存的各种情况。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/8e4e7c787d8840949eb04d4021fd464d.png\" alt=\"image.png\"></p>\n<h4 id=\"堆内内存\">堆内内存</h4>\n<p>内存问题大多还都是堆内内存问题。表象上主要分为 OOM 和 Stack Overflow。</p>\n<h4 id=\"oom\">OOM</h4>\n<p>JMV 中的内存不足，OOM 大致可以分为以下几种：</p>\n<p>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</p>\n<p>这个意思是没有足够的内存空间给线程分配 Java 栈，基本上还是线程池代码写的有问题，比如说忘记 shutdown，所以说应该首先从代码层面来寻找问题，使用 jstack 或者 jmap。如果一切都正常，JVM 方面可以通过指定Xss来减少单个 thread stack 的大小。另外也可以在系统层面，可以通过修改/etc/security/limits.confnofile 和 nproc 来增大 os 对线程的限制</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/2c72af00da7b4aaba4099b915bfdde3b.png\" alt=\"image.png\"></p>\n<p>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</p>\n<p>这个意思是堆的内存占用已经达到-Xmx 设置的最大值，应该是最常见的 OOM 错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过 jstack 和 jmap 去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。</p>\n<p>Caused by: java.lang.OutOfMemoryError: Meta space</p>\n<p>这个意思是元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值，排查思路和上面的一致，参数方面可以通过XX:MaxPermSize来进行调整(这里就不说 1.8 以前的永久代了)。</p>\n<h4 id=\"stack-overflow\">Stack Overflow</h4>\n<p>栈内存溢出，这个大家见到也比较多。</p>\n<p>Exception in thread &quot;main&quot; java.lang.StackOverflowError</p>\n<p>表示线程栈需要的内存大于 Xss 值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起 OOM。</p>\n<h4 id=\"使用-jmap-定位代码内存泄漏\">使用 JMAP 定位代码内存泄漏</h4>\n<p>上述关于 OOM 和 Stack Overflo 的代码排查方面，我们一般使用 JMAPjmap -dump:format=b,file=filename pid来导出 dump 文件</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/db465142011f4e1685e175d0a04db8d6.png\" alt=\"image.png\"></p>\n<p>通过 mat(Eclipse Memory Analysis Tools)导入 dump 文件进行分析，内存泄漏问题一般我们直接选 Leak Suspects 即可，mat 给出了内存泄漏的建议。另外也可以选择 Top Consumers 来查看最大对象报告。和线程相关的问题可以选择 thread overview 进行分析。除此之外就是选择 Histogram 类概览来自己慢慢分析，大家可以搜搜 mat 的相关教程。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/47c7b39e77a0471e80262e6ade5133ed.png\" alt=\"image.png\"></p>\n<p>日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都 new 对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发 gc；ByteBuffer 缓存分配不合理等都会造成代码 OOM。</p>\n<p>另一方面，我们可以在启动参数中指定-XX:+HeapDumpOnOutOfMemoryError来保存 OOM 时的 dump 文件。</p>\n<h4 id=\"gc-问题和线程\">gc 问题和线程</h4>\n<p>gc 问题除了影响 CPU 也会影响内存，排查思路也是一致的。一般先使用 jstat 来查看分代变化情况，比如 youngGC 或者 fullGC 次数是不是太多呀；EU、OU 等指标增长是不是异常呀等。</p>\n<p>线程的话太多而且不被及时 gc 也会引发 oom，大部分就是之前说的unable to create new native thread。除了 jstack 细细分析 dump 文件外，我们一般先会看下总体线程，通过pstreee -p pid |wc -l。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/c71f1d2b672d4a64a46db2053357b973.png\" alt=\"image.png\"></p>\n<p>或者直接通过查看/proc/pid/task的数量即为线程数量。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/3607e378a2774679a7ff8964164d31ba.png\" alt=\"image.png\"></p>\n<h4 id=\"堆外内存\">堆外内存</h4>\n<p>如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用 Netty 导致的，那错误日志里可能会出现OutOfDirectMemoryError错误，如果直接是 DirectByteBuffer，那会报OutOfMemoryError: Direct buffer memory。</p>\n<p>堆外内存溢出往往是和 NIO 的使用相关，一般我们先通过 pmap 来查看下进程占用的内存情况pmap -x pid | sort -rn -k3 | head -30，这段意思是查看对应 pid 倒序前 30 大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/e1a9f722b6234ecab47cec2cca393680.png\" alt=\"image.png\"></p>\n<p>我们如果确定有可疑的内存端，需要通过 gdb 来分析gdb --batch --pid {pid} -ex &quot;dump memory filename.dump {内存起始地址} {内存起始地址+内存块大小}&quot;</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/c632856b2f4945f195a0bc9f958e314d.png\" alt=\"image.png\"></p>\n<p>获取 dump 文件后可用 heaxdump 进行查看hexdump -C filename | less，不过大多数看到的都是二进制乱码。</p>\n<p>NMT 是 Java7U40 引入的 HotSpot 新特性，配合 jcmd 命令我们就可以看到具体内存组成了。需要在启动参数中加入 -XX:NativeMemoryTracking=summary 或者 -XX:NativeMemoryTracking=detail，会有略微性能损耗。</p>\n<p>一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线jcmd pid VM.native_memory baseline。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/4a6cf290ef724e2aa9b0f7d49efa4df6.png\" alt=\"image.png\"></p>\n<p>然后等放一段时间后再去看看内存增长的情况，通过jcmd pid VM.native_memory detail.diff(summary.diff)做一下 summary 或者 detail 级别的 diff。\n<img src=\"http://oss.osalien.com/dbblog/20200927/41290e8a8eba44eda50321ccbf0200ee.png\" alt=\"image.png\"></p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/5a5a1aacb7724a88a02a969fe47c6ddf.png\" alt=\"image.png\"></p>\n<p>可以看到 jcmd 分析出来的内存十分详细，包括堆内、线程以及 gc(所以上述其他内存异常其实都可以用 nmt 来分析)，这边堆外内存我们重点关注 Internal 的内存增长，如果增长十分明显的话那就是有问题了。</p>\n<p>detail 级别的话还会有具体内存段的增长情况，如下图。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/7d33fe50bc084327a175d3349a073410.png\" alt=\"image.png\"></p>\n<p>此外在系统层面，我们还可以使用 strace 命令来监控内存分配 strace -f -e &quot;brk,mmap,munmap&quot; -p pid</p>\n<p>这边内存分配信息主要包括了 pid 和内存地址。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/199815eca3ec4628bf708b8efe94c442.png\" alt=\"image.png\"></p>\n<p>不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如 DirectByteBuffer 分配内存的话，是需要 full GC 或者手动 system.gc 来进行回收的(所以最好不要使用-XX:+DisableExplicitGC)。那么其实我们可以跟踪一下 DirectByteBuffer 对象的内存情况，通过jmap -histo:live pid手动触发 fullGC 来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过-XX:MaxDirectMemorySize进行调整。如果没有什么变化，那就要使用 jmap 去分析那些不能被 gc 的对象，以及和 DirectByteBuffer 之间的引用关系了。</p>\n<h4 id=\"gc-问题\">GC 问题</h4>\n<p>堆内内存泄漏总是和 GC 异常相伴。不过 GC 问题不只是和内存问题相关，还有可能引起 CPU 负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下 GC 相关问题。</p>\n<p>我们在 CPU 章介绍了使用 jstat 来获取当前 GC 分代变化信息。而更多时候，我们是通过 GC 日志来排查问题的，在启动参数中加上-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps来开启 GC 日志。</p>\n<p>常见的 Young GC、Full GC 日志含义在此就不做赘述了。</p>\n<p>针对 gc 日志，我们就能大致推断出 youngGC 与 fullGC 是否过于频繁或者耗时过长，从而对症下药。我们下面将对 G1 垃圾收集器来做分析，这边也建议大家使用 G1-XX:+UseG1GC。</p>\n<h4 id=\"younggc-过频繁\">youngGC 过频繁</h4>\n<p>youngGC 频繁一般是短周期小对象较多，先考虑是不是 Eden 区/新生代设置的太小了，看能否通过调整-Xmn、-XX:SurvivorRatio 等参数设置来解决问题。如果参数正常，但是 young gc 频率还是太高，就需要使用 Jmap 和 MAT 对 dump 文件进行进一步排查了。</p>\n<h4 id=\"younggc-耗时过长\">youngGC 耗时过长</h4>\n<p>耗时过长问题就要看 GC 日志里耗时耗在哪一块了。以 G1 日志为例，可以关注 Root Scanning、Object Copy、Ref Proc 等阶段。Ref Proc 耗时长，就要注意引用相关的对象。Root Scanning 耗时长，就要注意线程数、跨代引用。Object Copy 则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的 Root Scanning 和正常时间段比增长较多，那就是起的线程太多了。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/947a26cadcc04bc8a870144179c62c39.png\" alt=\"image.png\"></p>\n<h4 id=\"触发-fullgc\">触发 fullGC</h4>\n<p>G1 中更多的还是 mixedGC，但 mixedGC 可以和 youngGC 思路一样去排查。触发 fullGC 了一般都会有问题，G1 会退化使用 Serial 收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。</p>\n<p>fullGC 的原因可能包括以下这些，以及参数调整方面的一些思路：</p>\n<ul>\n<li><p>并发阶段失败：在并发标记阶段，MixGC 之前老年代就被填满了，那么这时候 G1 就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数-XX:ConcGCThreads。</p>\n</li>\n<li><p>晋升失败：在 GC 的时候没有足够的内存供存活/晋升对象使用，所以触发了 Full GC。这时候可以通过-XX:G1ReservePercent来增加预留内存百分比，减少-XX:InitiatingHeapOccupancyPercent来提前启动标记，-XX:ConcGCThreads来增加标记线程数也是可以的。</p>\n</li>\n<li><p>大对象分配失败：大对象找不到合适的 region 空间进行分配，就会进行 fullGC，这种情况下可以增大内存或者增大-XX:G1HeapRegionSize。</p>\n</li>\n<li><p>程序主动执行 System.gc()：不要随便写就对了。</p>\n</li>\n</ul>\n<p>另外，我们可以在启动参数中配置-XX:HeapDumpPath=/xxx/dump.hprof来 dump fullGC 相关的文件，并通过 jinfo 来进行 gc 前后的 dump</p>\n<pre><code>jinfo -flag +HeapDumpBeforeFullGC pid\njinfo -flag +HeapDumpAfterFullGC pid</code></pre><p>这样得到 2 份 dump 文件，对比后主要关注被 gc 掉的问题对象来定位问题。</p>\n<h4 id=\"网络\">网络</h4>\n<p>涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从 tcp 层、应用层以及工具的使用等方面进行阐述。</p>\n<h4 id=\"超时\">超时</h4>\n<p>超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。</p>\n<ul>\n<li><p>读写超时。readTimeout/writeTimeout，有些框架叫做 so_timeout 或者 socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa 的超时指的也是读超时。读写超时一般都只针对客户端设置。</p>\n</li>\n<li><p>连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边 connectionTimeout 就有些五花八门了，Jetty 中表示空闲连接清理时间，Tomcat 则表示连接维持的最大时间。</p>\n</li>\n<li><p>其他。包括连接获取超时 connectionAcquireTimeout 和空闲连接清理超时 idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。</p>\n</li>\n</ul>\n<p>我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。</p>\n<p>在实际开发中，我们关心最多的应该是接口的读写超时了。</p>\n<p>如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的 tcp 连接。而如果接口设置的过短，那么接口超时就会非常频繁。</p>\n<p>服务端接口明明 rt 降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。</p>\n<h4 id=\"tcp-队列溢出\">TCP 队列溢出</h4>\n<p>tcp 队列溢出是个相对底层的错误，它可能会造成超时、rst 等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/5a70a907d7e947709d3cc8f98c3a2af5.png\" alt=\"image.png\"></p>\n<p>如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在 server 收到 client 的 syn 后，把消息放到 syns queue，回复 syn+ack 给 client，server 收到 client 的 ack，如果这时 accept queue 没满，那就从 syns queue 拿出暂存的信息放入 accept queue 中，否则按 tcp_abort_on_overflow 指示的执行。</p>\n<p>tcp_abort_on_overflow 0 表示如果三次握手第三步的时候 accept queue 满了那么 server 扔掉 client 发过来的 ack。tcp_abort_on_overflow 1 则表示第三步的时候如果全连接队列满了，server 发送一个 rst 包给 client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多connection reset / connection reset by peer。</p>\n<p>那么在实际开发中，我们怎么能快速定位到 tcp 队列溢出呢？</p>\n<p>netstat 命令，执行 netstat -s | egrep &quot;listen|LISTEN&quot;</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/7429f7ac0a034cce958bb62d5404599d.png\" alt=\"image.png\"></p>\n<p>如上图所示，overflowed 表示全连接队列溢出的次数，sockets dropped 表示半连接队列溢出的次数。</p>\n<h4 id=\"ss-命令，执行-ss--lnt\">ss 命令，执行 ss -lnt</h4>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/528542ca39d84222b64ee4479f373e07.png\" alt=\"image.png\"></p>\n<p>上面看到 Send-Q 表示第三列的 listen 端口上的全连接队列最大为 5，第一列 Recv-Q 为全连接队列当前使用了多少。</p>\n<p>接着我们看看怎么设置全连接、半连接队列大小吧：</p>\n<p>全连接队列的大小取决于 min(backlog, somaxconn)。backlog 是在 socket 创建的时候传入的，somaxconn 是一个 os 级别的系统参数。而半连接队列的大小取决于 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。</p>\n<p>在日常开发中，我们往往使用 servlet 容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在 Tomcat 中 backlog 叫做acceptCount，在 Jetty 里面则是acceptQueueSize。</p>\n<h4 id=\"rst-异常\">RST 异常</h4>\n<p>RST 包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。</p>\n<p>在实际开发中，我们往往会看到connection reset / connection reset by peer错误，这种情况就是 RST 包导致的。</p>\n<h4 id=\"端口不存在\">端口不存在</h4>\n<p>如果像不存在的端口发出建立连接 SYN 请求，那么服务端发现自己并没有这个端口则会直接返回一个 RST 报文，用于中断连接。</p>\n<h4 id=\"主动代替-fin-终止连接\">主动代替 FIN 终止连接</h4>\n<p>一般来说，正常的连接关闭都是需要通过 FIN 报文实现，然而我们也可以用 RST 报文来代替 FIN，表示直接终止连接。实际开发中，可设置 SO_LINGER 数值来控制，这种往往是故意的，来跳过 TIMED_WAIT，提供交互效率，不闲就慎用。</p>\n<p><strong>客户端或服务端有一边发生了异常，该方向对端发送 RST 以告知关闭连接</strong></p>\n<p>我们上面讲的 tcp 队列溢出发送 RST 包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。</p>\n<p><strong>接收到的 TCP 报文不在已知的 TCP 连接内</strong></p>\n<p>比如，一方机器由于网络实在太差 TCP 报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的 TCP 报文，但由于对应的 TCP 连接已不存在，那么会直接发一个 RST 包以便开启新的连接。</p>\n<p><strong>一方长期未收到另一方的确认报文，在一定时间或重传次数后发出 RST 报文</strong></p>\n<p>这种大多也和网络环境相关了，网络环境差可能会导致更多的 RST 报文。</p>\n<p>之前说过 RST 报文多会导致程序报错，在一个已关闭的连接上读操作会报connection reset，而在一个已关闭的连接上写操作则会报connection reset by peer。通常我们可能还会看到broken pipe错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到 RST，报出connection reset错后继续读写数据报的错，这个在 glibc 源码注释中也有介绍。</p>\n<p>我们在排查故障时候怎么确定有 RST 包的存在呢？当然是使用 tcpdump 命令进行抓包，并使用 wireshark 进行简单分析了。tcpdump -i en0 tcp -w xxx.cap，en0 表示监听的网卡。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/940bcfd015b04240bf8bc050ece98c8d.png\" alt=\"image.png\"></p>\n<p>接下来我们通过 wireshark 打开抓到的包，可能就能看到如下图所示，红色的就表示 RST 包了。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/7a07046d13824178980f1dcc28ff227f.png\" alt=\"image.png\"></p>\n<h4 id=\"time_wait-和-close_wait\">TIME_WAIT 和 CLOSE_WAIT</h4>\n<p>TIME_WAIT 和 CLOSE_WAIT 是啥意思相信大家都知道。</p>\n<p>在线上时，我们可以直接用命令netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;来查看 time-wait 和 close_wait 的数量</p>\n<p>用 ss 命令会更快ss -ant | awk &#39;{++S[$1]} END {for(a in S) print a, S[a]}&#39;</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200927/2e9d2d2362704767bcf15172774c2ac3.png\" alt=\"image.png\"></p>\n<h4 id=\"time_wait\">TIME_WAIT</h4>\n<p>time_wait 的存在一是为了丢失的数据包被后面连接复用，二是为了在 2MSL 的时间范围内正常关闭连接。它的存在其实会大大减少 RST 包的出现。</p>\n<p>过多的 time_wait 在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:</p>\n<pre><code>#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭\n\nnet.ipv4.tcp_tw_reuse = 1\n\n#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭\n\nnet.ipv4.tcp_tw_recycle = 1</code></pre><p>当然我们不要忘记在 NAT 环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小tcp_max_tw_buckets，超过这个数的 time_wait 都会被干掉，不过这也会导致报time wait bucket table overflow的错。</p>\n<h4 id=\"close_wait\">CLOSE_WAIT</h4>\n<p>close_wait 往往都是因为应用程序写的有问题，没有在 ACK 后再次发起 FIN 报文。close_wait 出现的概率甚至比 time_wait 要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。</p>\n<p>想要定位这类问题，最好是通过 jstack 来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。</p>\n<p>开发同学说应用上线后 CLOSE_WAIT 就一直增多，直到挂掉为止，jstack 后找到比较可疑的堆栈是大部分线程都卡在了countdownlatch.await方法，找开发同学了解后得知使用了多线程但是确没有 catch 异常，修改后发现异常仅仅是最简单的升级 sdk 后常出现的class not found。</p>\n',117,0,22,NULL,NULL,'2020-09-26 23:15:20','2020-09-30 01:04:53',1,'32,42',1,0),(10,'一文讲清楚互斥锁、自旋锁、读写锁、悲观锁、乐观锁','高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。\n所以，知道各种锁的开销，以及应用场景是很有必要的。','小林coding','### 前言\n生活中用到的锁，用途都比较简单粗暴，上锁基本是为了防止外人进来、电动车被偷等等。\n\n但生活中也不是没有 BUG 的，比如加锁的电动车在「广西 - 窃·格瓦拉」面前，锁就是形同虚设，只要他愿意，他就可以轻轻松松地把你电动车给「顺走」，不然打工怎么会是他这辈子不可能的事情呢？牛逼之人，必有牛逼之处。\n\n![image.png](http://oss.osalien.com/dbblog/20200928/d6b0a966913c41e9bd315254527c3d1f.png)\n\n那在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。\n\n如何用好锁，也是程序员的基本素养之一了。\n\n高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。\n\n所以，知道各种锁的开销，以及应用场景是很有必要的。\n\n接下来，就谈一谈常见的这几种锁：\n\n![image.png](http://oss.osalien.com/dbblog/20200928/9a49b16e156e459fb028c7540450093d.png)\n\n----\n\n### 正文\n多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。\n\n最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。\n\n如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。\n\n所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。\n\n对症下药，才能减少锁对高并发性能的影响。\n\n那接下来，针对不同的应用场景，谈一谈「**互斥锁、自旋锁、读写锁、乐观锁、悲观锁**」的选择和使用。\n\n#### 互斥锁与自旋锁：谁更轻松自如？\n\n最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。\n\n加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。\n\n当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：\n\n- **互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；\n- **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁；\n\n互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，**既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。**\n\n**对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的**。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：\n\n![image.png](http://oss.osalien.com/dbblog/20200928/0ff0f991a9d14bd2a1b41ba1e8395487.png)\n\n所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。\n\n那这个开销成本是什么呢？会有**两次线程上下文切换的成本**：\n\n当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；\n接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。\n线程的上下文切换的是什么？当两个线程是属于同一个进程，**因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。**\n\n上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。\n\n所以，**如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。**\n\n自旋锁是通过 CPU 提供的 **CAS** 函数（**Compare And Swap**），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。\n\n一般加锁的过程，包含两个步骤：\n\n- 第一步，查看锁的状态，如果锁是空闲的，则执行第二步；\n- 第二步，将锁设置为当前线程持有；\nCAS 函数就把这两个步骤合并成一条硬件级指令，形成**原子指令**，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。\n\n使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 **while**循环等待实现，不过最好是使用 CPU 提供的 **PAUSE**指令来实现「忙等待」，因为可以减少循环等待时的耗电量。\n\n自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。**需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。**\n\n自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。\n\n自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：**当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对。**\n\n它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。\n\n---\n\n#### 读写锁：读和写还有优先级区分？\n\n读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。\n\n所以，**读写锁适用于能明确区分读操作和写操作的场景。**\n\n读写锁的工作原理是：\n\n- 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。\n- 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。\n所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。\n\n知道了读写锁的工作原理后，我们可以发现，**读写锁在读多写少的场景，能发挥出优势。**\n\n另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。\n\n读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：\n\n![image.png](http://oss.osalien.com/dbblog/20200928/02c9cf3fe63a4cb088c24082441e2cdc.png)\n\n而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：\n\n![image.png](http://oss.osalien.com/dbblog/20200928/f8acc3a9e69d45fdace7b7da76388fcd.png)\n\n读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。\n\n写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。\n\n既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。\n\n**公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。**\n\n互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。\n\n----\n\n#### 乐观锁与悲观锁：做事的心态有何不同？\n\n前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。\n\n悲观锁做事比较悲观，它认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。**\n\n那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。\n\n乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。**\n\n放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。\n\n可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现**乐观锁全程并没有加锁，所以它也叫无锁编程。**\n\n这里举一个场景例子：在线文档。\n\n我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。\n\n那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。\n\n怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。\n\n服务端要怎么验证是否冲突了呢？通常方案如下：\n\n- 由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；\n- 当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。\n\n实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。\n\n乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。**\n\n----\n\n### 总结\n\n开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。\n\n如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。\n\n如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。\n\n互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。\n\n另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。\n\n相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。\n\n但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。\n\n不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。\n\n','<h3 id=\"前言\">前言</h3>\n<p>生活中用到的锁，用途都比较简单粗暴，上锁基本是为了防止外人进来、电动车被偷等等。</p>\n<p>但生活中也不是没有 BUG 的，比如加锁的电动车在「广西 - 窃·格瓦拉」面前，锁就是形同虚设，只要他愿意，他就可以轻轻松松地把你电动车给「顺走」，不然打工怎么会是他这辈子不可能的事情呢？牛逼之人，必有牛逼之处。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200928/d6b0a966913c41e9bd315254527c3d1f.png\" alt=\"image.png\"></p>\n<p>那在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。</p>\n<p>如何用好锁，也是程序员的基本素养之一了。</p>\n<p>高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。</p>\n<p>所以，知道各种锁的开销，以及应用场景是很有必要的。</p>\n<p>接下来，就谈一谈常见的这几种锁：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200928/9a49b16e156e459fb028c7540450093d.png\" alt=\"image.png\"></p>\n<hr>\n<h3 id=\"正文\">正文</h3>\n<p>多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。</p>\n<p>最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。</p>\n<p>如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。</p>\n<p>所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。</p>\n<p>对症下药，才能减少锁对高并发性能的影响。</p>\n<p>那接下来，针对不同的应用场景，谈一谈「<strong>互斥锁、自旋锁、读写锁、乐观锁、悲观锁</strong>」的选择和使用。</p>\n<h4 id=\"互斥锁与自旋锁：谁更轻松自如？\">互斥锁与自旋锁：谁更轻松自如？</h4>\n<p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。</p>\n<p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p>\n<p>当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：</p>\n<ul>\n<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>\n<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>\n</ul>\n<p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。</strong></p>\n<p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200928/0ff0f991a9d14bd2a1b41ba1e8395487.png\" alt=\"image.png\"></p>\n<p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。</p>\n<p>那这个开销成本是什么呢？会有<strong>两次线程上下文切换的成本</strong>：</p>\n<p>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；\n接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。\n线程的上下文切换的是什么？当两个线程是属于同一个进程，<strong>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</strong></p>\n<p>上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。</p>\n<p>所以，<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p>\n<p>自旋锁是通过 CPU 提供的 <strong>CAS</strong> 函数（<strong>Compare And Swap</strong>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p>\n<p>一般加锁的过程，包含两个步骤：</p>\n<ul>\n<li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li>\n<li>第二步，将锁设置为当前线程持有；\nCAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</li>\n</ul>\n<p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <strong>while</strong>循环等待实现，不过最好是使用 CPU 提供的 <strong>PAUSE</strong>指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p>\n<p>自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p>\n<p>自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p>\n<p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对。</strong></p>\n<p>它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。</p>\n<hr>\n<h4 id=\"读写锁：读和写还有优先级区分？\">读写锁：读和写还有优先级区分？</h4>\n<p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p>\n<p>所以，<strong>读写锁适用于能明确区分读操作和写操作的场景。</strong></p>\n<p>读写锁的工作原理是：</p>\n<ul>\n<li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li>\n<li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。\n所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。</li>\n</ul>\n<p>知道了读写锁的工作原理后，我们可以发现，<strong>读写锁在读多写少的场景，能发挥出优势。</strong></p>\n<p>另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。</p>\n<p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200928/02c9cf3fe63a4cb088c24082441e2cdc.png\" alt=\"image.png\"></p>\n<p>而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200928/f8acc3a9e69d45fdace7b7da76388fcd.png\" alt=\"image.png\"></p>\n<p>读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。</p>\n<p>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。</p>\n<p>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。</p>\n<p><strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p>\n<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>\n<hr>\n<h4 id=\"乐观锁与悲观锁：做事的心态有何不同？\">乐观锁与悲观锁：做事的心态有何不同？</h4>\n<p>前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。</p>\n<p>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</strong></p>\n<p>那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</p>\n<p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</strong></p>\n<p>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。</p>\n<p>可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现<strong>乐观锁全程并没有加锁，所以它也叫无锁编程。</strong></p>\n<p>这里举一个场景例子：在线文档。</p>\n<p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p>\n<p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p>\n<p>怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。</p>\n<p>服务端要怎么验证是否冲突了呢？通常方案如下：</p>\n<ul>\n<li>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</li>\n<li>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。</li>\n</ul>\n<p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p>\n<p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p>\n<hr>\n<h3 id=\"总结\">总结</h3>\n<p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p>\n<p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p>\n<p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。</p>\n<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>\n<p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p>\n<p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p>\n<p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p>\n<p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p>\n',215,0,34,NULL,NULL,'2020-09-27 22:43:19','2020-09-30 00:48:35',1,'32,42',1,0),(11,'Java图形验证码支持gif、中文、算术等','图形验证码是最经典，也是最常用的验证方式。今天介绍一个非常不错的类库：Java图形验证码，支持gif、中文、算术等类型，可用于Java Web、JavaSE等项目。',' JAVA乐园','图形验证码是最经典，也是最常用的验证方式。今天介绍一个非常不错的类库：Java图形验证码，支持gif、中文、算术等类型，可用于Java Web、JavaSE等项目。\n\n官网：\n```\nhttps://gitee.com/whvse/EasyCaptcha\n```\n效果图：\n\n![image.png](http://oss.osalien.com/dbblog/20200929/5db8f7a3297645c393145c983f2e8272.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/26bb7b26e582465e9b09b7f9735348bb.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/02ab3d266f0b43f0b9d19ed62ae53ab6.png)\n\n![msFvb6.gif](http://oss.osalien.com/dbblog/20200929/52be7ba2332041f1abfd7227c4324066.gif)&emsp;![msFXK1.gif](http://oss.osalien.com/dbblog/20200929/3f2b63cfa9ab4b35a1c6c5a0bdbaf58f.gif)&emsp;![msFzVK.gif](http://oss.osalien.com/dbblog/20200929/81d7a8d9455b4799b9c640ce1e746abd.gif)\n\n算术类型：\n\n![image.png](http://oss.osalien.com/dbblog/20200929/9eadd044c4c5409dae039cbf8418f66f.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/f60589d25ce141e08f62daddb2228e12.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/9fe6e08842434b01bab6d7b7b3cfa604.png)\n\n中文类型：\n\n![image.png](http://oss.osalien.com/dbblog/20200929/c633a03a8a6b4ed0a82b9bf2eea1242f.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/5a2242c00c894af88b139ef3e2ff268a.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/611b85fb037843f084de98902f434930.png)\n\n内置字体：\n\n![image.png](http://oss.osalien.com/dbblog/20200929/0176cc600a554e0aad31eafe09a1c66a.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/30ee91ee22554d39a3f125cd998d2c23.png)&emsp;![image.png](http://oss.osalien.com/dbblog/20200929/576f09b3e1954019bcae81b0a5fce5e9.png)\n\n#### 0x01：项目引入easy-captcha\n```\n<dependencies>\n   <dependency>\n      <groupId>com.github.whvcse</groupId>\n      <artifactId>easy-captcha</artifactId>\n      <version>1.6.2</version>\n   </dependency>\n</dependencies>\n```\n#### 0x02：SpringBoot项目创建图形验证码\n\n前后端分离项目中建议不要存储在session中；而使用分布式session，存储在redis中，redis存储需要一个key，key一同返回给前端用于验证输入。\n```\n@Controller\npublic class CaptchaController {\n\n    @Autowired\n    private RedisUtil redisUtil;\n\n    @ResponseBody\n    @RequestMapping(\"/vcode/captcha\")\n    public JsonResult captcha(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        SpecCaptcha specCaptcha = new SpecCaptcha(130, 48, 5);\n        String verCode = specCaptcha.text().toLowerCase();\n        String key = UUID.randomUUID().toString();\n        // 存入redis并设置过期时间为30分钟\n        redisUtil.setEx(key, verCode, 30, TimeUnit.MINUTES);\n        // 将key和base64返回给前端\n        return JsonResult.ok().put(\"key\", key).put(\"image\", specCaptcha.toBase64());\n    }\n\n    @ResponseBody\n    @PostMapping(\"/vcode/vaild\")\n    public JsonResult login(String username,String password,String verCode,String verKey){\n        // 获取redis中的验证码\n        String redisCode = redisUtil.get(verKey);\n        // 判断验证码\n        if (verCode==null || !redisCode.equals(verCode.trim().toLowerCase())) {\n            return JsonResult.error(\"验证码不正确\");\n        }\n    }  \n}\n```\n#### 0x03：前端使用ajax获取验证码并验证\n```\n<img id=\"verImg\" width=\"130px\" height=\"48px\"/>\n\n<script>\n    var verKey;\n    // 获取验证码\n    $.get(\'/vcode/captcha\', function(res) {\n        verKey = res.key;\n        $(\'#verImg\').attr(\'src\', res.image);\n    },\'json\');\n\n    // 登录\n    $.post(\'/vcode/login\', {\n        verKey: verKey,\n        verCode: \'8u6h\',\n        username: \'admin\'，\n        password: \'admin\'\n    }, function(res) {\n        console.log(res);\n    }, \'json\');\n</script>\n```','<p>图形验证码是最经典，也是最常用的验证方式。今天介绍一个非常不错的类库：Java图形验证码，支持gif、中文、算术等类型，可用于Java Web、JavaSE等项目。</p>\n<p>官网：</p>\n<pre><code>https://gitee.com/whvse/EasyCaptcha</code></pre><p>效果图：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200929/5db8f7a3297645c393145c983f2e8272.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/26bb7b26e582465e9b09b7f9735348bb.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/02ab3d266f0b43f0b9d19ed62ae53ab6.png\" alt=\"image.png\"></p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200929/52be7ba2332041f1abfd7227c4324066.gif\" alt=\"msFvb6.gif\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/3f2b63cfa9ab4b35a1c6c5a0bdbaf58f.gif\" alt=\"msFXK1.gif\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/81d7a8d9455b4799b9c640ce1e746abd.gif\" alt=\"msFzVK.gif\"></p>\n<p>算术类型：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200929/9eadd044c4c5409dae039cbf8418f66f.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/f60589d25ce141e08f62daddb2228e12.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/9fe6e08842434b01bab6d7b7b3cfa604.png\" alt=\"image.png\"></p>\n<p>中文类型：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200929/c633a03a8a6b4ed0a82b9bf2eea1242f.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/5a2242c00c894af88b139ef3e2ff268a.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/611b85fb037843f084de98902f434930.png\" alt=\"image.png\"></p>\n<p>内置字体：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20200929/0176cc600a554e0aad31eafe09a1c66a.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/30ee91ee22554d39a3f125cd998d2c23.png\" alt=\"image.png\">&emsp;<img src=\"http://oss.osalien.com/dbblog/20200929/576f09b3e1954019bcae81b0a5fce5e9.png\" alt=\"image.png\"></p>\n<h4 id=\"0x01：项目引入easy-captcha\">0x01：项目引入easy-captcha</h4>\n<pre><code>&lt;dependencies&gt;\n   &lt;dependency&gt;\n      &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt;\n      &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt;\n      &lt;version&gt;1.6.2&lt;/version&gt;\n   &lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre><h4 id=\"0x02：springboot项目创建图形验证码\">0x02：SpringBoot项目创建图形验证码</h4>\n<p>前后端分离项目中建议不要存储在session中；而使用分布式session，存储在redis中，redis存储需要一个key，key一同返回给前端用于验证输入。</p>\n<pre><code>@Controller\npublic class CaptchaController {\n\n    @Autowired\n    private RedisUtil redisUtil;\n\n    @ResponseBody\n    @RequestMapping(&quot;/vcode/captcha&quot;)\n    public JsonResult captcha(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        SpecCaptcha specCaptcha = new SpecCaptcha(130, 48, 5);\n        String verCode = specCaptcha.text().toLowerCase();\n        String key = UUID.randomUUID().toString();\n        // 存入redis并设置过期时间为30分钟\n        redisUtil.setEx(key, verCode, 30, TimeUnit.MINUTES);\n        // 将key和base64返回给前端\n        return JsonResult.ok().put(&quot;key&quot;, key).put(&quot;image&quot;, specCaptcha.toBase64());\n    }\n\n    @ResponseBody\n    @PostMapping(&quot;/vcode/vaild&quot;)\n    public JsonResult login(String username,String password,String verCode,String verKey){\n        // 获取redis中的验证码\n        String redisCode = redisUtil.get(verKey);\n        // 判断验证码\n        if (verCode==null || !redisCode.equals(verCode.trim().toLowerCase())) {\n            return JsonResult.error(&quot;验证码不正确&quot;);\n        }\n    }  \n}</code></pre><h4 id=\"0x03：前端使用ajax获取验证码并验证\">0x03：前端使用ajax获取验证码并验证</h4>\n<pre><code>&lt;img id=&quot;verImg&quot; width=&quot;130px&quot; height=&quot;48px&quot;/&gt;\n\n&lt;script&gt;\n    var verKey;\n    // 获取验证码\n    $.get(&#39;/vcode/captcha&#39;, function(res) {\n        verKey = res.key;\n        $(&#39;#verImg&#39;).attr(&#39;src&#39;, res.image);\n    },&#39;json&#39;);\n\n    // 登录\n    $.post(&#39;/vcode/login&#39;, {\n        verKey: verKey,\n        verCode: &#39;8u6h&#39;,\n        username: &#39;admin&#39;，\n        password: &#39;admin&#39;\n    }, function(res) {\n        console.log(res);\n    }, &#39;json&#39;);\n&lt;/script&gt;</code></pre>',27,0,0,NULL,NULL,'2020-09-28 19:16:18','2020-09-30 00:48:09',0,'32,43,50',1,0),(12,'各种OOM代码样例及解决方法','针对目前大家对OOM的类型不太熟悉，那么来总结一下各种OOM出现的情况以及解决方法。把各种OOM的情况列出来，然后逐一进行代码编写复现和提供解决方法。','JAVA乐园','针对目前大家对OOM的类型不太熟悉，那么来总结一下各种OOM出现的情况以及解决方法。把各种OOM的情况列出来，然后逐一进行代码编写复现和提供解决方法。\n\n1. 堆溢出-java.lang.OutOfMemoryError: Java heap space。\n2. 栈溢出-java.lang.OutOfMemorryError。\n3. 栈溢出-java.lang.StackOverFlowError。\n4. 元信息溢出-java.lang.OutOfMemoryError: Metaspace。\n5. 直接内存溢出-java.lang.OutOfMemoryError: Direct buffer memory。\n6. GC超限-java.lang.OutOfMemoryError: GC overhead limit exceeded。\n\n### 0x01: 堆溢出\n\n堆溢出异常，相信大家很常见。即堆内对象不能进行回收了，堆内存持续增大，这样达到了堆内存的最大值，数据满了，所以就出来了。我们直接放溢出的代码样例。需要设置好idea的VM Options: -Xmx100m，这样设置为最大堆内存，这样运行起来就很快就出来错误了。\n\n```\npackage oom;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class HeapOOM {\n\n    static class OOMObject {\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        List<OOMObject> list = new ArrayList<>();\n\n        while(true) {\n//            TimeUnit.MILLISECONDS.sleep(1);\n            list.add(new OOMObject());\n        }\n    }\n\n}\n```\n\n运行的异常如下，代码直接就出来我们看到的异常了。\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xmx100m -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.HeapOOM\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n    at java.util.Arrays.copyOf(Arrays.java:3210)\n    at java.util.Arrays.copyOf(Arrays.java:3181)\n    at java.util.ArrayList.grow(ArrayList.java:261)\n    at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)\n    at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)\n    at java.util.ArrayList.add(ArrayList.java:458)\n    at oom.HeapOOM.main(HeapOOM.java:21)\n\nProcess finished with exit code 1\n```\n\n细心的小伙伴可以发现代码中设置了一个休眠，目的是看一下堆内存的结构和数据图。将休眠代码打开，然后打开JDK自带的jconsole命令，连接上之后看一下概览图，通过下图发现堆内存持续不断的增长。\n\n![image.png](http://oss.osalien.com/dbblog/20201009/ce46094ddf10467497bdeb3df7f38ec8.png)\n\n打开内存界面，看一下内存，然后点一下GC按钮，这个时候会有一些类进行回收，但是还是会继续增长，看一下下面的图。\n\n![image.png](http://oss.osalien.com/dbblog/20201009/dc15839cbd7e4130b4295b9f80f5ffe5.png)\n\n![image.png](http://oss.osalien.com/dbblog/20201009/f11f47101ba743fda59417cdefeb12c3.png)\n\n点开信息标签看一下。经过几次GC回收之后，类的数据量还是变化不大，说明没有进行回收。\n\n![image.png](http://oss.osalien.com/dbblog/20201009/04e7ebfb652e4092ac48f6cfafd699c0.png)\n\n以上这种情况的解决方法就是找到问题点，分析哪个地方是否存储了大量类没有被回收的情况，通过JMAP命令将线上的堆内存导出来后进行分析。\n\n### 0x02: 栈溢出-OutOfMemorryError\n\n看一下栈溢出的情况，下面的代码就是无限的创建线程，直到没法再创建线程。\n\n```\npackage oom;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Date 2020-07-18\n */\npublic class StackOOM {\n\n    public static void infiniteRun() {\n        while(true) {\n            Thread thread = new Thread(() -> {\n\n                while (true) {\n                    try {\n                        TimeUnit.HOURS.sleep(1);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n            });\n            thread.start();\n        }\n    }\n\n    public static void main(String[] args) {\n        infiniteRun();\n    }\n\n}\n```\n\n抛出来的异常如下，如果真的需要创建线程，我们需要调整帧栈的大小-Xss512k，默认帧栈大小为1M，如果设置小了，可以创建更多线程。\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xss512k -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.StackOOM\nException in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread\n    at java.lang.Thread.start0(Native Method)\n    at java.lang.Thread.start(Thread.java:717)\n    at oom.StackOOM.infiniteRun(StackOOM.java:24)\n    at oom.StackOOM.main(StackOOM.java:29)\n\nProcess finished with exit code 130 (interrupted by signal 2: SIGINT)\n```\n\n以上这种情况是帧栈不够用了，如果出现了这种情况，需要了解什么地方创建了很多线程，线上程序需要用jstack命令，将当前线程的状态导出来放到文件里边，然后将文件上传到fastthread.io网站上进行分析。\n\n### 0x03: 栈溢出-StackOverFlowError\n\n看一下栈溢出的另一种情况，这就是栈的StackOverFlow的情况。下面就是一个死循环递归调用。\n\n```\npackage oom;\n\n/**\n * @Date 2020-07-18\n */\npublic class StackOFE {\n\n    public static void stackOverFlowErrorMethod() {\n        stackOverFlowErrorMethod();\n    }\n\n    public static void main(String[] args) {\n        stackOverFlowErrorMethod();\n    }\n\n}\n```\n\n运行之后出现的错误如下，程序每次递归的时候，程序会把数据结果压入栈，包括里边的指针等，这个时候就需要帧栈大一些才能承受住更多的递归调用。通过-Xss进行设置，上边的例子需要设置小一些，以分配更多的帧栈，这次是一个帧栈需要记录程序数据，所以需要更大的值。\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xss2m -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.StackOFE\nException in thread \"main\" java.lang.StackOverflowError\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n```\n\n遇到上面的情况下，那么就需要通过jstack将线程数据导到文件进行分析。找到递归的点，如果程序就是需要递归的次数的话，那么这个时候就需要增大帧栈的大小以适应程序。\n\n### 0x04: 元信息溢出\n\n元数据区域溢出，元数据区域也成为方法区，存储着类的相关信息，常量池，方法描述符，字段描述符，运行时产生大量的类就会造成这个区域的溢出。我们运行的时候指定一下元数据区域的大小，设置到idea的VM options里边：-XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=30M。\n\n```\npackage oom;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n/**\n * @Date 2020-07-18\n */\npublic class MetaspaceOOM {\n\n    static class OOMObject{}\n\n    public static void main(String[] args) {\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() {\n                public Object intercept(Object obj, Method method,\n                                        Object[] args, MethodProxy proxy) throws Throwable {\n                    return proxy.invokeSuper(obj, args);\n                }\n            });\n            enhancer.create();\n        }\n    }\n\n}\n```\n\n运行的结果如下，元数据信息溢出了。这种情况产生的原因有：通过CBLIG大量生成类，导致Meta信息满了；JDK7的时候使用String.intern()不当，会产生大量常量数据；加载大量的jsp以及动态生成jsp文件。需要调整元数据空间的大小，如果调大了之后还出现了这种异常，我们需要分析哪里出现的溢出并fix掉\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=30M -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar:/Users/huangqingshi/.m2/repository/cglib/cglib/3.2.5/cglib-3.2.5.jar:/Users/huangqingshi/.m2/repository/org/ow2/asm/asm/5.2/asm-5.2.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant/1.9.6/ant-1.9.6.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant-launcher/1.9.6/ant-launcher-1.9.6.jar oom.MetaspaceOOM\nException in thread \"main\" java.lang.OutOfMemoryError: Metaspace\n    at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:345)\n    at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)\n    at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:114)\n    at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:291)\n    at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)\n    at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)\n    at oom.MetaspaceOOM.main(MetaspaceOOM.java:28)\n\nProcess finished with exit code 1\n```\n\n### 0x05: 直接内存溢出\n\n直接内存溢出，除了使用堆内存外，还可能用直接内存，即堆外内存。NIO为了提高性能，避免在Java Heap和native Heap中切换，所以使用直接内存，默认情况下，直接内存的大小和对内存大小一致。堆外内存不受JVM的限制，但是受制于机器整体内存的大小限制。如下代码设置堆最大内存为128m，直接内存为100m，然后我们每次分配1M放到list里边。　\n\n```\n-Xmx128m -XX:MaxDirectMemorySize=100M\n\npackage oom;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @Date 2020-07-18\n */\npublic class DirectBufferOOM {\n\n    public static void main(String[] args) {\n        final int _1M = 1024 * 1024 * 1;\n        List<ByteBuffer> buffers = new ArrayList<>();\n        int count = 1;\n        while (true) {\n            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);\n            buffers.add(byteBuffer);\n            System.out.println(count++);\n        }\n\n    }\n}\n```\n\n这个时候，当输出100次的时候，下次再分配的时候会报OOM-Direct buffer memory。\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xmx128m -XX:MaxDirectMemorySize=100M -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar:/Users/huangqingshi/.m2/repository/cglib/cglib/3.2.5/cglib-3.2.5.jar:/Users/huangqingshi/.m2/repository/org/ow2/asm/asm/5.2/asm-5.2.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant/1.9.6/ant-1.9.6.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant-launcher/1.9.6/ant-launcher-1.9.6.jar oom.DirectBufferOOM\n\nException in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory\n    at java.nio.Bits.reserveMemory(Bits.java:694)\n    at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123)\n    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)\n    at oom.DirectBufferOOM.main(DirectBufferOOM.java:18)\n\nProcess finished with exit code 1\n```\n\n这种情况是我们使用直接内存造成溢出，这个时候我们需要检查一下程序里边是否使用的NIO及NIO，比如Netty，里边的直接内存的配置。\n\n### 0x06: GC超限\n\nJDK1.6之后新增了一个错误类型，如果堆内存太小的时候会报这个错误。如果98%的GC的时候回收不到2%的时候会报这个错误，也就是最小最大内存出现了问题的时候会报这个错误。如果代码配置了最小最大堆内存都为10m。　\n\n```\n-Xmx10m -Xms10m\n\npackage oom;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * @Date 2020-07-18\n */\npublic class GCOverheadOOM {\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(5);\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n            executor.execute(() -> {\n                try {\n                    Thread.sleep(10000);\n                } catch (InterruptedException e) {\n                    //do nothing\n                }\n            });\n        }\n\n    }\n\n}\n```\n\n这个创建了一个线程池，如果线程池执行的时候如果核心线程处理不过来的时候会把数据放到LinkedBlockingQueue里边，也就是堆内存当中。这个时候我们需要检查-Xms -Xmx最小最大堆配置是否合理。再一个dump出现当前内存来分析一下是否使用了大量的循环或使用大量内存代码。\n\n以上就是经常遇到的情况，需要针对出现的不同情况进行分析和处理。','<p>针对目前大家对OOM的类型不太熟悉，那么来总结一下各种OOM出现的情况以及解决方法。把各种OOM的情况列出来，然后逐一进行代码编写复现和提供解决方法。</p>\n<ol>\n<li>堆溢出-java.lang.OutOfMemoryError: Java heap space。</li>\n<li>栈溢出-java.lang.OutOfMemorryError。</li>\n<li>栈溢出-java.lang.StackOverFlowError。</li>\n<li>元信息溢出-java.lang.OutOfMemoryError: Metaspace。</li>\n<li>直接内存溢出-java.lang.OutOfMemoryError: Direct buffer memory。</li>\n<li>GC超限-java.lang.OutOfMemoryError: GC overhead limit exceeded。</li>\n</ol>\n<h3 id=\"0x01-堆溢出\">0x01: 堆溢出</h3>\n<p>堆溢出异常，相信大家很常见。即堆内对象不能进行回收了，堆内存持续增大，这样达到了堆内存的最大值，数据满了，所以就出来了。我们直接放溢出的代码样例。需要设置好idea的VM Options: -Xmx100m，这样设置为最大堆内存，这样运行起来就很快就出来错误了。</p>\n<pre><code>package oom;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class HeapOOM {\n\n    static class OOMObject {\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();\n\n        while(true) {\n//            TimeUnit.MILLISECONDS.sleep(1);\n            list.add(new OOMObject());\n        }\n    }\n\n}</code></pre><p>运行的异常如下，代码直接就出来我们看到的异常了。</p>\n<pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xmx100m -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.HeapOOM\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space\n    at java.util.Arrays.copyOf(Arrays.java:3210)\n    at java.util.Arrays.copyOf(Arrays.java:3181)\n    at java.util.ArrayList.grow(ArrayList.java:261)\n    at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)\n    at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)\n    at java.util.ArrayList.add(ArrayList.java:458)\n    at oom.HeapOOM.main(HeapOOM.java:21)\n\nProcess finished with exit code 1</code></pre><p>细心的小伙伴可以发现代码中设置了一个休眠，目的是看一下堆内存的结构和数据图。将休眠代码打开，然后打开JDK自带的jconsole命令，连接上之后看一下概览图，通过下图发现堆内存持续不断的增长。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201009/ce46094ddf10467497bdeb3df7f38ec8.png\" alt=\"image.png\"></p>\n<p>打开内存界面，看一下内存，然后点一下GC按钮，这个时候会有一些类进行回收，但是还是会继续增长，看一下下面的图。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201009/dc15839cbd7e4130b4295b9f80f5ffe5.png\" alt=\"image.png\"></p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201009/f11f47101ba743fda59417cdefeb12c3.png\" alt=\"image.png\"></p>\n<p>点开信息标签看一下。经过几次GC回收之后，类的数据量还是变化不大，说明没有进行回收。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201009/04e7ebfb652e4092ac48f6cfafd699c0.png\" alt=\"image.png\"></p>\n<p>以上这种情况的解决方法就是找到问题点，分析哪个地方是否存储了大量类没有被回收的情况，通过JMAP命令将线上的堆内存导出来后进行分析。</p>\n<h3 id=\"0x02-栈溢出-outofmemorryerror\">0x02: 栈溢出-OutOfMemorryError</h3>\n<p>看一下栈溢出的情况，下面的代码就是无限的创建线程，直到没法再创建线程。</p>\n<pre><code>package oom;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Date 2020-07-18\n */\npublic class StackOOM {\n\n    public static void infiniteRun() {\n        while(true) {\n            Thread thread = new Thread(() -&gt; {\n\n                while (true) {\n                    try {\n                        TimeUnit.HOURS.sleep(1);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n            });\n            thread.start();\n        }\n    }\n\n    public static void main(String[] args) {\n        infiniteRun();\n    }\n\n}</code></pre><p>抛出来的异常如下，如果真的需要创建线程，我们需要调整帧栈的大小-Xss512k，默认帧栈大小为1M，如果设置小了，可以创建更多线程。</p>\n<pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xss512k -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.StackOOM\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread\n    at java.lang.Thread.start0(Native Method)\n    at java.lang.Thread.start(Thread.java:717)\n    at oom.StackOOM.infiniteRun(StackOOM.java:24)\n    at oom.StackOOM.main(StackOOM.java:29)\n\nProcess finished with exit code 130 (interrupted by signal 2: SIGINT)</code></pre><p>以上这种情况是帧栈不够用了，如果出现了这种情况，需要了解什么地方创建了很多线程，线上程序需要用jstack命令，将当前线程的状态导出来放到文件里边，然后将文件上传到fastthread.io网站上进行分析。</p>\n<h3 id=\"0x03-栈溢出-stackoverflowerror\">0x03: 栈溢出-StackOverFlowError</h3>\n<p>看一下栈溢出的另一种情况，这就是栈的StackOverFlow的情况。下面就是一个死循环递归调用。</p>\n<pre><code>package oom;\n\n/**\n * @Date 2020-07-18\n */\npublic class StackOFE {\n\n    public static void stackOverFlowErrorMethod() {\n        stackOverFlowErrorMethod();\n    }\n\n    public static void main(String[] args) {\n        stackOverFlowErrorMethod();\n    }\n\n}</code></pre><p>运行之后出现的错误如下，程序每次递归的时候，程序会把数据结果压入栈，包括里边的指针等，这个时候就需要帧栈大一些才能承受住更多的递归调用。通过-Xss进行设置，上边的例子需要设置小一些，以分配更多的帧栈，这次是一个帧栈需要记录程序数据，所以需要更大的值。</p>\n<pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xss2m -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar oom.StackOFE\nException in thread &quot;main&quot; java.lang.StackOverflowError\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)\n    at oom.StackOFE.stackOverFlowErrorMethod(StackOFE.java:10)</code></pre><p>遇到上面的情况下，那么就需要通过jstack将线程数据导到文件进行分析。找到递归的点，如果程序就是需要递归的次数的话，那么这个时候就需要增大帧栈的大小以适应程序。</p>\n<h3 id=\"0x04-元信息溢出\">0x04: 元信息溢出</h3>\n<p>元数据区域溢出，元数据区域也成为方法区，存储着类的相关信息，常量池，方法描述符，字段描述符，运行时产生大量的类就会造成这个区域的溢出。我们运行的时候指定一下元数据区域的大小，设置到idea的VM options里边：-XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=30M。</p>\n<pre><code>package oom;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n/**\n * @Date 2020-07-18\n */\npublic class MetaspaceOOM {\n\n    static class OOMObject{}\n\n    public static void main(String[] args) {\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() {\n                public Object intercept(Object obj, Method method,\n                                        Object[] args, MethodProxy proxy) throws Throwable {\n                    return proxy.invokeSuper(obj, args);\n                }\n            });\n            enhancer.create();\n        }\n    }\n\n}</code></pre><p>运行的结果如下，元数据信息溢出了。这种情况产生的原因有：通过CBLIG大量生成类，导致Meta信息满了；JDK7的时候使用String.intern()不当，会产生大量常量数据；加载大量的jsp以及动态生成jsp文件。需要调整元数据空间的大小，如果调大了之后还出现了这种异常，我们需要分析哪里出现的溢出并fix掉</p>\n<pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=30M -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar:/Users/huangqingshi/.m2/repository/cglib/cglib/3.2.5/cglib-3.2.5.jar:/Users/huangqingshi/.m2/repository/org/ow2/asm/asm/5.2/asm-5.2.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant/1.9.6/ant-1.9.6.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant-launcher/1.9.6/ant-launcher-1.9.6.jar oom.MetaspaceOOM\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace\n    at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:345)\n    at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)\n    at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:114)\n    at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:291)\n    at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)\n    at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)\n    at oom.MetaspaceOOM.main(MetaspaceOOM.java:28)\n\nProcess finished with exit code 1</code></pre><h3 id=\"0x05-直接内存溢出\">0x05: 直接内存溢出</h3>\n<p>直接内存溢出，除了使用堆内存外，还可能用直接内存，即堆外内存。NIO为了提高性能，避免在Java Heap和native Heap中切换，所以使用直接内存，默认情况下，直接内存的大小和对内存大小一致。堆外内存不受JVM的限制，但是受制于机器整体内存的大小限制。如下代码设置堆最大内存为128m，直接内存为100m，然后我们每次分配1M放到list里边。　</p>\n<pre><code>-Xmx128m -XX:MaxDirectMemorySize=100M\n\npackage oom;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @Date 2020-07-18\n */\npublic class DirectBufferOOM {\n\n    public static void main(String[] args) {\n        final int _1M = 1024 * 1024 * 1;\n        List&lt;ByteBuffer&gt; buffers = new ArrayList&lt;&gt;();\n        int count = 1;\n        while (true) {\n            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);\n            buffers.add(byteBuffer);\n            System.out.println(count++);\n        }\n\n    }\n}</code></pre><p>这个时候，当输出100次的时候，下次再分配的时候会报OOM-Direct buffer memory。</p>\n<pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java -Xmx128m -XX:MaxDirectMemorySize=100M -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/lib/tools.jar:/Users/huangqingshi/Downloads/flink-project/target/classes:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-java/1.7.2/flink-java-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-core/1.7.2/flink-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-annotations/1.7.2/flink-annotations-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-metrics-core/1.7.2/flink-metrics-core-1.7.2.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/kryo/kryo/2.24.0/kryo-2.24.0.jar:/Users/huangqingshi/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/Users/huangqingshi/.m2/repository/org/objenesis/objenesis/2.1/objenesis-2.1.jar:/Users/huangqingshi/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-asm/5.0.4-5.0/flink-shaded-asm-5.0.4-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-math3/3.5/commons-math3-3.5.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-api/1.7.15/slf4j-api-1.7.15.jar:/Users/huangqingshi/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/force-shading/1.7.2/force-shading-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-streaming-java_2.11/1.7.2/flink-streaming-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-runtime_2.11/1.7.2/flink-runtime_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-queryable-state-client-java_2.11/1.7.2/flink-queryable-state-client-java_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-hadoop-fs/1.7.2/flink-hadoop-fs-1.7.2.jar:/Users/huangqingshi/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-netty/4.1.24.Final-5.0/flink-shaded-netty-4.1.24.Final-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-jackson/2.7.9-5.0/flink-shaded-jackson-2.7.9-5.0.jar:/Users/huangqingshi/.m2/repository/commons-cli/commons-cli/1.3.1/commons-cli-1.3.1.jar:/Users/huangqingshi/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-actor_2.11/2.4.20/akka-actor_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/config/1.3.0/config-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-java8-compat_2.11/0.7.0/scala-java8-compat_2.11-0.7.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-stream_2.11/2.4.20/akka-stream_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/reactivestreams/reactive-streams/1.0.0/reactive-streams-1.0.0.jar:/Users/huangqingshi/.m2/repository/com/typesafe/ssl-config-core_2.11/0.2.1/ssl-config-core_2.11-0.2.1.jar:/Users/huangqingshi/.m2/repository/org/scala-lang/modules/scala-parser-combinators_2.11/1.0.4/scala-parser-combinators_2.11-1.0.4.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-protobuf_2.11/2.4.20/akka-protobuf_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/com/typesafe/akka/akka-slf4j_2.11/2.4.20/akka-slf4j_2.11-2.4.20.jar:/Users/huangqingshi/.m2/repository/org/clapper/grizzled-slf4j_2.11/1.3.2/grizzled-slf4j_2.11-1.3.2.jar:/Users/huangqingshi/.m2/repository/com/github/scopt/scopt_2.11/3.5.0/scopt_2.11-3.5.0.jar:/Users/huangqingshi/.m2/repository/org/xerial/snappy/snappy-java/1.1.4/snappy-java-1.1.4.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill_2.11/0.7.6/chill_2.11-0.7.6.jar:/Users/huangqingshi/.m2/repository/com/twitter/chill-java/0.7.6/chill-java-0.7.6.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-clients_2.11/1.7.2/flink-clients_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-optimizer_2.11/1.7.2/flink-optimizer_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-shaded-guava/18.0-5.0/flink-shaded-guava-18.0-5.0.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.10_2.11/1.7.2/flink-connector-kafka-0.10_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-0.9_2.11/1.7.2/flink-connector-kafka-0.9_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/flink/flink-connector-kafka-base_2.11/1.7.2/flink-connector-kafka-base_2.11-1.7.2.jar:/Users/huangqingshi/.m2/repository/org/apache/kafka/kafka-clients/0.10.2.1/kafka-clients-0.10.2.1.jar:/Users/huangqingshi/.m2/repository/net/jpountz/lz4/lz4/1.3.0/lz4-1.3.0.jar:/Users/huangqingshi/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/Users/huangqingshi/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/huangqingshi/.m2/repository/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar:/Users/huangqingshi/.m2/repository/com/google/guava/guava/28.1-jre/guava-28.1-jre.jar:/Users/huangqingshi/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/huangqingshi/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/huangqingshi/.m2/repository/org/checkerframework/checker-qual/2.8.1/checker-qual-2.8.1.jar:/Users/huangqingshi/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.2/error_prone_annotations-2.3.2.jar:/Users/huangqingshi/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/huangqingshi/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.18/animal-sniffer-annotations-1.18.jar:/Users/huangqingshi/.m2/repository/redis/clients/jedis/3.1.0/jedis-3.1.0.jar:/Users/huangqingshi/.m2/repository/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar:/Users/huangqingshi/.m2/repository/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar:/Users/huangqingshi/.m2/repository/com/google/protobuf/protobuf-java/3.6.1/protobuf-java-3.6.1.jar:/Users/huangqingshi/.m2/repository/com/alibaba/druid/1.1.20/druid-1.1.20.jar:/Users/huangqingshi/.m2/repository/cglib/cglib/3.2.5/cglib-3.2.5.jar:/Users/huangqingshi/.m2/repository/org/ow2/asm/asm/5.2/asm-5.2.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant/1.9.6/ant-1.9.6.jar:/Users/huangqingshi/.m2/repository/org/apache/ant/ant-launcher/1.9.6/ant-launcher-1.9.6.jar oom.DirectBufferOOM\n\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory\n    at java.nio.Bits.reserveMemory(Bits.java:694)\n    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)\n    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)\n    at oom.DirectBufferOOM.main(DirectBufferOOM.java:18)\n\nProcess finished with exit code 1</code></pre><p>这种情况是我们使用直接内存造成溢出，这个时候我们需要检查一下程序里边是否使用的NIO及NIO，比如Netty，里边的直接内存的配置。</p>\n<h3 id=\"0x06-gc超限\">0x06: GC超限</h3>\n<p>JDK1.6之后新增了一个错误类型，如果堆内存太小的时候会报这个错误。如果98%的GC的时候回收不到2%的时候会报这个错误，也就是最小最大内存出现了问题的时候会报这个错误。如果代码配置了最小最大堆内存都为10m。　</p>\n<pre><code>-Xmx10m -Xms10m\n\npackage oom;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * @Date 2020-07-18\n */\npublic class GCOverheadOOM {\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(5);\n        for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {\n            executor.execute(() -&gt; {\n                try {\n                    Thread.sleep(10000);\n                } catch (InterruptedException e) {\n                    //do nothing\n                }\n            });\n        }\n\n    }\n\n}</code></pre><p>这个创建了一个线程池，如果线程池执行的时候如果核心线程处理不过来的时候会把数据放到LinkedBlockingQueue里边，也就是堆内存当中。这个时候我们需要检查-Xms -Xmx最小最大堆配置是否合理。再一个dump出现当前内存来分析一下是否使用了大量的循环或使用大量内存代码。</p>\n<p>以上就是经常遇到的情况，需要针对出现的不同情况进行分析和处理。</p>\n',105,0,11,NULL,NULL,'2020-07-20 21:50:54','2020-10-08 21:59:17',0,'32,42',1,0),(13,'Java集合01——总体框架','Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等','Bobbi','## 集合框架\nJava集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。Java集合工具包位置是java.util.*\n\nJava集合主要可以划分为4个部分：\n- List列表\n- Set集合\n- Map映射\n- 工具类(Iterator迭代器、Enumeration枚举类、Arrays和Collections)\n\nJava集合工具包框架图(如下)：\n\n![image.png](http://oss.osalien.com/dbblog/20201010/d3676534ff4e4e85b3d69758ba03be40.png)\n\n## 大致说明：\n\n看上面的框架图，先抓住它的主干，即Collection和Map。\n\n### 1. Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。\n\nCollection包含了List和Set两大分支。\n\nList是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。\nSet是一个不允许有重复元素的集合。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。\n\n### 2. Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。\n\nAbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。\n   \nHashtable虽然继承于Dictionary，但它实现了Map接口。\n\n接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。\n\n\n最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。\n\n有了上面的整体框架之后，我们接下来对每个类分别进行分析。\n\n\n','<h2 id=\"集合框架\">集合框架</h2>\n<p>Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。Java集合工具包位置是java.util.*</p>\n<p>Java集合主要可以划分为4个部分：</p>\n<ul>\n<li>List列表</li>\n<li>Set集合</li>\n<li>Map映射</li>\n<li>工具类(Iterator迭代器、Enumeration枚举类、Arrays和Collections)</li>\n</ul>\n<p>Java集合工具包框架图(如下)：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201010/d3676534ff4e4e85b3d69758ba03be40.png\" alt=\"image.png\"></p>\n<h2 id=\"大致说明：\">大致说明：</h2>\n<p>看上面的框架图，先抓住它的主干，即Collection和Map。</p>\n<h3 id=\"1-collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。\">1. Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。</h3>\n<p>Collection包含了List和Set两大分支。</p>\n<p>List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。\nSet是一个不允许有重复元素的集合。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。</p>\n<h3 id=\"2-map是一个映射接口，即key-value键值对。map中的每一个元素包含一个key和key对应的value。\">2. Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。</h3>\n<p>AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。</p>\n<p>Hashtable虽然继承于Dictionary，但它实现了Map接口。</p>\n<p>接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。</p>\n<p>最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。</p>\n<p>有了上面的整体框架之后，我们接下来对每个类分别进行分析。</p>\n',73,0,2,NULL,NULL,'2019-09-02 14:56:47','2020-10-10 00:05:08',0,'32,34,56',1,0),(14,'Java集合02——Collection框架','Collection是一个接口，它主要的两个分支是：List 和 Set。\n','Bobbi','## 概要\nCollection是一个接口，它主要的两个分支是：List 和 Set。\n\n![image.png](http://oss.osalien.com/dbblog/20201010/47d3f78d7588432cb558f07499e0f0bb.png)\n\n- List和Set都是接口，它们继承于Collection。List是有序的队列，List中可以有重复的元素；而Set是数学概念中的集合，Set中没有重复元素！\n\n- AbstractCollection抽象类，它实现了Collection中的绝大部分函数；这样，在Collection的实现类中，我们就可以通过继承AbstractCollection省去重复编码。AbstractList和AbstractSet都继承于AbstractCollection，具体的List实现类继承于AbstractList，而Set的实现类则继承于AbstractSet。\n\n- 另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。\n\n## Collection简介\nCollection 定义如下：\n```java\npublic interface Collection<E> extends Iterable<E> {}\n```\n它是一个接口，是高度抽象出来的集合，它包含了集合的基本操作：添加、删除、清空、遍历(读取)、是否为空、获取大小、是否保护某元素等等。\n\n```java\npublic interface Collection<E> extends Iterable<E> {\n    // Query Operations\n\n    // 返回此集合中的元素数\n    int size();\n\n    // 如果此集合不包含元素，则返回 true\n    boolean isEmpty();\n\n    // 如果此集合包含指定的元素，则返回 true\n    boolean contains(Object o);\n\n    // 返回此集合中的元素的迭代器\n    Iterator<E> iterator();\n\n    // 返回一个包含此集合中所有元素的数组\n    Object[] toArray();\n\n    // 返回包含此集合中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。\n    <T> T[] toArray(T[] a);\n\n    // Modification Operations\n\n    // 向集合中添加一个元素\n    boolean add(E e);\n\n    // 从该集合中删除指定元素的单个实例（如果存在）\n    boolean remove(Object o);\n\n\n    // 以下均为批量操作\n\n    // 如果此集合包含指定 集合中的所有元素，则返回true。\n    boolean containsAll(Collection<?> c);\n\n    // 将指定集合中的所有元素添加到此集合\n    boolean addAll(Collection<? extends E> c);\n\n    // 删除指定集合中包含的所有此集合的元素\n    boolean removeAll(Collection<?> c);\n\n    // 删除满足给定谓词的此集合的所有元素。(1.8 后)\n    default boolean removeIf(Predicate<? super E> filter) {\n        Objects.requireNonNull(filter);\n        boolean removed = false;\n        final Iterator<E> each = iterator();\n        while (each.hasNext()) {\n            if (filter.test(each.next())) {\n                each.remove();\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    // 仅保留此集合中包含在指定集合中的元素\n    boolean retainAll(Collection<?> c);\n\n    // 从此集合中删除所有元素\n    void clear();\n    \n    // 比较和散列\n    boolean equals(Object o);\n    int hashCode();\n\n    // 创建一个并行迭代器。(，1.8后)\n    @Override\n    default Spliterator<E> spliterator() {\n        return Spliterators.spliterator(this, 0);\n    }\n    \n    // 返回一个Stream\n    default Stream<E> stream() {\n        return StreamSupport.stream(spliterator(), false);\n    }\n\n    // 返回可并行的 Stream\n    default Stream<E> parallelStream() {\n        return StreamSupport.stream(spliterator(), true);\n    }\n}\n\n```\n\n## List简介\nList的接口定义如下：\n```java\npublic interface List<E> extends Collection<E> {}\n```\nList是一个继承于Collection的接口。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。\n\n```java\npublic interface List<E> extends Collection<E> {\n    // 以下是查询操作\n\n    // 返回此集合中的元素数\n    int size();\n\n    // 如果此集合不包含元素，则返回 true\n    boolean isEmpty();\n\n    // 如果此集合包含指定的元素，则返回 true\n    boolean contains(Object o);\n\n    // 返回此集合中的元素的迭代器\n    Iterator<E> iterator();\n\n    // 返回一个包含此集合中所有元素的数组\n    Object[] toArray();\n\n    // 返回的数组的运行时类型是指定数组的运行时类型。\n    <T> T[] toArray(T[] a);\n\n\n    // 以下是修改操作\n\n    // 向集合中添加一个元素\n    boolean add(E e);\n\n    // 从该集合中删除指定元素的单个实例（如果存在）\n    boolean remove(Object o);\n\n\n    // Bulk Modification Operations\n\n    // 如果此集合包含指定 集合中的所有元素，则返回true。\n    boolean containsAll(Collection<?> c);\n\n    // 将指定集合中的所有元素添加到此集合\n    boolean addAll(Collection<? extends E> c);\n\n    // 将指定集合中的所有元素插入到此列表中的指定位置\n    boolean addAll(int index, Collection<? extends E> c);\n\n    // 删除指定集合中包含的所有此集合的元素\n    boolean removeAll(Collection<?> c);\n\n    // 仅保留此集合中包含在指定集合中的元素\n    boolean retainAll(Collection<?> c);\n\n    // 将该列表的每个元素替换为将该运算符应用于该元素的结果。\n    default void replaceAll(UnaryOperator<E> operator) {\n        Objects.requireNonNull(operator);\n        final ListIterator<E> li = this.listIterator();\n        while (li.hasNext()) {\n            li.set(operator.apply(li.next()));\n        }\n    }\n\n    // 使用随附的 Comparator排序此列表来比较元素。\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    default void sort(Comparator<? super E> c) {\n        Object[] a = this.toArray();\n        Arrays.sort(a, (Comparator) c);\n        ListIterator<E> i = this.listIterator();\n        for (Object e : a) {\n            i.next();\n            i.set((E) e);\n        }\n    }\n\n    // 从此集合中删除所有元素\n    void clear();\n\n    // 比较和散列\n    boolean equals(Object o);\n\n    int hashCode();\n\n\n    // 以下是位置访问操作\n\n    // 返回此列表中指定位置的元素。\n    E get(int index);\n\n    // 用指定的元素（可选操作）替换此列表中指定位置的元素。\n    E set(int index, E element);\n\n    // 将指定的元素插入此列表中的指定位置\n    void add(int index, E element);\n\n   // 删除该列表中指定位置的元素\n    E remove(int index);\n\n\n    // 以下是搜索操作\n\n    // 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1\n    int indexOf(Object o);\n\n    // 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1\n    int lastIndexOf(Object o);\n\n\n    // 以下是List迭代器\n\n    // 返回列表中的列表迭代器\n    ListIterator<E> listIterator();\n\n    // 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n    ListIterator<E> listIterator(int index);\n\n    // 以下是视图\n\n    // 返回此列表中指定的 fromIndex （含）和 toIndex之间的视图\n    java.util.List<E> subList(int fromIndex, int toIndex);\n\n    //  创建一个并行迭代器\n    @Override\n    default Spliterator<E> spliterator() {\n        return Spliterators.spliterator(this, Spliterator.ORDERED);\n    }\n}\n```\n\n## Set简介\nSet的定义如下：\n```java\npublic interface Set<E> extends Collection<E> {}\n```\nSet是一个继承于Collection的接口。Set是无序列表，且不允许有重复的元素\n\n```java\n\npublic interface Set<E> extends Collection<E> {\n    // Query Operations\n\n    // 返回此集合中的元素数\n    int size();\n\n    // 如果此集合不包含元素，则返回 true 。\n    boolean isEmpty();\n\n    // 如果此集合包含指定的元素，则返回 true\n    boolean contains(Object o);\n\n    // 返回此集合中元素的迭代器。\n    Iterator<E> iterator();\n\n    // 返回一个包含此集合中所有元素的数组\n    Object[] toArray();\n\n    // 返回的数组的运行时类型是指定数组的运行时类型。\n    <T> T[] toArray(T[] a);\n\n\n    // 修改操作\n\n    // 	如果指定的元素不存在，则将其指定的元素添加\n    boolean add(E e);\n\n   // 	如果存在，则从该集合中删除指定的元素\n    boolean remove(Object o);\n\n\n    // 批量操作\n\n    // 返回 true如果此集合包含所有指定集合的元素\n    boolean containsAll(Collection<?> c);\n\n   // 将指定集合中的所有元素添加到此集合\n    boolean addAll(Collection<? extends E> c);\n\n    // 仅保留该集合中包含在指定集合中的元素\n    boolean retainAll(Collection<?> c);\n\n   // 从此集合中删除指定集合中包含的所有元素\n    boolean removeAll(Collection<?> c);\n\n    // 从此集合中删除所有元素\n    void clear();\n\n\n    // Comparison and hashing\n    boolean equals(Object o);\n    int hashCode();\n\n    // 在此集合中的元素上创建一个 Spliterator\n    @Override\n    default Spliterator<E> spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT);\n    }\n}\n\n```\n\n## AbstractCollection\nAbstractCollection定义如下：\n```java\npublic abstract class AbstractCollection<E> implements Collection<E> {}\n```\n\nAbstractCollection是一个抽象类，它实现了Collection中除iterator()和size()之外的函数。\nAbstractCollection的主要作用：它实现了Collection接口中的大部分函数。从而方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口了。\n\n## AbstractList\nAbstractList的定义如下：\n```java\npublic abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {}\n\n```\n\nAbstractList是一个继承于AbstractCollection，并且实现List接口的抽象类。它实现了List中除size()、get(int location)之外的函数。\nAbstractList的主要作用：它实现了List接口中的大部分函数。从而方便其它类继承List。\n另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()接口。\n\n## AbstractSet\nAbstractSet的定义如下：\n```java\npublic abstract class AbstractSet<E> extends AbstractCollection<E> implements Set<E> {}\n\n```\nAbstractSet是一个继承于AbstractCollection，并且实现Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()之外的函数。\nAbstractSet的主要作用：它实现了Set接口中的大部分函数。从而方便其它类实现Set接口。\n\n## Iterator\nIterator的定义如下：\n```java\npublic interface Iterator<E> {}\n\n```\nIterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口，包括：是否存在下一个元素、获取下一个元素、删除当前元素。\n\n```java\n// Iterator的API\nabstract boolean hasNext()\nabstract E next()\nabstract void remove()\n```\n\n## ListIterator\nListIterator的定义如下：\n```java\npublic interface ListIterator<E> extends Iterator<E> {}\n```\n\nListIterator是一个继承于Iterator的接口，它是队列迭代器。专门用于便利List，能提供向前/向后遍历。相比于Iterator，它新增了添加、是否存在上一个元素、获取上一个元素等等API接口。\n\n```java\n// ListIterator的API\n// 继承于Iterator的接口\nabstract boolean hasNext()\nabstract E next()\nabstract void remove()\n// 新增API接口\nabstract void add(E object)\nabstract boolean hasPrevious()\nabstract int nextIndex()\nabstract E previous()\nabstract int previousIndex()\nabstract void set(E object)\n```','<h2 id=\"概要\">概要</h2>\n<p>Collection是一个接口，它主要的两个分支是：List 和 Set。</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201010/47d3f78d7588432cb558f07499e0f0bb.png\" alt=\"image.png\"></p>\n<ul>\n<li><p>List和Set都是接口，它们继承于Collection。List是有序的队列，List中可以有重复的元素；而Set是数学概念中的集合，Set中没有重复元素！</p>\n</li>\n<li><p>AbstractCollection抽象类，它实现了Collection中的绝大部分函数；这样，在Collection的实现类中，我们就可以通过继承AbstractCollection省去重复编码。AbstractList和AbstractSet都继承于AbstractCollection，具体的List实现类继承于AbstractList，而Set的实现类则继承于AbstractSet。</p>\n</li>\n<li><p>另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。</p>\n</li>\n</ul>\n<h2 id=\"collection简介\">Collection简介</h2>\n<p>Collection 定义如下：</p>\n<pre><code class=\"language-java\">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {}</code></pre>\n<p>它是一个接口，是高度抽象出来的集合，它包含了集合的基本操作：添加、删除、清空、遍历(读取)、是否为空、获取大小、是否保护某元素等等。</p>\n<pre><code class=\"language-java\">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {\n    // Query Operations\n\n    // 返回此集合中的元素数\n    int size();\n\n    // 如果此集合不包含元素，则返回 true\n    boolean isEmpty();\n\n    // 如果此集合包含指定的元素，则返回 true\n    boolean contains(Object o);\n\n    // 返回此集合中的元素的迭代器\n    Iterator&lt;E&gt; iterator();\n\n    // 返回一个包含此集合中所有元素的数组\n    Object[] toArray();\n\n    // 返回包含此集合中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。\n    &lt;T&gt; T[] toArray(T[] a);\n\n    // Modification Operations\n\n    // 向集合中添加一个元素\n    boolean add(E e);\n\n    // 从该集合中删除指定元素的单个实例（如果存在）\n    boolean remove(Object o);\n\n\n    // 以下均为批量操作\n\n    // 如果此集合包含指定 集合中的所有元素，则返回true。\n    boolean containsAll(Collection&lt;?&gt; c);\n\n    // 将指定集合中的所有元素添加到此集合\n    boolean addAll(Collection&lt;? extends E&gt; c);\n\n    // 删除指定集合中包含的所有此集合的元素\n    boolean removeAll(Collection&lt;?&gt; c);\n\n    // 删除满足给定谓词的此集合的所有元素。(1.8 后)\n    default boolean removeIf(Predicate&lt;? super E&gt; filter) {\n        Objects.requireNonNull(filter);\n        boolean removed = false;\n        final Iterator&lt;E&gt; each = iterator();\n        while (each.hasNext()) {\n            if (filter.test(each.next())) {\n                each.remove();\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    // 仅保留此集合中包含在指定集合中的元素\n    boolean retainAll(Collection&lt;?&gt; c);\n\n    // 从此集合中删除所有元素\n    void clear();\n\n    // 比较和散列\n    boolean equals(Object o);\n    int hashCode();\n\n    // 创建一个并行迭代器。(，1.8后)\n    @Override\n    default Spliterator&lt;E&gt; spliterator() {\n        return Spliterators.spliterator(this, 0);\n    }\n\n    // 返回一个Stream\n    default Stream&lt;E&gt; stream() {\n        return StreamSupport.stream(spliterator(), false);\n    }\n\n    // 返回可并行的 Stream\n    default Stream&lt;E&gt; parallelStream() {\n        return StreamSupport.stream(spliterator(), true);\n    }\n}\n</code></pre>\n<h2 id=\"list简介\">List简介</h2>\n<p>List的接口定义如下：</p>\n<pre><code class=\"language-java\">public interface List&lt;E&gt; extends Collection&lt;E&gt; {}</code></pre>\n<p>List是一个继承于Collection的接口。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。</p>\n<pre><code class=\"language-java\">public interface List&lt;E&gt; extends Collection&lt;E&gt; {\n    // 以下是查询操作\n\n    // 返回此集合中的元素数\n    int size();\n\n    // 如果此集合不包含元素，则返回 true\n    boolean isEmpty();\n\n    // 如果此集合包含指定的元素，则返回 true\n    boolean contains(Object o);\n\n    // 返回此集合中的元素的迭代器\n    Iterator&lt;E&gt; iterator();\n\n    // 返回一个包含此集合中所有元素的数组\n    Object[] toArray();\n\n    // 返回的数组的运行时类型是指定数组的运行时类型。\n    &lt;T&gt; T[] toArray(T[] a);\n\n\n    // 以下是修改操作\n\n    // 向集合中添加一个元素\n    boolean add(E e);\n\n    // 从该集合中删除指定元素的单个实例（如果存在）\n    boolean remove(Object o);\n\n\n    // Bulk Modification Operations\n\n    // 如果此集合包含指定 集合中的所有元素，则返回true。\n    boolean containsAll(Collection&lt;?&gt; c);\n\n    // 将指定集合中的所有元素添加到此集合\n    boolean addAll(Collection&lt;? extends E&gt; c);\n\n    // 将指定集合中的所有元素插入到此列表中的指定位置\n    boolean addAll(int index, Collection&lt;? extends E&gt; c);\n\n    // 删除指定集合中包含的所有此集合的元素\n    boolean removeAll(Collection&lt;?&gt; c);\n\n    // 仅保留此集合中包含在指定集合中的元素\n    boolean retainAll(Collection&lt;?&gt; c);\n\n    // 将该列表的每个元素替换为将该运算符应用于该元素的结果。\n    default void replaceAll(UnaryOperator&lt;E&gt; operator) {\n        Objects.requireNonNull(operator);\n        final ListIterator&lt;E&gt; li = this.listIterator();\n        while (li.hasNext()) {\n            li.set(operator.apply(li.next()));\n        }\n    }\n\n    // 使用随附的 Comparator排序此列表来比较元素。\n    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})\n    default void sort(Comparator&lt;? super E&gt; c) {\n        Object[] a = this.toArray();\n        Arrays.sort(a, (Comparator) c);\n        ListIterator&lt;E&gt; i = this.listIterator();\n        for (Object e : a) {\n            i.next();\n            i.set((E) e);\n        }\n    }\n\n    // 从此集合中删除所有元素\n    void clear();\n\n    // 比较和散列\n    boolean equals(Object o);\n\n    int hashCode();\n\n\n    // 以下是位置访问操作\n\n    // 返回此列表中指定位置的元素。\n    E get(int index);\n\n    // 用指定的元素（可选操作）替换此列表中指定位置的元素。\n    E set(int index, E element);\n\n    // 将指定的元素插入此列表中的指定位置\n    void add(int index, E element);\n\n   // 删除该列表中指定位置的元素\n    E remove(int index);\n\n\n    // 以下是搜索操作\n\n    // 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1\n    int indexOf(Object o);\n\n    // 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1\n    int lastIndexOf(Object o);\n\n\n    // 以下是List迭代器\n\n    // 返回列表中的列表迭代器\n    ListIterator&lt;E&gt; listIterator();\n\n    // 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n    ListIterator&lt;E&gt; listIterator(int index);\n\n    // 以下是视图\n\n    // 返回此列表中指定的 fromIndex （含）和 toIndex之间的视图\n    java.util.List&lt;E&gt; subList(int fromIndex, int toIndex);\n\n    //  创建一个并行迭代器\n    @Override\n    default Spliterator&lt;E&gt; spliterator() {\n        return Spliterators.spliterator(this, Spliterator.ORDERED);\n    }\n}</code></pre>\n<h2 id=\"set简介\">Set简介</h2>\n<p>Set的定义如下：</p>\n<pre><code class=\"language-java\">public interface Set&lt;E&gt; extends Collection&lt;E&gt; {}</code></pre>\n<p>Set是一个继承于Collection的接口。Set是无序列表，且不允许有重复的元素</p>\n<pre><code class=\"language-java\">\npublic interface Set&lt;E&gt; extends Collection&lt;E&gt; {\n    // Query Operations\n\n    // 返回此集合中的元素数\n    int size();\n\n    // 如果此集合不包含元素，则返回 true 。\n    boolean isEmpty();\n\n    // 如果此集合包含指定的元素，则返回 true\n    boolean contains(Object o);\n\n    // 返回此集合中元素的迭代器。\n    Iterator&lt;E&gt; iterator();\n\n    // 返回一个包含此集合中所有元素的数组\n    Object[] toArray();\n\n    // 返回的数组的运行时类型是指定数组的运行时类型。\n    &lt;T&gt; T[] toArray(T[] a);\n\n\n    // 修改操作\n\n    //     如果指定的元素不存在，则将其指定的元素添加\n    boolean add(E e);\n\n   //     如果存在，则从该集合中删除指定的元素\n    boolean remove(Object o);\n\n\n    // 批量操作\n\n    // 返回 true如果此集合包含所有指定集合的元素\n    boolean containsAll(Collection&lt;?&gt; c);\n\n   // 将指定集合中的所有元素添加到此集合\n    boolean addAll(Collection&lt;? extends E&gt; c);\n\n    // 仅保留该集合中包含在指定集合中的元素\n    boolean retainAll(Collection&lt;?&gt; c);\n\n   // 从此集合中删除指定集合中包含的所有元素\n    boolean removeAll(Collection&lt;?&gt; c);\n\n    // 从此集合中删除所有元素\n    void clear();\n\n\n    // Comparison and hashing\n    boolean equals(Object o);\n    int hashCode();\n\n    // 在此集合中的元素上创建一个 Spliterator\n    @Override\n    default Spliterator&lt;E&gt; spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT);\n    }\n}\n</code></pre>\n<h2 id=\"abstractcollection\">AbstractCollection</h2>\n<p>AbstractCollection定义如下：</p>\n<pre><code class=\"language-java\">public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {}</code></pre>\n<p>AbstractCollection是一个抽象类，它实现了Collection中除iterator()和size()之外的函数。\nAbstractCollection的主要作用：它实现了Collection接口中的大部分函数。从而方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口了。</p>\n<h2 id=\"abstractlist\">AbstractList</h2>\n<p>AbstractList的定义如下：</p>\n<pre><code class=\"language-java\">public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {}\n</code></pre>\n<p>AbstractList是一个继承于AbstractCollection，并且实现List接口的抽象类。它实现了List中除size()、get(int location)之外的函数。\nAbstractList的主要作用：它实现了List接口中的大部分函数。从而方便其它类继承List。\n另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()接口。</p>\n<h2 id=\"abstractset\">AbstractSet</h2>\n<p>AbstractSet的定义如下：</p>\n<pre><code class=\"language-java\">public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; {}\n</code></pre>\n<p>AbstractSet是一个继承于AbstractCollection，并且实现Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()之外的函数。\nAbstractSet的主要作用：它实现了Set接口中的大部分函数。从而方便其它类实现Set接口。</p>\n<h2 id=\"iterator\">Iterator</h2>\n<p>Iterator的定义如下：</p>\n<pre><code class=\"language-java\">public interface Iterator&lt;E&gt; {}\n</code></pre>\n<p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口，包括：是否存在下一个元素、获取下一个元素、删除当前元素。</p>\n<pre><code class=\"language-java\">// Iterator的API\nabstract boolean hasNext()\nabstract E next()\nabstract void remove()</code></pre>\n<h2 id=\"listiterator\">ListIterator</h2>\n<p>ListIterator的定义如下：</p>\n<pre><code class=\"language-java\">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {}</code></pre>\n<p>ListIterator是一个继承于Iterator的接口，它是队列迭代器。专门用于便利List，能提供向前/向后遍历。相比于Iterator，它新增了添加、是否存在上一个元素、获取上一个元素等等API接口。</p>\n<pre><code class=\"language-java\">// ListIterator的API\n// 继承于Iterator的接口\nabstract boolean hasNext()\nabstract E next()\nabstract void remove()\n// 新增API接口\nabstract void add(E object)\nabstract boolean hasPrevious()\nabstract int nextIndex()\nabstract E previous()\nabstract int previousIndex()\nabstract void set(E object)</code></pre>\n',65,0,2,NULL,NULL,'2019-09-03 04:27:25','2020-10-10 00:05:50',0,'32,34,56',1,0),(15,'Java集合03——ArrayList','ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。','Bobbi','## ArrayList简介\n\nArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。\n\nArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。\n\nArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。\n\nArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。\n\nArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。\n\n## 数据结构\n\n![image.png](http://oss.osalien.com/dbblog/20201010/6a511922056c451e841950615e7a4bd6.png)\n\nArrayList包含了两个重要的对象：elementData 和 size。\n\n(1) elementData 是\"Object[]类型的数组\"，它保存了添加到ArrayList中的元素。实际上，elementData是个动态数组，我们能通过构造函数 ArrayList(int initialCapacity)来执行它的初始容量为initialCapacity；如果通过不含参数的构造函数ArrayList()来创建ArrayList，则elementData的容量默认是××10××。elementData数组的大小会根据ArrayList容量的增长而动态的增长\n\n```java\n// 存储ArrayList元素的数组缓冲区\ntransient Object[] elementData; \n```\n\n(2) size 则是动态数组的实际大小。\n\n## 构造方法\n\n```java\n/**\n* 构造具有指定初始容量的空列表\n*/\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     * 构造一个初始容量为10的空列表。\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 创建一个包含collection的ArrayList\n     */\n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n\nArrayList 提供了三种方式的构造器,可以构造一个默认初始容量为 10 的空列表、构造\n一个指定初始容量的空列表以及构造一个包含指定 collection 的元素的列表,这些元素按照\n该 collection 的迭代器返回它们的顺序排列的。\n\n## API列表\n\n```java\n    /// Collection中定义的API\n\n    // 将指定的元素追加到此列表的末尾。\n    boolean add(E e)\n    // 将指定集合中的所有元素添加到此集合。\n    boolean addAll(Collection<? extends E> c)\n    // 返回此列表中的元素数。\n    int size()\n    // 如果此列表包含指定的元素，则返回 true 。\n    boolean contains(Object o)\n    // 从列表中删除所有元素。\n    void clear()\n    // 如果此列表不包含元素，则返回 true 。\n    boolean isEmpty()\n    // 返回该列表中的元素的迭代器。\n    Iterator<E> iterator()\n    // 从列表中删除指定元素的第一个出现（如果存在）。\n    boolean remove(Object o)\n    // 从此列表中删除指定集合中包含的所有元素。\n    boolean removeAll(Collection<?> c)\n    // 仅保留此列表中包含在指定集合中的元素。\n    boolean retainAll(Collection<?> c)\n    // 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。\n    Object[] toArray()\n    // 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。\n    <T> T[] toArray(T[] a)\n\n\n    /// AbstractCollection中定义的API\n\n    // 在此列表中的指定位置插入指定的元素。\n    void add(int index, E element)\n    // 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n    boolean addAll(int index, Collection<? extends E> c)\n    // 返回此列表中指定位置的元素。\n    E get(int index)\n    // 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。\n    int indexOf(Object o)\n    // 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。\n    int lastIndexOf(Object o)\n    // 返回列表中的列表迭代器（按适当的顺序）。\n    ListIterator<E> listIterator()\n    // 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n    ListIterator<E> listIterator(int index)\n    // 删除该列表中指定位置的元素。\n    E remove(int index)\n    // 用指定的元素替换此列表中指定位置的元素。\n    E set(int index, E element)\n    // 返回此列表中指定的 fromIndex （包括）和 toIndex之间的独占视图。\n    List<E> subList(int fromIndex, int toIndex)\n\n    /// ArrayList中新增的API\n\n    // 返回此 ArrayList实例的浅拷贝。\n    Object clone()\n    // 如果需要，增加此 ArrayList实例的容量，以确保它可以至少保存最小容量参数指定的元素数。\n    void ensureCapacity(int minCapacity)\n    // java8遍历操作\n    void forEach(Consumer<? super E> action)\n    // 删除满足给定谓词的此集合的所有元素。\n    boolean removeIf(Predicate<? super E> filter)\n    // 从这个列表中删除所有索引在 fromIndex （含）和 toIndex之间的元素。\n    protected void removeRange(int fromIndex, int toIndex)\n    // 将该列表的每个元素替换为将该运算符应用于该元素的结果。\n    void replaceAll(UnaryOperator<E> operator)\n    // 使用提供的 Comparator对此列表进行排序以比较元素。\n    void sort(Comparator<? super E> c)\n    // 在此列表中的元素上创建Spliterator 。\n    Spliterator<E> spliterator()\n    //  去掉预留元素的大小。\n    void trimToSize()\n\n```\n\n## 存储\n\nArrayList 提供了 set(int index, E element)、add(E e)、add(int index, E element)、\naddAll(Collection<? extends E> c)、addAll(int index, Collection<? extends E> c)这些添加元素的方法\n\n#### set(int index,E element)\n\n用指定的元素替换此列表中指定位置的元素\n\n```java\n    // 用指定的元素替换此列表中指定位置的元素\n    public E set(int index, E element) {\n	    // 检查给定索引是否在范围内(与size比较)\n        rangeCheck(index);\n		// 替换指定位置的元素，并返回旧元素 \n        E oldValue = elementData(index);\n        elementData[index] = element;\n        return oldValue;\n    }\n```\n\n#### add(E e)\n\n将指定的元素追加到此列表的末尾。\n\n```java\n   // 将指定的元素追加到此列表的末尾。 \n   public boolean add(E e) {\n       // 检查并扩容\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n       // 向列表末尾添加元素\n        elementData[size++] = e;\n        return true;\n    }\n```\n\n#### add(int index, E element)\n\n在此列表中的指定位置插入指定的元素。\n\n```java\n    public void add(int index, E element) {\n        // 检查index是否越界\n        rangeCheckForAdd(index);\n		// 检查并扩容\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        // 复制数组\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        // 向指定位置添加元素\n        elementData[index] = element;\n        size++;\n    }\n```\n\n#### allAll(Collection<? extends E> c)\n\n```java\n    public boolean addAll(Collection<? extends E> c) {\n        // 将list转为Object[] 数组\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        // 检查并扩容\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        // 复制数组元素到size后的位置\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n```\n\n#### allAll(int index, Collection<? extends E> c)\n\n```java\n    public boolean addAll(int index, Collection<? extends E> c) {\n        // 检查index是否越界\n        rangeCheckForAdd(index);\n		// 将list转为Object[] 数组\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        // 检查并扩容\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n		// 复制数组元素到index位置\n        int numMoved = size - index;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                             numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n```\n\n#### System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)\n\nsrc:源数组;\n\nsrcPos:源数组要复制的起始位置;\n\ndest:目的数组;\n\ndestPos:目的数组放置的起始位置;\n\nlength:复制的长度.\n\n\n\n### 自动扩容机制\n\n我们可以看到他的实现其实最核心的内容就是`ensureCapacityInternal`。这个函数其实就是**自动扩容机制的核心**。我们依次来看一下他的具体实现\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n// 计算实际元素个数\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    // 如果是空，则实际元素个数 是默认容量或初始容量的最大值\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n    // modCount值+1\n    modCount++;\n    // 如果实际元素个数大于数组容量，则扩容\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    // 扩展为原来的1.5倍（右移一位 除以2）\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    // 如果扩为1.5倍还不满足需求，直接扩为需求值\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // 将老数组内容拷贝到新数组\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n从上面介绍的向 ArrayList 中存储元素的代码中,我们看到,每当向数组中添加元素时,\n都要去检查添加后元素的个数是否会超出当前数组的长度,如果超出,数组将会进行扩容,\n以满足添加数据的需求。\n\n\n\n数组进行扩容时,会将老数组中的元素重新拷贝一份到新的数组中,每次数组容量的增长是其原容量的 1.5 倍。这种操作的代价是很高的,因此在实际使用时,我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时,要在构造 ArrayList 实例时,就指定其容量,以避免数组扩容的发生。\n\n## 读取\n\n```java\n    public E get(int index) {\n    	// 检查是否越界\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n```\n\n### 遍历方式比较\n\n(1) 第一种，**通过迭代器遍历**。即通过Iterator去遍历。\n\n```java\nInteger value = null;\nIterator iter = list.iterator();\nwhile (iter.hasNext()) {\n    value = (Integer)iter.next();\n}\n```\n\n(2) 第二种，随机访问，通过索引值去遍历\n\n```java\nInteger value = null;\nint size = list.size();\nfor (int i=0; i<size; i++) {\n    value = (Integer)list.get(i);        \n}\n```\n\n(3) 第三种，**for循环遍历**。如下：\n\n```java\nInteger value = null;\nfor (Integer integ:list) {\n    value = integ;\n}\n```\n\n(4) 第四种，Java8遍历\n\n```java\nlist.forEach(item -> System.out.print(item))\n```\n\n下面通过一个实例，比较这四种方式的效率：\n\n```java\npublic class Tetst {\n\n    public static void main(String[] args) {\n        List list = new ArrayList();\n        for (int i=0; i<10000000; i++)\n            list.add(i);\n        iteratorThroughFor2(list) ;\n        iteratorThroughIterator(list) ;\n        iteratorThroughRandomAccess(list) ;\n        iteratorThroughForJava8(list) ;\n\n    }\n\n\n\n    public static void iteratorThroughRandomAccess(List list) {\n\n        long startTime;\n        long endTime;\n        startTime = System.currentTimeMillis();\n        for (int i=0; i<list.size(); i++) {\n            list.get(i);\n        }\n        endTime = System.currentTimeMillis();\n        long interval = endTime - startTime;\n        System.out.println(\"iteratorThroughRandomAccess：\" + interval+\" ms\");\n    }\n\n    public static void iteratorThroughIterator(List list) {\n\n        long startTime;\n        long endTime;\n        startTime = System.currentTimeMillis();\n        for(Iterator iter = list.iterator(); iter.hasNext(); ) {\n            iter.next();\n        }\n        endTime = System.currentTimeMillis();\n        long interval = endTime - startTime;\n        System.out.println(\"iteratorThroughIterator：\" + interval+\" ms\");\n    }\n\n\n    public static void iteratorThroughFor2(List list) {\n\n        long startTime;\n        long endTime;\n        startTime = System.currentTimeMillis();\n        for(Object obj:list)\n            ;\n        endTime = System.currentTimeMillis();\n        long interval = endTime - startTime;\n        System.out.println(\"iteratorThroughFor2：\" + interval+\" ms\");\n    }\n\n    public static void iteratorThroughForJava8(List list) {\n\n        long startTime;\n        long endTime;\n        startTime = System.currentTimeMillis();\n        list.forEach(item -> {});\n        endTime = System.currentTimeMillis();\n        long interval = endTime - startTime;\n        System.out.println(\"iteratorThroughForJava8：\" + interval+\" ms\");\n    }\n\n}\n\n```\n\n运行结果：\n\n```java\niteratorThroughFor2：7 ms\niteratorThroughIterator：10 ms\niteratorThroughRandomAccess：6 ms\niteratorThroughForJava8：58 ms\n```\n\n由此可见，**遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用Java8的forEach遍历的效率最低！**\n\n\n\n## 删除\n\nArrayList 提供了根据下标或者指定对象两种方式的删除功能。如下:\n\n根据索引删除\n\n```java\n    public E remove(int index) {\n        // 检查index是否越界\n        rangeCheck(index);\n		// 增加modCount\n        modCount++;\n        // 获取index旧值并返回\n        E oldValue = elementData(index);\n		// 通过数组覆盖删除\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        // 释放多余空间\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n\n```\n\n根据对象删除\n\n```java\n    public boolean remove(Object o) {\n        if (o == null) {\n            // object为空的情况，删除第一个null值\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            // 遍历list，如果值相等则删除，只删除第一个\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    private void fastRemove(int index) {\n        // 增加modCount\n        modCount++;\n        // 通过数组覆盖删除\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        // 释放多余空间\n        elementData[--size] = null; // clear to let GC do its work\n    }\n```\n\n\n\n','<h2 id=\"arraylist简介\">ArrayList简介</h2>\n<p>ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。</p>\n<p>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p>\n<p>ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</p>\n<p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p>\n<p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p>\n<h2 id=\"数据结构\">数据结构</h2>\n<p><img src=\"http://oss.osalien.com/dbblog/20201010/6a511922056c451e841950615e7a4bd6.png\" alt=\"image.png\"></p>\n<p>ArrayList包含了两个重要的对象：elementData 和 size。</p>\n<p>(1) elementData 是&quot;Object[]类型的数组&quot;，它保存了添加到ArrayList中的元素。实际上，elementData是个动态数组，我们能通过构造函数 ArrayList(int initialCapacity)来执行它的初始容量为initialCapacity；如果通过不含参数的构造函数ArrayList()来创建ArrayList，则elementData的容量默认是××10××。elementData数组的大小会根据ArrayList容量的增长而动态的增长</p>\n<pre><code class=\"language-java\">// 存储ArrayList元素的数组缓冲区\ntransient Object[] elementData; </code></pre>\n<p>(2) size 则是动态数组的实际大小。</p>\n<h2 id=\"构造方法\">构造方法</h2>\n<pre><code class=\"language-java\">/**\n* 构造具有指定初始容量的空列表\n*/\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity &gt; 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     * 构造一个初始容量为10的空列表。\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 创建一个包含collection的ArrayList\n     */\n    public ArrayList(Collection&lt;? extends E&gt; c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }</code></pre>\n<p>ArrayList 提供了三种方式的构造器,可以构造一个默认初始容量为 10 的空列表、构造\n一个指定初始容量的空列表以及构造一个包含指定 collection 的元素的列表,这些元素按照\n该 collection 的迭代器返回它们的顺序排列的。</p>\n<h2 id=\"api列表\">API列表</h2>\n<pre><code class=\"language-java\">    /// Collection中定义的API\n\n    // 将指定的元素追加到此列表的末尾。\n    boolean add(E e)\n    // 将指定集合中的所有元素添加到此集合。\n    boolean addAll(Collection&lt;? extends E&gt; c)\n    // 返回此列表中的元素数。\n    int size()\n    // 如果此列表包含指定的元素，则返回 true 。\n    boolean contains(Object o)\n    // 从列表中删除所有元素。\n    void clear()\n    // 如果此列表不包含元素，则返回 true 。\n    boolean isEmpty()\n    // 返回该列表中的元素的迭代器。\n    Iterator&lt;E&gt; iterator()\n    // 从列表中删除指定元素的第一个出现（如果存在）。\n    boolean remove(Object o)\n    // 从此列表中删除指定集合中包含的所有元素。\n    boolean removeAll(Collection&lt;?&gt; c)\n    // 仅保留此列表中包含在指定集合中的元素。\n    boolean retainAll(Collection&lt;?&gt; c)\n    // 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。\n    Object[] toArray()\n    // 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。\n    &lt;T&gt; T[] toArray(T[] a)\n\n\n    /// AbstractCollection中定义的API\n\n    // 在此列表中的指定位置插入指定的元素。\n    void add(int index, E element)\n    // 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n    boolean addAll(int index, Collection&lt;? extends E&gt; c)\n    // 返回此列表中指定位置的元素。\n    E get(int index)\n    // 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。\n    int indexOf(Object o)\n    // 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。\n    int lastIndexOf(Object o)\n    // 返回列表中的列表迭代器（按适当的顺序）。\n    ListIterator&lt;E&gt; listIterator()\n    // 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n    ListIterator&lt;E&gt; listIterator(int index)\n    // 删除该列表中指定位置的元素。\n    E remove(int index)\n    // 用指定的元素替换此列表中指定位置的元素。\n    E set(int index, E element)\n    // 返回此列表中指定的 fromIndex （包括）和 toIndex之间的独占视图。\n    List&lt;E&gt; subList(int fromIndex, int toIndex)\n\n    /// ArrayList中新增的API\n\n    // 返回此 ArrayList实例的浅拷贝。\n    Object clone()\n    // 如果需要，增加此 ArrayList实例的容量，以确保它可以至少保存最小容量参数指定的元素数。\n    void ensureCapacity(int minCapacity)\n    // java8遍历操作\n    void forEach(Consumer&lt;? super E&gt; action)\n    // 删除满足给定谓词的此集合的所有元素。\n    boolean removeIf(Predicate&lt;? super E&gt; filter)\n    // 从这个列表中删除所有索引在 fromIndex （含）和 toIndex之间的元素。\n    protected void removeRange(int fromIndex, int toIndex)\n    // 将该列表的每个元素替换为将该运算符应用于该元素的结果。\n    void replaceAll(UnaryOperator&lt;E&gt; operator)\n    // 使用提供的 Comparator对此列表进行排序以比较元素。\n    void sort(Comparator&lt;? super E&gt; c)\n    // 在此列表中的元素上创建Spliterator 。\n    Spliterator&lt;E&gt; spliterator()\n    //  去掉预留元素的大小。\n    void trimToSize()\n</code></pre>\n<h2 id=\"存储\">存储</h2>\n<p>ArrayList 提供了 set(int index, E element)、add(E e)、add(int index, E element)、\naddAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法</p>\n<h4 id=\"setint-indexe-element\">set(int index,E element)</h4>\n<p>用指定的元素替换此列表中指定位置的元素</p>\n<pre><code class=\"language-java\">    // 用指定的元素替换此列表中指定位置的元素\n    public E set(int index, E element) {\n        // 检查给定索引是否在范围内(与size比较)\n        rangeCheck(index);\n        // 替换指定位置的元素，并返回旧元素 \n        E oldValue = elementData(index);\n        elementData[index] = element;\n        return oldValue;\n    }</code></pre>\n<h4 id=\"adde-e\">add(E e)</h4>\n<p>将指定的元素追加到此列表的末尾。</p>\n<pre><code class=\"language-java\">   // 将指定的元素追加到此列表的末尾。 \n   public boolean add(E e) {\n       // 检查并扩容\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n       // 向列表末尾添加元素\n        elementData[size++] = e;\n        return true;\n    }</code></pre>\n<h4 id=\"addint-index-e-element\">add(int index, E element)</h4>\n<p>在此列表中的指定位置插入指定的元素。</p>\n<pre><code class=\"language-java\">    public void add(int index, E element) {\n        // 检查index是否越界\n        rangeCheckForAdd(index);\n        // 检查并扩容\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        // 复制数组\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        // 向指定位置添加元素\n        elementData[index] = element;\n        size++;\n    }</code></pre>\n<h4 id=\"allallcollection-extends-e-c\">allAll(Collection&lt;? extends E&gt; c)</h4>\n<pre><code class=\"language-java\">    public boolean addAll(Collection&lt;? extends E&gt; c) {\n        // 将list转为Object[] 数组\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        // 检查并扩容\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        // 复制数组元素到size后的位置\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }</code></pre>\n<h4 id=\"allallint-index-collection-extends-e-c\">allAll(int index, Collection&lt;? extends E&gt; c)</h4>\n<pre><code class=\"language-java\">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {\n        // 检查index是否越界\n        rangeCheckForAdd(index);\n        // 将list转为Object[] 数组\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        // 检查并扩容\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        // 复制数组元素到index位置\n        int numMoved = size - index;\n        if (numMoved &gt; 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                             numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }</code></pre>\n<h4 id=\"systemarraycopyobject-src-int-srcpos-object-dest-int-destpos-int-length\">System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</h4>\n<p>src:源数组;</p>\n<p>srcPos:源数组要复制的起始位置;</p>\n<p>dest:目的数组;</p>\n<p>destPos:目的数组放置的起始位置;</p>\n<p>length:复制的长度.</p>\n<h3 id=\"自动扩容机制\">自动扩容机制</h3>\n<p>我们可以看到他的实现其实最核心的内容就是<code>ensureCapacityInternal</code>。这个函数其实就是<strong>自动扩容机制的核心</strong>。我们依次来看一下他的具体实现</p>\n<pre><code class=\"language-java\">private void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n// 计算实际元素个数\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    // 如果是空，则实际元素个数 是默认容量或初始容量的最大值\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n    // modCount值+1\n    modCount++;\n    // 如果实际元素个数大于数组容量，则扩容\n    if (minCapacity - elementData.length &gt; 0)\n        grow(minCapacity);\n}\n\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    // 扩展为原来的1.5倍（右移一位 除以2）\n    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\n    // 如果扩为1.5倍还不满足需求，直接扩为需求值\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // 将老数组内容拷贝到新数组\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}</code></pre>\n<p>从上面介绍的向 ArrayList 中存储元素的代码中,我们看到,每当向数组中添加元素时,\n都要去检查添加后元素的个数是否会超出当前数组的长度,如果超出,数组将会进行扩容,\n以满足添加数据的需求。</p>\n<p>数组进行扩容时,会将老数组中的元素重新拷贝一份到新的数组中,每次数组容量的增长是其原容量的 1.5 倍。这种操作的代价是很高的,因此在实际使用时,我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时,要在构造 ArrayList 实例时,就指定其容量,以避免数组扩容的发生。</p>\n<h2 id=\"读取\">读取</h2>\n<pre><code class=\"language-java\">    public E get(int index) {\n        // 检查是否越界\n        rangeCheck(index);\n\n        return elementData(index);\n    }</code></pre>\n<h3 id=\"遍历方式比较\">遍历方式比较</h3>\n<p>(1) 第一种，<strong>通过迭代器遍历</strong>。即通过Iterator去遍历。</p>\n<pre><code class=\"language-java\">Integer value = null;\nIterator iter = list.iterator();\nwhile (iter.hasNext()) {\n    value = (Integer)iter.next();\n}</code></pre>\n<p>(2) 第二种，随机访问，通过索引值去遍历</p>\n<pre><code class=\"language-java\">Integer value = null;\nint size = list.size();\nfor (int i=0; i&lt;size; i++) {\n    value = (Integer)list.get(i);        \n}</code></pre>\n<p>(3) 第三种，<strong>for循环遍历</strong>。如下：</p>\n<pre><code class=\"language-java\">Integer value = null;\nfor (Integer integ:list) {\n    value = integ;\n}</code></pre>\n<p>(4) 第四种，Java8遍历</p>\n<pre><code class=\"language-java\">list.forEach(item -&gt; System.out.print(item))</code></pre>\n<p>下面通过一个实例，比较这四种方式的效率：</p>\n<pre><code class=\"language-java\">public class Tetst {\n\n    public static void main(String[] args) {\n        List list = new ArrayList();\n        for (int i=0; i&lt;10000000; i++)\n            list.add(i);\n        iteratorThroughFor2(list) ;\n        iteratorThroughIterator(list) ;\n        iteratorThroughRandomAccess(list) ;\n        iteratorThroughForJava8(list) ;\n\n    }\n\n\n\n    public static void iteratorThroughRandomAccess(List list) {\n\n        long startTime;\n        long endTime;\n        startTime = System.currentTimeMillis();\n        for (int i=0; i&lt;list.size(); i++) {\n            list.get(i);\n        }\n        endTime = System.currentTimeMillis();\n        long interval = endTime - startTime;\n        System.out.println(&quot;iteratorThroughRandomAccess：&quot; + interval+&quot; ms&quot;);\n    }\n\n    public static void iteratorThroughIterator(List list) {\n\n        long startTime;\n        long endTime;\n        startTime = System.currentTimeMillis();\n        for(Iterator iter = list.iterator(); iter.hasNext(); ) {\n            iter.next();\n        }\n        endTime = System.currentTimeMillis();\n        long interval = endTime - startTime;\n        System.out.println(&quot;iteratorThroughIterator：&quot; + interval+&quot; ms&quot;);\n    }\n\n\n    public static void iteratorThroughFor2(List list) {\n\n        long startTime;\n        long endTime;\n        startTime = System.currentTimeMillis();\n        for(Object obj:list)\n            ;\n        endTime = System.currentTimeMillis();\n        long interval = endTime - startTime;\n        System.out.println(&quot;iteratorThroughFor2：&quot; + interval+&quot; ms&quot;);\n    }\n\n    public static void iteratorThroughForJava8(List list) {\n\n        long startTime;\n        long endTime;\n        startTime = System.currentTimeMillis();\n        list.forEach(item -&gt; {});\n        endTime = System.currentTimeMillis();\n        long interval = endTime - startTime;\n        System.out.println(&quot;iteratorThroughForJava8：&quot; + interval+&quot; ms&quot;);\n    }\n\n}\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-java\">iteratorThroughFor2：7 ms\niteratorThroughIterator：10 ms\niteratorThroughRandomAccess：6 ms\niteratorThroughForJava8：58 ms</code></pre>\n<p>由此可见，<strong>遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用Java8的forEach遍历的效率最低！</strong></p>\n<h2 id=\"删除\">删除</h2>\n<p>ArrayList 提供了根据下标或者指定对象两种方式的删除功能。如下:</p>\n<p>根据索引删除</p>\n<pre><code class=\"language-java\">    public E remove(int index) {\n        // 检查index是否越界\n        rangeCheck(index);\n        // 增加modCount\n        modCount++;\n        // 获取index旧值并返回\n        E oldValue = elementData(index);\n        // 通过数组覆盖删除\n        int numMoved = size - index - 1;\n        if (numMoved &gt; 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        // 释放多余空间\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n</code></pre>\n<p>根据对象删除</p>\n<pre><code class=\"language-java\">    public boolean remove(Object o) {\n        if (o == null) {\n            // object为空的情况，删除第一个null值\n            for (int index = 0; index &lt; size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            // 遍历list，如果值相等则删除，只删除第一个\n            for (int index = 0; index &lt; size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    private void fastRemove(int index) {\n        // 增加modCount\n        modCount++;\n        // 通过数组覆盖删除\n        int numMoved = size - index - 1;\n        if (numMoved &gt; 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        // 释放多余空间\n        elementData[--size] = null; // clear to let GC do its work\n    }</code></pre>\n',41,0,2,NULL,NULL,'2019-09-06 04:54:17','2020-10-10 00:06:29',0,'32,34,56',1,0),(16,'Java集合04——fail-fast总结','fail-fast 机制是java集合(Collection)中的一种错误机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。','Bobbi','## fail-fast简介\nfail-fast 机制是java集合(Collection)中的一种错误机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。\n\n## fail-fast场景\n在多线程和单线程环境下都有可能出现快速失败。\n### 单线程环境下的fail-fast\n```java\npublic class FailFastTest {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            list.add(i);\n        }\n        Iterator<Integer> iterator = list.iterator();\n        while(iterator.hasNext()) {\n            Integer next = iterator.next();\n            System.out.println(\"当前元素为 \"+ next);\n            if(next == 2) {\n                list.remove(next);\n                System.out.println(\"移除元素2后\");\n            }\n        }\n    }\n\n}\n\n```\n运行结果：\n\n```shell\n当前元素为 0\n当前元素为 1\n当前元素为 2\n移除元素2后\nException in thread \"main\" java.util.ConcurrentModificationException\n	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)\n	at java.util.ArrayList$Itr.next(ArrayList.java:859)\n	at chap03.FailFastTest.main(FailFastTest.java:21)\n```\n\n上述代码创建了长度为10的list，遍历list时，当值为2时，调用list的remove方法，移除该元素，当移除元素2后，再次调用next()方法时,抛出ConcurrentModificationException,即产生了fail-fast\n\n### 多线程环境下的fail-fast\n```java\npublic class FailFastTest {\n\n    private static List<Integer> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n        new Thread1().start();\n        new Thread2().start();\n    }\n\n    private static class Thread1 extends Thread {\n        @Override\n        public void run() {\n            int  i = 0;\n            while (i<6 ) {\n                list.add(i);\n                printAll();\n                i++;\n            }\n\n        }\n    }\n    private static class Thread2 extends Thread {\n        @Override\n        public void run() {\n            int  i = 10;\n            while (i<16 ) {\n                list.add(i);\n                printAll();\n                i++;\n            }\n\n        }\n    }\n    private static void printAll() {\n        Iterator<Integer> iterator = list.iterator();\n        while (iterator.hasNext()) {\n            Integer next = iterator.next();\n            System.out.print(next + \", \");\n        }\n        System.out.println();\n    }\n\n}\n```\n运行结果:\n\n```shell\n0, \n0, 10, \n0, 10, 1, \n0, 10, 1, 11, \n0, 10, 1, 11, 2, \n0, 10, 1, 11, 2, 12, \n0, 0, 10, 1, 11, 2, 12, 13, 3, \nException in thread \"Thread-1\" java.util.ConcurrentModificationException\n	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)\n	at java.util.ArrayList$Itr.next(ArrayList.java:859)\n	at chap03.FailFastTest.printAll(FailFastTest.java:59)\n	at chap03.FailFastTest.access$300(FailFastTest.java:13)\n	at chap03.FailFastTest$Thread2.run(FailFastTest.java:50)\n0, 10, 1, 11, 2, 12, 13, 3, 4, \n0, 10, 1, 11, 2, 12, 13, 3, 4, 5, \n\n```\n结果说明：\n(1) FastFailTest中通过 new Thread1().start() 和 new Thread2().start() 同时启动两个线程去操作list。\n    Thread1线程：向list中依次添加0,1,2,3,4,5。每添加一个数之后，就通过printAll()遍历整个list。\n    Thread2线程：向list中依次添加10,11,12,13,14,15。每添加一个数之后，就通过printAll()遍历整个list。<br>\n(2) 当某一个线程遍历list的过程中，list的内容被另外一个线程所改变了；就会抛出ConcurrentModificationException异常，产生fail-fast事件。\n\n## fail-fast原理\n产生fail-fast事件，是通过抛出ConcurrentModificationException异常来触发的。\n那么，ArrayList是如何抛出ConcurrentModificationException异常的呢?\n\n我们知道，ConcurrentModificationException是在操作Iterator时抛出的异常。我们先看看Iterator的源码。ArrayList的Iterator是在父类AbstractList.java中实现的。代码如下:\n```java\n    // 返回List对应的迭代器。实际上，是返回Itr对象\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n\n    // Itr是Iterator的实现类\n    private class Itr implements Iterator<E> {\n        /**\n         * 后续调用next返回的元素索引\n         */\n        int cursor = 0;\n\n        /**\n         * 最近调用next或previous返回的元素索引。\n         */\n        int lastRet = -1;\n\n        /**\n         * 迭代器所期望的modCount值。\n         * 每次新建Itr()对象时，都会保存新建该对象时对应的modCount；\n         * 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等；\n	 * 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。\n         */\n        int expectedModCount = modCount;\n\n        public boolean hasNext() {\n            return cursor != size();\n        }\n\n        public E next() {\n	    // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等；\n	    // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。\n            checkForComodification();\n            try {\n                int i = cursor;\n                E next = get(i);\n                lastRet = i;\n                cursor = i + 1;\n                return next;\n            } catch (IndexOutOfBoundsException e) {\n                checkForComodification();\n                throw new NoSuchElementException();\n            }\n        }\n\n        public void remove() {\n            if (lastRet < 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try {\n                AbstractList.this.remove(lastRet);\n                if (lastRet < cursor)\n                    cursor--;\n                lastRet = -1;\n                expectedModCount = modCount;\n            } catch (IndexOutOfBoundsException e) {\n                throw new ConcurrentModificationException();\n            }\n        }\n	// 检查是否修改\n        final void checkForComodification() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n        }\n    }\n```\n从中，我们可以发现在调用 next() 和 remove()时，都会执行 checkForComodification()。可以看出，该方法才是判断是否抛出ConcurrentModificationException异常的关键。在该段代码中，当modCount != expectedModCount\n时，就会抛出该异常。\n\n从Itr类中，我们知道 expectedModCount 在创建Itr对象时，被赋值为 modCount。通过Itr，我们知道：expectedModCount不可能被修改为不等于 modCount。所以，需要考证的就是modCount何时会被修改。\n\n接下来，我们查看ArrayList的源码，来看看modCount是如何被修改的。\n[ArrayList源码解析>>](http://www.dblearn.cn/article/42)\n\n从中，我们发现：无论是add()、remove()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化，这样在checkForComodification方法中就会抛出ConcurrentModificationException异常。\n\n## fail-fast解决\n\n### 使用迭代器的remove方法\n在单线程的遍历过程中，如果要进行remove操作，可以调用迭代器的remove方法而不是集合类的remove方法。看看ArrayList中迭代器的remove方法的源码：\n```java\n        public void remove() {\n            if (lastRet < 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try {\n                ArrayList.this.remove(lastRet);\n                cursor = lastRet;\n                lastRet = -1;\n                expectedModCount = modCount;\n            } catch (IndexOutOfBoundsException ex) {\n                throw new ConcurrentModificationException();\n            }\n        }\n```\n可以看到，该remove方法并不会修改modCount的值，并且不会对后面的遍历造成影响，因为该方法remove不能指定元素，只能remove当前遍历过的那个元素，所以调用该方法并不会发生fail-fast现象。\n\n### 使用java.util.concurrent包下对应的类\n若在多线程环境下使用fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”\n所以，本例中只需要将ArrayList替换成java.util.concurrent包下对应的类即可。\n即，将代码\n```java\nprivate static List<String> list = new ArrayList<String>();\n```\n\n替换为\n```java\nprivate static List<String> list = new CopyOnWriteArrayList<String>();\n```\n则可以解决该办法。\n\n','<h2 id=\"fail-fast简介\">fail-fast简介</h2>\n<p>fail-fast 机制是java集合(Collection)中的一种错误机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。</p>\n<h2 id=\"fail-fast场景\">fail-fast场景</h2>\n<p>在多线程和单线程环境下都有可能出现快速失败。</p>\n<h3 id=\"单线程环境下的fail-fast\">单线程环境下的fail-fast</h3>\n<pre><code class=\"language-java\">public class FailFastTest {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 10; i++) {\n            list.add(i);\n        }\n        Iterator&lt;Integer&gt; iterator = list.iterator();\n        while(iterator.hasNext()) {\n            Integer next = iterator.next();\n            System.out.println(&quot;当前元素为 &quot;+ next);\n            if(next == 2) {\n                list.remove(next);\n                System.out.println(&quot;移除元素2后&quot;);\n            }\n        }\n    }\n\n}\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-shell\">当前元素为 0\n当前元素为 1\n当前元素为 2\n移除元素2后\nException in thread &quot;main&quot; java.util.ConcurrentModificationException\n    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)\n    at java.util.ArrayList$Itr.next(ArrayList.java:859)\n    at chap03.FailFastTest.main(FailFastTest.java:21)</code></pre>\n<p>上述代码创建了长度为10的list，遍历list时，当值为2时，调用list的remove方法，移除该元素，当移除元素2后，再次调用next()方法时,抛出ConcurrentModificationException,即产生了fail-fast</p>\n<h3 id=\"多线程环境下的fail-fast\">多线程环境下的fail-fast</h3>\n<pre><code class=\"language-java\">public class FailFastTest {\n\n    private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n\n    public static void main(String[] args) {\n        new Thread1().start();\n        new Thread2().start();\n    }\n\n    private static class Thread1 extends Thread {\n        @Override\n        public void run() {\n            int  i = 0;\n            while (i&lt;6 ) {\n                list.add(i);\n                printAll();\n                i++;\n            }\n\n        }\n    }\n    private static class Thread2 extends Thread {\n        @Override\n        public void run() {\n            int  i = 10;\n            while (i&lt;16 ) {\n                list.add(i);\n                printAll();\n                i++;\n            }\n\n        }\n    }\n    private static void printAll() {\n        Iterator&lt;Integer&gt; iterator = list.iterator();\n        while (iterator.hasNext()) {\n            Integer next = iterator.next();\n            System.out.print(next + &quot;, &quot;);\n        }\n        System.out.println();\n    }\n\n}</code></pre>\n<p>运行结果:</p>\n<pre><code class=\"language-shell\">0, \n0, 10, \n0, 10, 1, \n0, 10, 1, 11, \n0, 10, 1, 11, 2, \n0, 10, 1, 11, 2, 12, \n0, 0, 10, 1, 11, 2, 12, 13, 3, \nException in thread &quot;Thread-1&quot; java.util.ConcurrentModificationException\n    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)\n    at java.util.ArrayList$Itr.next(ArrayList.java:859)\n    at chap03.FailFastTest.printAll(FailFastTest.java:59)\n    at chap03.FailFastTest.access$300(FailFastTest.java:13)\n    at chap03.FailFastTest$Thread2.run(FailFastTest.java:50)\n0, 10, 1, 11, 2, 12, 13, 3, 4, \n0, 10, 1, 11, 2, 12, 13, 3, 4, 5, \n</code></pre>\n<p>结果说明：\n(1) FastFailTest中通过 new Thread1().start() 和 new Thread2().start() 同时启动两个线程去操作list。\n    Thread1线程：向list中依次添加0,1,2,3,4,5。每添加一个数之后，就通过printAll()遍历整个list。\n    Thread2线程：向list中依次添加10,11,12,13,14,15。每添加一个数之后，就通过printAll()遍历整个list。<br>\n(2) 当某一个线程遍历list的过程中，list的内容被另外一个线程所改变了；就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>\n<h2 id=\"fail-fast原理\">fail-fast原理</h2>\n<p>产生fail-fast事件，是通过抛出ConcurrentModificationException异常来触发的。\n那么，ArrayList是如何抛出ConcurrentModificationException异常的呢?</p>\n<p>我们知道，ConcurrentModificationException是在操作Iterator时抛出的异常。我们先看看Iterator的源码。ArrayList的Iterator是在父类AbstractList.java中实现的。代码如下:</p>\n<pre><code class=\"language-java\">    // 返回List对应的迭代器。实际上，是返回Itr对象\n    public Iterator&lt;E&gt; iterator() {\n        return new Itr();\n    }\n\n    // Itr是Iterator的实现类\n    private class Itr implements Iterator&lt;E&gt; {\n        /**\n         * 后续调用next返回的元素索引\n         */\n        int cursor = 0;\n\n        /**\n         * 最近调用next或previous返回的元素索引。\n         */\n        int lastRet = -1;\n\n        /**\n         * 迭代器所期望的modCount值。\n         * 每次新建Itr()对象时，都会保存新建该对象时对应的modCount；\n         * 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等；\n     * 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。\n         */\n        int expectedModCount = modCount;\n\n        public boolean hasNext() {\n            return cursor != size();\n        }\n\n        public E next() {\n        // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等；\n        // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。\n            checkForComodification();\n            try {\n                int i = cursor;\n                E next = get(i);\n                lastRet = i;\n                cursor = i + 1;\n                return next;\n            } catch (IndexOutOfBoundsException e) {\n                checkForComodification();\n                throw new NoSuchElementException();\n            }\n        }\n\n        public void remove() {\n            if (lastRet &lt; 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try {\n                AbstractList.this.remove(lastRet);\n                if (lastRet &lt; cursor)\n                    cursor--;\n                lastRet = -1;\n                expectedModCount = modCount;\n            } catch (IndexOutOfBoundsException e) {\n                throw new ConcurrentModificationException();\n            }\n        }\n    // 检查是否修改\n        final void checkForComodification() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n        }\n    }</code></pre>\n<p>从中，我们可以发现在调用 next() 和 remove()时，都会执行 checkForComodification()。可以看出，该方法才是判断是否抛出ConcurrentModificationException异常的关键。在该段代码中，当modCount != expectedModCount\n时，就会抛出该异常。</p>\n<p>从Itr类中，我们知道 expectedModCount 在创建Itr对象时，被赋值为 modCount。通过Itr，我们知道：expectedModCount不可能被修改为不等于 modCount。所以，需要考证的就是modCount何时会被修改。</p>\n<p>接下来，我们查看ArrayList的源码，来看看modCount是如何被修改的。\n<a href=\"http://www.dblearn.cn/article/42\">ArrayList源码解析&gt;&gt;</a></p>\n<p>从中，我们发现：无论是add()、remove()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化，这样在checkForComodification方法中就会抛出ConcurrentModificationException异常。</p>\n<h2 id=\"fail-fast解决\">fail-fast解决</h2>\n<h3 id=\"使用迭代器的remove方法\">使用迭代器的remove方法</h3>\n<p>在单线程的遍历过程中，如果要进行remove操作，可以调用迭代器的remove方法而不是集合类的remove方法。看看ArrayList中迭代器的remove方法的源码：</p>\n<pre><code class=\"language-java\">        public void remove() {\n            if (lastRet &lt; 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try {\n                ArrayList.this.remove(lastRet);\n                cursor = lastRet;\n                lastRet = -1;\n                expectedModCount = modCount;\n            } catch (IndexOutOfBoundsException ex) {\n                throw new ConcurrentModificationException();\n            }\n        }</code></pre>\n<p>可以看到，该remove方法并不会修改modCount的值，并且不会对后面的遍历造成影响，因为该方法remove不能指定元素，只能remove当前遍历过的那个元素，所以调用该方法并不会发生fail-fast现象。</p>\n<h3 id=\"使用javautilconcurrent包下对应的类\">使用java.util.concurrent包下对应的类</h3>\n<p>若在多线程环境下使用fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”\n所以，本例中只需要将ArrayList替换成java.util.concurrent包下对应的类即可。\n即，将代码</p>\n<pre><code class=\"language-java\">private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></pre>\n<p>替换为</p>\n<pre><code class=\"language-java\">private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();</code></pre>\n<p>则可以解决该办法。</p>\n',47,0,2,NULL,NULL,'2019-09-16 14:24:36','2020-10-09 23:58:10',0,'32,34,56',1,0),(17,'Java集合05——LinkedList','LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。','Bobbi','## LinkedList介绍\n```java\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n```\nLinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。\nLinkedList 实现 List 接口，能对它进行队列操作。\nLinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。\nLinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。\nLinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。\nLinkedList 是非同步的。\n\n### AbstractSequentialList简介\nLinkedList是AbstractSequentialList的子类。\nAbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些函数。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。\n\n此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。\n\n## LinkedList数据结构\n\n![image.png](http://oss.osalien.com/dbblog/20201010/e947de3d3511490791e38162b14c01a2.png)\n\nLinkedList的本质是双向链表。\n\n1. LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。 \n2. LinkedList包含三个重要的成员：first、last 和 size。<br>\n　　first是双向链表的表头，last是双向列表的表尾。它们是是双向链表节点所对应的类Node的实例。Node中包含成员变量： previous, next, item。其中，previous是该节点的上一个节点，next是该节点的下一个节点，item是该节点所包含的值。 <br>\n　　size是双向链表中节点的个数。\n\n## 构造方法\n```java\n    public LinkedList() {\n    }\n\n    /**\n     * 创建一个包含collection的LinkedList\n     */\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n```\nLinkedList() 构造一个空列表。\n\nLinkedList(Collection<? extends E> c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用 LinkedList()，构造一个空列表，然后调用了 addAll() 方法将 Collection 中的所有元素添加到列表中。以下是 addAll() 的源代码：\n```java\n    public boolean addAll(Collection<? extends E> c) {\n        return addAll(size, c);\n    }\n\n    public boolean addAll(int index, Collection<? extends E> c) {\n        // 检查插入位置index是否越界\n        checkPositionIndex(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n\n        // 获取上一个节点,及插入位置的节点\n        LinkedList.Node<E> pred, succ;\n        //如果插入位置为尾部，succ则为null，原来链表的last设置为此刻的pred节点\n        if (index == size) {\n            succ = null;\n            pred = last;\n        } else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        // 执行插入操作\n        for (Object o : a) {\n            @SuppressWarnings(\"unchecked\") E e = (E) o;\n            LinkedList.Node<E> newNode = new LinkedList.Node<>(pred, e, null);\n            // 如果pred为空，此Node就为first节点\n            if (pred == null)\n                first = newNode;\n            else\n                // 尾插法\n                pred.next = newNode;\n            pred = newNode;\n        }\n        // 如果succ为空（末尾），就把插入的最后一个节点设为last\n        if (succ == null) {\n            last = pred;\n        } else {\n            //否则，把之前保存的succ接到pred后面,并且把succ的前向指针指向插入的最后一个元素\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numNew;\n        modCount++;\n        return true;\n    }\n\n```	\n经过上边的代码注释可以了解到，LinkedList 批量添加节点的方法大体分下面几个步骤：\n\n1. 检查索引值是否合法，不合法将抛出角标越界异常\n2. 保存 index 位置的节点，和 index-1 位置的节点，用于链表的增删操作\n3. 将参数集合转化为数组，循环将数组中的元素封装为节点添加到链表中。\n4. 更新链表长度并返回添加 true 表示添加成功。\n\n\n## LinkedList的API\n```java\n    // 将指定的元素追加到此列表的末尾。\n    boolean	add(E e);\n    // 在此列表中的指定位置插入指定的元素。\n    void	add(int index, E element);\n    // 将集合中的所有元素追加到此列表的末尾。\n    boolean	addAll(Collection<? extends E> c);\n    // 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n    boolean	addAll(int index, Collection<? extends E> c);\n    // 在该列表开头插入指定的元素。\n    void	addFirst(E e);\n    // 将指定的元素追加到此列表的末尾。\n    void	addLast(E e);\n    // 从列表中删除所有元素。\n    void	clear();\n    // 返回此 LinkedList的浅版本。\n    Object	clone();\n    // 如果此列表包含指定的元素，则返回 true 。\n    boolean	contains(Object o);\n    // 以相反的顺序返回此deque中的元素的迭代器。\n    Iterator<E>	descendingIterator();\n    // 检索但不删除此列表的头（第一个元素）。\n    E	element();\n    // 返回此列表中指定位置的元素。\n    E	get(int index);\n    // 返回此列表中的第一个元素。\n    E	getFirst();\n    // 返回此列表中的最后一个元素。\n    E	getLast();\n    // 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。\n    int	indexOf(Object o);\n    // 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。\n    int	lastIndexOf(Object o);\n    // 从列表中的指定位置开始，返回此列表中元素的列表迭代器（按适当的顺序）。\n    ListIterator<E>	listIterator(int index);\n    // 将指定的元素添加为此列表的尾部（最后一个元素）。\n    boolean	offer(E e);\n    // 在此列表的前面插入指定的元素。\n    boolean	offerFirst(E e);\n    // 在该列表的末尾插入指定的元素。\n    boolean	offerLast(E e);\n    // 检索但不删除此列表的头（第一个元素）。\n    E	peek();\n    // 检索但不删除此列表的第一个元素，如果此列表为空，则返回 null 。\n    E	peekFirst();\n    // 检索但不删除此列表的最后一个元素，如果此列表为空，则返回 null 。\n    E	peekLast();\n    // 检索并删除此列表的头（第一个元素）。\n    E	poll();\n    // 检索并删除此列表的第一个元素，如果此列表为空，则返回 null 。\n    E	pollFirst();\n    // 检索并删除此列表的最后一个元素，如果此列表为空，则返回 null 。\n    E	pollLast();\n    // 从此列表头弹出一个元素。 removeFirst\n    E	pop();\n    // 将元素推送到由此列表头上。 addFirst\n    void	push(E e);\n    // 检索并删除此列表的头（第一个元素）。\n    E	remove();\n    // 删除该列表中指定位置的元素。\n    E	remove(int index);\n    // 从列表中删除指定元素的第一个出现（如果存在）。\n    boolean	remove(Object o);\n    // 从此列表中删除并返回第一个元素。\n    E	removeFirst();\n    // 删除此列表中指定元素的第一个出现（从头到尾遍历列表时）。\n    boolean	removeFirstOccurrence(Object o);\n    // 从此列表中删除并返回最后一个元素。\n    E	removeLast();\n    // 删除此列表中指定元素的最后一次出现（从头到尾遍历列表时）。\n    boolean	removeLastOccurrence(Object o);\n    // 用指定的元素替换此列表中指定位置的元素。\n    E	set(int index, E element);\n    // 返回此列表中的元素数。\n    int	size();\n    // 在此列表中的元素上创建并发迭代器Spliterator 。\n    Spliterator<E>	spliterator();\n    // 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。\n    Object[]	toArray();\n    // 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。\n    <T> T[]	toArray(T[] a)\n```\n\n## LinkedList 添加节点\nLinkedList 作为链表数据结构的实现，不同于数组，它可以方便的在头尾插入一个节点，而 add 方法默认在链表尾部添加节点：\n\n\n```java\n   \n    public void addFirst(E e) {\n        linkFirst(e);\n    }\n    public void addLast(E e) {\n        linkLast(e);\n    }\n    public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n```\n这一系方法都调用用了 linkXXX 方法\n```java\n    // 链接e作为第一个\n    private void linkFirst(E e) {\n	// 暂存原列头元素\n        final Node<E> f = first;\n	// 以添加的元素为节点值构建新的节点 并将 next 指针指向之前的头节点\n        final Node<E> newNode = new Node<>(null, e, f);\n        // 将first节点覆盖为新节点\n	first = newNode;\n	// 如果原头节点为空，则之前是空链，此时为单节点链表，尾结点为新节点\n        if (f == null)\n            last = newNode;\n        else\n       // 否则将原头节点的prev指针指向新的节点 \n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n\n    // 链接e作为最后一个元素\n    void linkLast(E e) {\n	// 暂存原列表末端元素\n        final Node<E> l = last;\n	// 以添加的元素为节点值构建新的节点 并将 prev 指针指向之前的尾节点\n        final Node<E> newNode = new Node<>(l, e, null);\n        // 将last节点覆盖为新节点\n	last = newNode;\n        // 如果原尾节点为空，则之前是空链，此时为单节点链表，头结点为新节点\n        if (l == null)\n            first = newNode;\n        else\n       // 否则将原尾节点的next指针指向新的节点\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n\n    // 在非null节点succ之前插入元素e\n    void linkBefore(E e, Node<E> succ) {\n        // assert succ != null;\n	// 由于 succ 一定不为空，所以可以直接获取 prev 节点\n        final Node<E> pred = succ.prev;\n        // 新节点 prev 节点为 pred，next 节点为 succ\n        final Node<E> newNode = new Node<>(pred, e, succ);\n	// 原节点的 prev 指向新节点\n        succ.prev = newNode;\n       // 如果 pred 为空即头节点处插入了一个节点，则将新的节点赋值给 first 索引\n        if (pred == null)\n            first = newNode;\n        else\n	   //否则 pred 的下一个节点改为新节点\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n\n## LinkedList 删除节点\n```java\n   /**\n     * 从此列表中删除并返回第一个元素\n     */\n    public E removeFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return unlinkFirst(f);\n    }\n\n    /**\n     * 从此列表中删除并返回最后一个元素\n     */\n    public E removeLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return unlinkLast(l);\n    }\n\n    /**\n    * 从此列表中删除指定元素的第一个匹配项，如果存在，则删\n    */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n```\n可以看出最终调用的方法为 unlinkFirst，unlinkLast 方法：\n\n```java\n    /**\n     * 取消链接非空的第一个节点f\n     */\n    private E unlinkFirst(Node<E> f) {\n        // assert f == first && f != null;\n	// 头节点的 element 这里作为返回值使用\n        final E element = f.item;\n        // 暂存头结点的下一个节点next\n        final Node<E> next = f.next;\n	// 释放头结点释放头结点next指针，帮助GC\n        f.item = null;\n        f.next = null; // help GC\n	// 将next覆盖first节点\n        first = next;\n        // 如果 next 节点为空，即链表只有一个节点的时候，last 指向 null\n        if (next == null)\n            last = null;\n        else\n	    //否则 next 的 prev 指针指向 null\n            next.prev = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n    /**\n     * 取消链接非空的最后一个节点l\n     */\n    private E unlinkLast(Node<E> l) {\n        // assert l == last && l != null;\n	// 获取末节点元素，这里做返回值使用\n        final E element = l.item;\n	// 暂存末节点的上一个节点 prev\n        final Node<E> prev = l.prev;\n	// 释放末节点，和末节点的prev指针，帮助GC\n        l.item = null; \n        l.prev = null; // help GC\n	// 将prev覆盖last节点\n        last = prev;\n	// 如果链表只有一个节点的时候，first 指向 null\n        if (prev == null)\n            first = null;\n        else\n	    // 否则prev的next指针指向null\n            prev.next = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n    /**\n     * 取消链接非空节点x.\n     */\n    E unlink(Node<E> x) {\n        // assert x != null;\n	// 获取移除元素，做返回值使用\n        final E element = x.item;\n	// 获取移除元素的前后两个节点 prev next\n        final Node<E> next = x.next;\n        final Node<E> prev = x.prev;\n\n	// 如果节点为头节点，则做 unlinkFirst 操作\n        if (prev == null) {\n            first = next;\n        } else {\n	    //否则将上一个节点的 next 指针指向下个节点\n            prev.next = next;\n            x.prev = null;\n        }\n	 // 如果节点为尾节点，则做unlinkLast操作\n        if (next == null) {\n            last = prev;\n        } else {\n	    //否则下个节点 prev 指针指向上个节点\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n```\nLinkedList 实现了 List 接口的 clear 操作，用于删除链表所有的节点：\n```java\n    /**\n     * 删除所有元素\n     */\n    public void clear() {\n        // 依次清除节点，帮助释放内存空间\n        for (Node<E> x = first; x != null; ) {\n            Node<E> next = x.next;\n            x.item = null;\n            x.next = null;\n            x.prev = null;\n            x = next;\n        }\n        first = last = null;\n        size = 0;\n        modCount++;\n    }\n```\n\n## LinkedList 查询节点\nLinkedList 查询节点的方法，可分为根据指定的索引查询，获取头节点，获取未节点三种。值得注意的是，根据索引去获取节点内容的效率并不高，所以如果查询操作多余增删操作的时候建议用 ArrayList 去替代。\n\n```java\n/**\n* 根据索引查询\n*/\npublic E get(int index) {\n   checkElementIndex(index);\n   return node(index).item;\n}\n\n/**\n* 返回 first 索引指向的节点的内容\n*/\npublic E getFirst() {\n   final Node<E> f = first;\n   if (f == null)\n       throw new NoSuchElementException();\n   return f.item;\n}\n\n/**\n* 返回 last 索引指向的节点的内容\n*/\npublic E getLast() {\n   final Node<E> l = last;\n   if (l == null)\n       throw new NoSuchElementException();\n   return l.item;\n}\n\n```\n其中node(index)方法如下：\n```java\n    // 返回指定元素索引处的（非null）节点。\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n	// 如果 index < size/2 则从0开始寻找指定角标的节点\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n	 // 如果 index >= size/2 则从 size-1 开始寻找指定角标的节点\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n\n```\nnode 方法可以用于根据指定 index 去以 size/2 为界限搜索index 位置的 Node;\n\n## LinkedList 修改节点\nLinkedList 只提供了 set(int index, E element) 一个方法。\n```java\npublic E set(int index, E element) {\n   // 判断角标是否越界\n   checkElementIndex(index);\n   // 采用 node 方法查找对应索引的节点\n   Node<E> x = node(index);\n   //保存节点原有的内容值\n   E oldVal = x.item;\n   // 设置新值\n   x.item = element;\n   // 返回旧的值\n   return oldVal;\n}\n\n```\n\n## LinkedList 双向队列\n\n### Deque 双端队列\n我们先来认识一下 Java 中的 双端队列，我们都知道 Queue 是一个队列，遵循 FIFO 准则，我们也知道 Stack 是一个栈结构，遵循 FILO 准则。 而Deque 这个双端队列就厉害了,它既可以实现栈的操作，也可以实现队列的操作，换句话说，实现了这个接口的类，既可以作为栈使用也可以作为队列使用。\n\n### LinkedList FIFO队列\nQueue中的方法：\n\n- offer() 和 add() 都是在队列中插入一个元素\n- remove() 和 poll() 方法都是从队列中删除第一个元素\n- element() 和 peek() 用于在队列的头部查询元素\n\nLinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价\n\n``` shell\n队列方法       等效方法\nadd(e)        addLast(e)\noffer(e)      offerLast(e)\nremove()      removeFirst()\npoll()        pollFirst()\nelement()     getFirst()\npeek()        peekFirst()\n```\n\n### LinkedList LIFO栈\nStack中的方法：\n- push 往栈中压入一个元素\n- pop 从栈顶获取一个元素，同时删除该元素\n- peek 从栈顶获取一个元素，但不删除元素\n\nLinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价：\n\n```shell\n栈方法        等效方法\npush(e)      addFirst(e)\npop()        removeFirst()\npeek()       peekFirst()\n```\n\n## LinkedList遍历方式\n\n1. 迭代器遍历\n```java\nfor(Iterator iter = list.iterator(); iter.hasNext();)\n    iter.next();\n```\n2. 快速随机访问遍历\n```java\nint size = list.size();\nfor (int i=0; i<size; i++) {\n    list.get(i);        \n}\n```\n3. foreach循环遍历\n```java\nfor (Integer integ:list) \n    ;\n```\n4. 通过pollFirst()来遍历\n```java\nwhile(list.pollFirst() != null)\n    ;\n```\n5. 通过pollLast()来遍历\n```java\nwhile(list.pollLast() != null)\n    ;\n```\n6. 通过removeFirst()来遍历\n```java\ntry {\n    while(list.removeFirst() != null)\n        ;\n} catch (NoSuchElementException e) {\n}\n```\n7. 通过removeLast()来遍历\n```java\ntry {\n    while(list.removeLast() != null)\n        ;\n} catch (NoSuchElementException e) {\n}\n```\n\n### 遍历方式效率比较\n```java\npublic class LinkedListTest {\n\n    public static void main(String[] args) {\n        // 通过Iterator遍历LinkedList\n        iteratorLinkedListThruIterator(getLinkedList()) ;\n\n        // 通过快速随机访问遍历LinkedList\n        iteratorLinkedListThruForeach(getLinkedList()) ;\n\n        // 通过for循环的变种来访问遍历LinkedList\n        iteratorThroughFor2(getLinkedList()) ;\n\n        // 通过PollFirst()遍历LinkedList\n        iteratorThroughPollFirst(getLinkedList()) ;\n\n        // 通过PollLast()遍历LinkedList\n        iteratorThroughPollLast(getLinkedList()) ;\n\n        // 通过removeFirst()遍历LinkedList\n        iteratorThroughRemoveFirst(getLinkedList()) ;\n\n        // 通过removeLast()遍历LinkedList\n        iteratorThroughRemoveLast(getLinkedList()) ;\n    }\n\n    private static LinkedList getLinkedList() {\n        LinkedList llist = new LinkedList();\n        for (int i=0; i<100000; i++)\n            llist.addLast(i);\n\n        return llist;\n    }\n    /**\n     * 通过快迭代器遍历LinkedList\n     */\n    private static void iteratorLinkedListThruIterator(LinkedList<Integer> list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n\n        for(Iterator iter = list.iterator(); iter.hasNext();)\n            iter.next();\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(\"iteratorLinkedListThruIterator：\" + interval+\" ms\");\n    }\n\n    /**\n     * 通过快速随机访问遍历LinkedList\n     */\n    private static void iteratorLinkedListThruForeach(LinkedList<Integer> list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n\n        int size = list.size();\n        for (int i=0; i<size; i++) {\n            list.get(i);\n        }\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(\"iteratorLinkedListThruForeach：\" + interval+\" ms\");\n    }\n\n    /**\n     * 通过另外一种for循环来遍历LinkedList\n     */\n    private static void iteratorThroughFor2(LinkedList<Integer> list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n\n        for (Integer integ:list)\n            ;\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(\"iteratorThroughFor2：\" + interval+\" ms\");\n    }\n\n    /**\n     * 通过pollFirst()来遍历LinkedList\n     */\n    private static void iteratorThroughPollFirst(LinkedList<Integer> list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n        while(list.pollFirst() != null)\n            ;\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(\"iteratorThroughPollFirst：\" + interval+\" ms\");\n    }\n\n    /**\n     * 通过pollLast()来遍历LinkedList\n     */\n    private static void iteratorThroughPollLast(LinkedList<Integer> list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n        while(list.pollLast() != null)\n            ;\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(\"iteratorThroughPollLast：\" + interval+\" ms\");\n    }\n\n    /**\n     * 通过removeFirst()来遍历LinkedList\n     */\n    private static void iteratorThroughRemoveFirst(LinkedList<Integer> list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n        try {\n            while(list.removeFirst() != null)\n                ;\n        } catch (NoSuchElementException e) {\n        }\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(\"iteratorThroughRemoveFirst：\" + interval+\" ms\");\n    }\n\n    /**\n     * 通过removeLast()来遍历LinkedList\n     */\n    private static void iteratorThroughRemoveLast(LinkedList<Integer> list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n        try {\n            while(list.removeLast() != null)\n                ;\n        } catch (NoSuchElementException e) {\n        }\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(\"iteratorThroughRemoveLast：\" + interval+\" ms\");\n    }\n\n\n\n}\n\n```\n运行结果：\n```shell\niteratorLinkedListThruIterator：10 ms\niteratorLinkedListThruForeach：4945 ms\niteratorThroughFor2：6 ms\niteratorThroughPollFirst：4 ms\niteratorThroughPollLast：4 ms\niteratorThroughRemoveFirst：3 ms\niteratorThroughRemoveLast：4 ms\n```\n结果说明：\n由此可见，遍历LinkedList时，使用removeFist()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取，而不删除，应该使用foreach遍历方式。\n\n**无论如何，千万不要通过随机访问去遍历LinkedList!!**\n\n','<h2 id=\"linkedlist介绍\">LinkedList介绍</h2>\n<pre><code class=\"language-java\">public class LinkedList&lt;E&gt;\n    extends AbstractSequentialList&lt;E&gt;\n    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code></pre>\n<p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。\nLinkedList 实现 List 接口，能对它进行队列操作。\nLinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。\nLinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。\nLinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。\nLinkedList 是非同步的。</p>\n<h3 id=\"abstractsequentiallist简介\">AbstractSequentialList简介</h3>\n<p>LinkedList是AbstractSequentialList的子类。\nAbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些函数。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。</p>\n<p>此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。</p>\n<h2 id=\"linkedlist数据结构\">LinkedList数据结构</h2>\n<p><img src=\"http://oss.osalien.com/dbblog/20201010/e947de3d3511490791e38162b14c01a2.png\" alt=\"image.png\"></p>\n<p>LinkedList的本质是双向链表。</p>\n<ol>\n<li>LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。 </li>\n<li>LinkedList包含三个重要的成员：first、last 和 size。<br>\n　　first是双向链表的表头，last是双向列表的表尾。它们是是双向链表节点所对应的类Node的实例。Node中包含成员变量： previous, next, item。其中，previous是该节点的上一个节点，next是该节点的下一个节点，item是该节点所包含的值。 <br>\n　　size是双向链表中节点的个数。</li>\n</ol>\n<h2 id=\"构造方法\">构造方法</h2>\n<pre><code class=\"language-java\">    public LinkedList() {\n    }\n\n    /**\n     * 创建一个包含collection的LinkedList\n     */\n    public LinkedList(Collection&lt;? extends E&gt; c) {\n        this();\n        addAll(c);\n    }</code></pre>\n<p>LinkedList() 构造一个空列表。</p>\n<p>LinkedList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用 LinkedList()，构造一个空列表，然后调用了 addAll() 方法将 Collection 中的所有元素添加到列表中。以下是 addAll() 的源代码：</p>\n<pre><code class=\"language-java\">    public boolean addAll(Collection&lt;? extends E&gt; c) {\n        return addAll(size, c);\n    }\n\n    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {\n        // 检查插入位置index是否越界\n        checkPositionIndex(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n\n        // 获取上一个节点,及插入位置的节点\n        LinkedList.Node&lt;E&gt; pred, succ;\n        //如果插入位置为尾部，succ则为null，原来链表的last设置为此刻的pred节点\n        if (index == size) {\n            succ = null;\n            pred = last;\n        } else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        // 执行插入操作\n        for (Object o : a) {\n            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;\n            LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node&lt;&gt;(pred, e, null);\n            // 如果pred为空，此Node就为first节点\n            if (pred == null)\n                first = newNode;\n            else\n                // 尾插法\n                pred.next = newNode;\n            pred = newNode;\n        }\n        // 如果succ为空（末尾），就把插入的最后一个节点设为last\n        if (succ == null) {\n            last = pred;\n        } else {\n            //否则，把之前保存的succ接到pred后面,并且把succ的前向指针指向插入的最后一个元素\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numNew;\n        modCount++;\n        return true;\n    }\n</code></pre>\n<p>经过上边的代码注释可以了解到，LinkedList 批量添加节点的方法大体分下面几个步骤：</p>\n<ol>\n<li>检查索引值是否合法，不合法将抛出角标越界异常</li>\n<li>保存 index 位置的节点，和 index-1 位置的节点，用于链表的增删操作</li>\n<li>将参数集合转化为数组，循环将数组中的元素封装为节点添加到链表中。</li>\n<li>更新链表长度并返回添加 true 表示添加成功。</li>\n</ol>\n<h2 id=\"linkedlist的api\">LinkedList的API</h2>\n<pre><code class=\"language-java\">    // 将指定的元素追加到此列表的末尾。\n    boolean    add(E e);\n    // 在此列表中的指定位置插入指定的元素。\n    void    add(int index, E element);\n    // 将集合中的所有元素追加到此列表的末尾。\n    boolean    addAll(Collection&lt;? extends E&gt; c);\n    // 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n    boolean    addAll(int index, Collection&lt;? extends E&gt; c);\n    // 在该列表开头插入指定的元素。\n    void    addFirst(E e);\n    // 将指定的元素追加到此列表的末尾。\n    void    addLast(E e);\n    // 从列表中删除所有元素。\n    void    clear();\n    // 返回此 LinkedList的浅版本。\n    Object    clone();\n    // 如果此列表包含指定的元素，则返回 true 。\n    boolean    contains(Object o);\n    // 以相反的顺序返回此deque中的元素的迭代器。\n    Iterator&lt;E&gt;    descendingIterator();\n    // 检索但不删除此列表的头（第一个元素）。\n    E    element();\n    // 返回此列表中指定位置的元素。\n    E    get(int index);\n    // 返回此列表中的第一个元素。\n    E    getFirst();\n    // 返回此列表中的最后一个元素。\n    E    getLast();\n    // 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。\n    int    indexOf(Object o);\n    // 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。\n    int    lastIndexOf(Object o);\n    // 从列表中的指定位置开始，返回此列表中元素的列表迭代器（按适当的顺序）。\n    ListIterator&lt;E&gt;    listIterator(int index);\n    // 将指定的元素添加为此列表的尾部（最后一个元素）。\n    boolean    offer(E e);\n    // 在此列表的前面插入指定的元素。\n    boolean    offerFirst(E e);\n    // 在该列表的末尾插入指定的元素。\n    boolean    offerLast(E e);\n    // 检索但不删除此列表的头（第一个元素）。\n    E    peek();\n    // 检索但不删除此列表的第一个元素，如果此列表为空，则返回 null 。\n    E    peekFirst();\n    // 检索但不删除此列表的最后一个元素，如果此列表为空，则返回 null 。\n    E    peekLast();\n    // 检索并删除此列表的头（第一个元素）。\n    E    poll();\n    // 检索并删除此列表的第一个元素，如果此列表为空，则返回 null 。\n    E    pollFirst();\n    // 检索并删除此列表的最后一个元素，如果此列表为空，则返回 null 。\n    E    pollLast();\n    // 从此列表头弹出一个元素。 removeFirst\n    E    pop();\n    // 将元素推送到由此列表头上。 addFirst\n    void    push(E e);\n    // 检索并删除此列表的头（第一个元素）。\n    E    remove();\n    // 删除该列表中指定位置的元素。\n    E    remove(int index);\n    // 从列表中删除指定元素的第一个出现（如果存在）。\n    boolean    remove(Object o);\n    // 从此列表中删除并返回第一个元素。\n    E    removeFirst();\n    // 删除此列表中指定元素的第一个出现（从头到尾遍历列表时）。\n    boolean    removeFirstOccurrence(Object o);\n    // 从此列表中删除并返回最后一个元素。\n    E    removeLast();\n    // 删除此列表中指定元素的最后一次出现（从头到尾遍历列表时）。\n    boolean    removeLastOccurrence(Object o);\n    // 用指定的元素替换此列表中指定位置的元素。\n    E    set(int index, E element);\n    // 返回此列表中的元素数。\n    int    size();\n    // 在此列表中的元素上创建并发迭代器Spliterator 。\n    Spliterator&lt;E&gt;    spliterator();\n    // 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。\n    Object[]    toArray();\n    // 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。\n    &lt;T&gt; T[]    toArray(T[] a)</code></pre>\n<h2 id=\"linkedlist-添加节点\">LinkedList 添加节点</h2>\n<p>LinkedList 作为链表数据结构的实现，不同于数组，它可以方便的在头尾插入一个节点，而 add 方法默认在链表尾部添加节点：</p>\n<pre><code class=\"language-java\">\n    public void addFirst(E e) {\n        linkFirst(e);\n    }\n    public void addLast(E e) {\n        linkLast(e);\n    }\n    public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }</code></pre>\n<p>这一系方法都调用用了 linkXXX 方法</p>\n<pre><code class=\"language-java\">    // 链接e作为第一个\n    private void linkFirst(E e) {\n    // 暂存原列头元素\n        final Node&lt;E&gt; f = first;\n    // 以添加的元素为节点值构建新的节点 并将 next 指针指向之前的头节点\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);\n        // 将first节点覆盖为新节点\n    first = newNode;\n    // 如果原头节点为空，则之前是空链，此时为单节点链表，尾结点为新节点\n        if (f == null)\n            last = newNode;\n        else\n       // 否则将原头节点的prev指针指向新的节点 \n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n\n    // 链接e作为最后一个元素\n    void linkLast(E e) {\n    // 暂存原列表末端元素\n        final Node&lt;E&gt; l = last;\n    // 以添加的元素为节点值构建新的节点 并将 prev 指针指向之前的尾节点\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);\n        // 将last节点覆盖为新节点\n    last = newNode;\n        // 如果原尾节点为空，则之前是空链，此时为单节点链表，头结点为新节点\n        if (l == null)\n            first = newNode;\n        else\n       // 否则将原尾节点的next指针指向新的节点\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n\n    // 在非null节点succ之前插入元素e\n    void linkBefore(E e, Node&lt;E&gt; succ) {\n        // assert succ != null;\n    // 由于 succ 一定不为空，所以可以直接获取 prev 节点\n        final Node&lt;E&gt; pred = succ.prev;\n        // 新节点 prev 节点为 pred，next 节点为 succ\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);\n    // 原节点的 prev 指向新节点\n        succ.prev = newNode;\n       // 如果 pred 为空即头节点处插入了一个节点，则将新的节点赋值给 first 索引\n        if (pred == null)\n            first = newNode;\n        else\n       //否则 pred 的下一个节点改为新节点\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }</code></pre>\n<h2 id=\"linkedlist-删除节点\">LinkedList 删除节点</h2>\n<pre><code class=\"language-java\">   /**\n     * 从此列表中删除并返回第一个元素\n     */\n    public E removeFirst() {\n        final Node&lt;E&gt; f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return unlinkFirst(f);\n    }\n\n    /**\n     * 从此列表中删除并返回最后一个元素\n     */\n    public E removeLast() {\n        final Node&lt;E&gt; l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return unlinkLast(l);\n    }\n\n    /**\n    * 从此列表中删除指定元素的第一个匹配项，如果存在，则删\n    */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }</code></pre>\n<p>可以看出最终调用的方法为 unlinkFirst，unlinkLast 方法：</p>\n<pre><code class=\"language-java\">    /**\n     * 取消链接非空的第一个节点f\n     */\n    private E unlinkFirst(Node&lt;E&gt; f) {\n        // assert f == first &amp;&amp; f != null;\n    // 头节点的 element 这里作为返回值使用\n        final E element = f.item;\n        // 暂存头结点的下一个节点next\n        final Node&lt;E&gt; next = f.next;\n    // 释放头结点释放头结点next指针，帮助GC\n        f.item = null;\n        f.next = null; // help GC\n    // 将next覆盖first节点\n        first = next;\n        // 如果 next 节点为空，即链表只有一个节点的时候，last 指向 null\n        if (next == null)\n            last = null;\n        else\n        //否则 next 的 prev 指针指向 null\n            next.prev = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n    /**\n     * 取消链接非空的最后一个节点l\n     */\n    private E unlinkLast(Node&lt;E&gt; l) {\n        // assert l == last &amp;&amp; l != null;\n    // 获取末节点元素，这里做返回值使用\n        final E element = l.item;\n    // 暂存末节点的上一个节点 prev\n        final Node&lt;E&gt; prev = l.prev;\n    // 释放末节点，和末节点的prev指针，帮助GC\n        l.item = null; \n        l.prev = null; // help GC\n    // 将prev覆盖last节点\n        last = prev;\n    // 如果链表只有一个节点的时候，first 指向 null\n        if (prev == null)\n            first = null;\n        else\n        // 否则prev的next指针指向null\n            prev.next = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n    /**\n     * 取消链接非空节点x.\n     */\n    E unlink(Node&lt;E&gt; x) {\n        // assert x != null;\n    // 获取移除元素，做返回值使用\n        final E element = x.item;\n    // 获取移除元素的前后两个节点 prev next\n        final Node&lt;E&gt; next = x.next;\n        final Node&lt;E&gt; prev = x.prev;\n\n    // 如果节点为头节点，则做 unlinkFirst 操作\n        if (prev == null) {\n            first = next;\n        } else {\n        //否则将上一个节点的 next 指针指向下个节点\n            prev.next = next;\n            x.prev = null;\n        }\n     // 如果节点为尾节点，则做unlinkLast操作\n        if (next == null) {\n            last = prev;\n        } else {\n        //否则下个节点 prev 指针指向上个节点\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n</code></pre>\n<p>LinkedList 实现了 List 接口的 clear 操作，用于删除链表所有的节点：</p>\n<pre><code class=\"language-java\">    /**\n     * 删除所有元素\n     */\n    public void clear() {\n        // 依次清除节点，帮助释放内存空间\n        for (Node&lt;E&gt; x = first; x != null; ) {\n            Node&lt;E&gt; next = x.next;\n            x.item = null;\n            x.next = null;\n            x.prev = null;\n            x = next;\n        }\n        first = last = null;\n        size = 0;\n        modCount++;\n    }</code></pre>\n<h2 id=\"linkedlist-查询节点\">LinkedList 查询节点</h2>\n<p>LinkedList 查询节点的方法，可分为根据指定的索引查询，获取头节点，获取未节点三种。值得注意的是，根据索引去获取节点内容的效率并不高，所以如果查询操作多余增删操作的时候建议用 ArrayList 去替代。</p>\n<pre><code class=\"language-java\">/**\n* 根据索引查询\n*/\npublic E get(int index) {\n   checkElementIndex(index);\n   return node(index).item;\n}\n\n/**\n* 返回 first 索引指向的节点的内容\n*/\npublic E getFirst() {\n   final Node&lt;E&gt; f = first;\n   if (f == null)\n       throw new NoSuchElementException();\n   return f.item;\n}\n\n/**\n* 返回 last 索引指向的节点的内容\n*/\npublic E getLast() {\n   final Node&lt;E&gt; l = last;\n   if (l == null)\n       throw new NoSuchElementException();\n   return l.item;\n}\n</code></pre>\n<p>其中node(index)方法如下：</p>\n<pre><code class=\"language-java\">    // 返回指定元素索引处的（非null）节点。\n    Node&lt;E&gt; node(int index) {\n        // assert isElementIndex(index);\n    // 如果 index &lt; size/2 则从0开始寻找指定角标的节点\n        if (index &lt; (size &gt;&gt; 1)) {\n            Node&lt;E&gt; x = first;\n            for (int i = 0; i &lt; index; i++)\n                x = x.next;\n            return x;\n        } else {\n     // 如果 index &gt;= size/2 则从 size-1 开始寻找指定角标的节点\n            Node&lt;E&gt; x = last;\n            for (int i = size - 1; i &gt; index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n</code></pre>\n<p>node 方法可以用于根据指定 index 去以 size/2 为界限搜索index 位置的 Node;</p>\n<h2 id=\"linkedlist-修改节点\">LinkedList 修改节点</h2>\n<p>LinkedList 只提供了 set(int index, E element) 一个方法。</p>\n<pre><code class=\"language-java\">public E set(int index, E element) {\n   // 判断角标是否越界\n   checkElementIndex(index);\n   // 采用 node 方法查找对应索引的节点\n   Node&lt;E&gt; x = node(index);\n   //保存节点原有的内容值\n   E oldVal = x.item;\n   // 设置新值\n   x.item = element;\n   // 返回旧的值\n   return oldVal;\n}\n</code></pre>\n<h2 id=\"linkedlist-双向队列\">LinkedList 双向队列</h2>\n<h3 id=\"deque-双端队列\">Deque 双端队列</h3>\n<p>我们先来认识一下 Java 中的 双端队列，我们都知道 Queue 是一个队列，遵循 FIFO 准则，我们也知道 Stack 是一个栈结构，遵循 FILO 准则。 而Deque 这个双端队列就厉害了,它既可以实现栈的操作，也可以实现队列的操作，换句话说，实现了这个接口的类，既可以作为栈使用也可以作为队列使用。</p>\n<h3 id=\"linkedlist-fifo队列\">LinkedList FIFO队列</h3>\n<p>Queue中的方法：</p>\n<ul>\n<li>offer() 和 add() 都是在队列中插入一个元素</li>\n<li>remove() 和 poll() 方法都是从队列中删除第一个元素</li>\n<li>element() 和 peek() 用于在队列的头部查询元素</li>\n</ul>\n<p>LinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价</p>\n<pre><code class=\"language-shell\">队列方法       等效方法\nadd(e)        addLast(e)\noffer(e)      offerLast(e)\nremove()      removeFirst()\npoll()        pollFirst()\nelement()     getFirst()\npeek()        peekFirst()</code></pre>\n<h3 id=\"linkedlist-lifo栈\">LinkedList LIFO栈</h3>\n<p>Stack中的方法：</p>\n<ul>\n<li>push 往栈中压入一个元素</li>\n<li>pop 从栈顶获取一个元素，同时删除该元素</li>\n<li>peek 从栈顶获取一个元素，但不删除元素</li>\n</ul>\n<p>LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价：</p>\n<pre><code class=\"language-shell\">栈方法        等效方法\npush(e)      addFirst(e)\npop()        removeFirst()\npeek()       peekFirst()</code></pre>\n<h2 id=\"linkedlist遍历方式\">LinkedList遍历方式</h2>\n<ol>\n<li>迭代器遍历<pre><code class=\"language-java\">for(Iterator iter = list.iterator(); iter.hasNext();)\n iter.next();</code></pre>\n</li>\n<li>快速随机访问遍历<pre><code class=\"language-java\">int size = list.size();\nfor (int i=0; i&lt;size; i++) {\n list.get(i);        \n}</code></pre>\n</li>\n<li>foreach循环遍历<pre><code class=\"language-java\">for (Integer integ:list) \n ;</code></pre>\n</li>\n<li>通过pollFirst()来遍历<pre><code class=\"language-java\">while(list.pollFirst() != null)\n ;</code></pre>\n</li>\n<li>通过pollLast()来遍历<pre><code class=\"language-java\">while(list.pollLast() != null)\n ;</code></pre>\n</li>\n<li>通过removeFirst()来遍历<pre><code class=\"language-java\">try {\n while(list.removeFirst() != null)\n     ;\n} catch (NoSuchElementException e) {\n}</code></pre>\n</li>\n<li>通过removeLast()来遍历<pre><code class=\"language-java\">try {\n while(list.removeLast() != null)\n     ;\n} catch (NoSuchElementException e) {\n}</code></pre>\n</li>\n</ol>\n<h3 id=\"遍历方式效率比较\">遍历方式效率比较</h3>\n<pre><code class=\"language-java\">public class LinkedListTest {\n\n    public static void main(String[] args) {\n        // 通过Iterator遍历LinkedList\n        iteratorLinkedListThruIterator(getLinkedList()) ;\n\n        // 通过快速随机访问遍历LinkedList\n        iteratorLinkedListThruForeach(getLinkedList()) ;\n\n        // 通过for循环的变种来访问遍历LinkedList\n        iteratorThroughFor2(getLinkedList()) ;\n\n        // 通过PollFirst()遍历LinkedList\n        iteratorThroughPollFirst(getLinkedList()) ;\n\n        // 通过PollLast()遍历LinkedList\n        iteratorThroughPollLast(getLinkedList()) ;\n\n        // 通过removeFirst()遍历LinkedList\n        iteratorThroughRemoveFirst(getLinkedList()) ;\n\n        // 通过removeLast()遍历LinkedList\n        iteratorThroughRemoveLast(getLinkedList()) ;\n    }\n\n    private static LinkedList getLinkedList() {\n        LinkedList llist = new LinkedList();\n        for (int i=0; i&lt;100000; i++)\n            llist.addLast(i);\n\n        return llist;\n    }\n    /**\n     * 通过快迭代器遍历LinkedList\n     */\n    private static void iteratorLinkedListThruIterator(LinkedList&lt;Integer&gt; list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n\n        for(Iterator iter = list.iterator(); iter.hasNext();)\n            iter.next();\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(&quot;iteratorLinkedListThruIterator：&quot; + interval+&quot; ms&quot;);\n    }\n\n    /**\n     * 通过快速随机访问遍历LinkedList\n     */\n    private static void iteratorLinkedListThruForeach(LinkedList&lt;Integer&gt; list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n\n        int size = list.size();\n        for (int i=0; i&lt;size; i++) {\n            list.get(i);\n        }\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(&quot;iteratorLinkedListThruForeach：&quot; + interval+&quot; ms&quot;);\n    }\n\n    /**\n     * 通过另外一种for循环来遍历LinkedList\n     */\n    private static void iteratorThroughFor2(LinkedList&lt;Integer&gt; list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n\n        for (Integer integ:list)\n            ;\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(&quot;iteratorThroughFor2：&quot; + interval+&quot; ms&quot;);\n    }\n\n    /**\n     * 通过pollFirst()来遍历LinkedList\n     */\n    private static void iteratorThroughPollFirst(LinkedList&lt;Integer&gt; list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n        while(list.pollFirst() != null)\n            ;\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(&quot;iteratorThroughPollFirst：&quot; + interval+&quot; ms&quot;);\n    }\n\n    /**\n     * 通过pollLast()来遍历LinkedList\n     */\n    private static void iteratorThroughPollLast(LinkedList&lt;Integer&gt; list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n        while(list.pollLast() != null)\n            ;\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(&quot;iteratorThroughPollLast：&quot; + interval+&quot; ms&quot;);\n    }\n\n    /**\n     * 通过removeFirst()来遍历LinkedList\n     */\n    private static void iteratorThroughRemoveFirst(LinkedList&lt;Integer&gt; list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n        try {\n            while(list.removeFirst() != null)\n                ;\n        } catch (NoSuchElementException e) {\n        }\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(&quot;iteratorThroughRemoveFirst：&quot; + interval+&quot; ms&quot;);\n    }\n\n    /**\n     * 通过removeLast()来遍历LinkedList\n     */\n    private static void iteratorThroughRemoveLast(LinkedList&lt;Integer&gt; list) {\n        if (list == null)\n            return ;\n\n        // 记录开始时间\n        long start = System.currentTimeMillis();\n        try {\n            while(list.removeLast() != null)\n                ;\n        } catch (NoSuchElementException e) {\n        }\n\n        // 记录结束时间\n        long end = System.currentTimeMillis();\n        long interval = end - start;\n        System.out.println(&quot;iteratorThroughRemoveLast：&quot; + interval+&quot; ms&quot;);\n    }\n\n\n\n}\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-shell\">iteratorLinkedListThruIterator：10 ms\niteratorLinkedListThruForeach：4945 ms\niteratorThroughFor2：6 ms\niteratorThroughPollFirst：4 ms\niteratorThroughPollLast：4 ms\niteratorThroughRemoveFirst：3 ms\niteratorThroughRemoveLast：4 ms</code></pre>\n<p>结果说明：\n由此可见，遍历LinkedList时，使用removeFist()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取，而不删除，应该使用foreach遍历方式。</p>\n<p><strong>无论如何，千万不要通过随机访问去遍历LinkedList!!</strong></p>\n',55,0,2,NULL,NULL,'2019-09-19 04:55:10','2020-10-10 00:07:43',0,'32,34,56',1,0),(18,'Java集合06——Map框架','Map 是一个键值对(key-value)映射接口。Map映射中不能包含重复的键；每个键最多只能映射到一个值','Bobbi','## Map数据结构\n\n![image.png](http://oss.osalien.com/dbblog/20201010/214562be36e74df69a519a613293f98a.png)\n\n1.Map 是映射接口，Map中存储的内容是键值对(key-value)。\n2. AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。\n3. SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。\n4. NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如\"获取大于/等于某对象的键值对\"、“获取小于/等于某对象的键值对”等等。 \n5. TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“有序的键值对”！\n6. HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“键值对，但不保证次序”！\n7. Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“键值对，也不保证次序”。但和HashMap相比，Hashtable是线程安全的\n8. WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，WeakHashMap的键是“弱键”。\n\n## Map 简介\nMap的定义如下：\n```java\npublic interface Map<K,V> { }\n```\n\nMap 是一个键值对(key-value)映射接口。Map映射中不能包含重复的键；每个键最多只能映射到一个值。\n\nMap 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。\n\nMap 映射顺序。有些实现类，可以明确保证其顺序，如 TreeMap；另一些映射实现则不保证顺序，如 HashMap 类。\n\nMap 的实现类应该提供2个“标准的”构造方法：第一个，void（无参数）构造方法，用于创建空映射；第二个，带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新映射。实际上，后一个构造方法允许用户复制任意映射，生成所需类的一个等价映射。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK 中所有通用的映射实现都遵从它。\n\n### Map的API\n```java\n    // 以下是查询操作\n\n    /**\n     * 返回此Map的键值对数量\n     */\n    int size();\n\n    /**\n     * 判断Map中是否包含键值对\n     */\n    boolean isEmpty();\n\n    /**\n     * 如果此映射包含指定键的映射，则返回 true\n     */\n    boolean containsKey(Object key);\n\n    /**\n     * 如果此映射包含指定键的映射，则返回 true 。\n     */\n    boolean containsValue(Object value);\n\n    /**\n     * 返回到指定键所映射的值。\n     */\n    V get(Object key);\n\n    // 以下为修改操作\n\n    /**\n     * 将指定的值与该映射中的指定键相关联\n     */\n    V put(K key, V value);\n\n    /**\n     * 从该Map中删除一个键的映射。\n     */\n    V remove(Object key);\n\n\n    // 以下是批量操作\n\n    /**\n     * 将指定映射中的所有映射复制到此映射\n     */\n    void putAll(Map<? extends K, ? extends V> m);\n\n    /**\n     * 从此映射中删除所有映射\n     */\n    void clear();\n\n\n    // 以下是视图\n\n    /**\n     * 返回此映射中包含的键的视图。\n     */\n    Set<K> keySet();\n\n    /**\n     * 返回此映射中包含的值的视图。\n     */\n    Collection<V> values();\n\n    /**\n     * 返回此映射中包含的映射的视图。\n     */\n    Set<Map.Entry<K, V>> entrySet();\n\n\n    // 可违约的方法 defaulable\n\n    /**\n     * 返回指定键所映射到的值；如果此映射不包含该键的映射，则返回defaultValue。\n     */\n    default V getOrDefault(Object key, V defaultValue) {\n        V v;\n        return (((v = get(key)) != null) || containsKey(key))\n                ? v\n                : defaultValue;\n    }\n\n    /**\n     * Java8 forEach 遍历\n     */\n    default void forEach(BiConsumer<? super K, ? super V> action) {\n        Objects.requireNonNull(action);\n        for (Map.Entry<K, V> entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n            action.accept(k, v);\n        }\n    }\n\n    /**\n     * 将所有条目的值替换为对该条目调用给定函数的结果，直到处理完所有条目为止\n     */\n    default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n        Objects.requireNonNull(function);\n        for (Map.Entry<K, V> entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n\n            // ise thrown from function is not a cme.\n            v = function.apply(k, v);\n\n            try {\n                entry.setValue(v);\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n        }\n    }\n\n    /**\n     * 如果指定的键尚未与某个值相关联（或映射到 null ）将其与给定值相关联并返回 null ，否则返回当前值。\n     */\n    default V putIfAbsent(K key, V value) {\n        V v = get(key);\n        if (v == null) {\n            v = put(key, value);\n        }\n\n        return v;\n    }\n\n    /**\n     * 仅当指定的密钥当前映射到指定的值时删除该条目。\n     */\n    default boolean remove(Object key, Object value) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, value) ||\n                (curValue == null && !containsKey(key))) {\n            return false;\n        }\n        remove(key);\n        return true;\n    }\n\n    /**\n     * 仅当当前映射到指定的值时，才能替换指定键的条目。\n     */\n    default boolean replace(K key, V oldValue, V newValue) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, oldValue) ||\n                (curValue == null && !containsKey(key))) {\n            return false;\n        }\n        put(key, newValue);\n        return true;\n    }\n\n    /**\n     * 只有当目标映射到某个值时，才能替换指定键的条目。\n     */\n    default V replace(K key, V value) {\n        V curValue;\n        if (((curValue = get(key)) != null) || containsKey(key)) {\n            curValue = put(key, value);\n        }\n        return curValue;\n    }\n\n    /**\n     * 如果指定的键尚未与值相关联（或映射到 null ），则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非 null 。\n     */\n    default V computeIfAbsent(K key,\n                              Function<? super K, ? extends V> mappingFunction) {\n        Objects.requireNonNull(mappingFunction);\n        V v;\n        if ((v = get(key)) == null) {\n            V newValue;\n            if ((newValue = mappingFunction.apply(key)) != null) {\n                put(key, newValue);\n                return newValue;\n            }\n        }\n\n        return v;\n    }\n\n    /**\n     * 如果指定的密钥的值存在且非空，则尝试计算给定密钥及其当前映射值的新映射。\n     */\n    default V computeIfPresent(K key,\n                               BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue;\n        if ((oldValue = get(key)) != null) {\n            V newValue = remappingFunction.apply(key, oldValue);\n            if (newValue != null) {\n                put(key, newValue);\n                return newValue;\n            } else {\n                remove(key);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * 尝试计算指定键的映射及其当前映射的值（如果没有当前映射， null ）。\n     */\n    default V compute(K key,\n                      BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue = get(key);\n\n        V newValue = remappingFunction.apply(key, oldValue);\n        if (newValue == null) {\n            // delete mapping\n            if (oldValue != null || containsKey(key)) {\n                // something to remove\n                remove(key);\n                return null;\n            } else {\n                // nothing to do. Leave things as they were.\n                return null;\n            }\n        } else {\n            // add or replace old mapping\n            put(key, newValue);\n            return newValue;\n        }\n    }\n\n    /**\n     * 如果指定的键尚未与值相关联或与null相关联，则将其与给定的非空值相关联。\n     */\n    default V merge(K key, V value,\n                    BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        Objects.requireNonNull(value);\n        V oldValue = get(key);\n        V newValue = (oldValue == null) ? value :\n                remappingFunction.apply(oldValue, value);\n        if(newValue == null) {\n            remove(key);\n        } else {\n            put(key, newValue);\n        }\n        return newValue;\n    }\n```\n##  Map.Entry\nMap.Entry的定义如下：\n```java\ninterface Entry<K,V> { }\n```\nMap.Entry是Map中内部的一个接口，Map.Entry是键值对，Map通过 entrySet() 获取Map.Entry的键值对集合，从而通过该集合实现对键值对的操作。\n\n### Map.Entity的API\n```java\n   /**\n     * 返回此Entity对应的key。\n     */\n    K getKey();\n\n    /**\n     * 返回此Entity对应的value。\n     */\n    V getValue();\n\n    /**\n     * 替换此Entity的value\n     */\n    V setValue(V value);\n\n    /**\n     * equals方法\n     */\n    boolean equals(Object o);\n\n    /**\n     * 获取hashCode\n     */\n    int hashCode();\n\n    /**\n     * 返回一个比较器，该比较器以自然顺序比较key。\n     */\n    public static <K extends Comparable<? super K>, V> Comparator<Map.Entry<K,V>> comparingByKey() {\n        return (Comparator<Map.Entry<K, V>> & Serializable)\n                (c1, c2) -> c1.getKey().compareTo(c2.getKey());\n    }\n\n    /**\n     * 返回一个比较器，该比较器以自然顺序比较value。\n     */\n    public static <K, V extends Comparable<? super V>> Comparator<Map.Entry<K,V>> comparingByValue() {\n        return (Comparator<Map.Entry<K, V>> & Serializable)\n                (c1, c2) -> c1.getValue().compareTo(c2.getValue());\n    }\n\n    /**\n     * 返回一个比较器，该比较器使用给定的Comparator按key比较\n     */\n    public static <K, V> Comparator<Map.Entry<K, V>> comparingByKey(Comparator<? super K> cmp) {\n        Objects.requireNonNull(cmp);\n        return (Comparator<Map.Entry<K, V>> & Serializable)\n                (c1, c2) -> cmp.compare(c1.getKey(), c2.getKey());\n    }\n\n    /**\n     * 返回一个比较器，该比较器使用给定的Comparator按value比较\n     */\n    public static <K, V> Comparator<Map.Entry<K, V>> comparingByValue(Comparator<? super V> cmp) {\n        Objects.requireNonNull(cmp);\n        return (Comparator<Map.Entry<K, V>> & Serializable)\n                (c1, c2) -> cmp.compare(c1.getValue(), c2.getValue());\n    }\n\n```\n\n## AbstractMap\nAbstractMap的定义如下：\n```java\npublic abstract class AbstractMap<K,V> implements Map<K,V> {}\n```\nAbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。\n\n### AbstractMap的API\n```java\n    // 从该Map中删除所有的映射（可选操作）。\n    void	clear()\n    // 返回此 AbstractMap实例的浅拷贝：键和值本身不被克隆。\n    protected Object	clone()\n    // 如果此映射包含指定键的映射，则返回 true 。\n    boolean	containsKey(Object key)\n    // 如果此映射将一个或多个键映射到指定的值，则返回 true 。\n    boolean	containsValue(Object value)\n    // 返回此Map中包含的映射的Set视图。\n    abstract Set<Map.Entry<K,V>>	entrySet()\n\n    boolean	equals(Object o)\n    int	hashCode()\n    String	toString()\n\n    // 返回到指定键所映射的值\n    V	get(Object key)\n    // 如果此Map不包含键值映射，则返回 true 。\n    boolean	isEmpty()\n    // 返回此地图中包含的键的Set视图。\n    Set<K>	keySet()\n    // 将指定的值与该映射中的指定键相关联（可选操作）。\n    V	put(K key, V value)\n    // 将指定Map的所有映射复制到此映射（可选操作）。\n    void	putAll(Map<? extends K,? extends V> m)\n    // 如果存在（从可选的操作），从该Map中删除一个键的映射。\n    V	remove(Object key)\n    // 返回此Map中键值映射的数量。\n    int	size()\n    // 返回此Map中包含的值的Collection视图。\n    Collection<V>	values()\n```\n\n## SortedMap\nSortedMap的定义如下：\n```java\npublic interface SortedMap<K,V> extends Map<K,V> { }\n```\nSortedMap是一个继承于Map接口的接口。它是一个有序的SortedMap键值映射。\nSortedMap的排序方式有两种：自然排序 或者 用户指定比较器。 插入有序 SortedMap 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）。\n\n### SortedMap的API\n```java\n    // 返回用于订购此Map中的键的比较器\n    Comparator<? super K>	comparator()\n    // 返回此Map中包含的映射的Set视图。\n    Set<Map.Entry<K,V>>	entrySet()\n    // 返回此Map中当前的第一个键。\n    K	firstKey()\n    // 返回该Map的部分key严格小于 toKey 。\n    SortedMap<K,V>	headMap(K toKey)\n    // 返回此Map中包含的键的Set视图。\n    Set<K>	keySet()\n    // 返回当前在此Map中的最后（最高）键。\n    K	lastKey()\n    // 返回此Map部分的视图，其关键字范围为 fromKey （含）到 toKey（不含）。\n    SortedMap<K,V>	subMap(K fromKey, K toKey)\n    // 返回此Map部分的视图，其键大于或等于 fromKey 。\n    SortedMap<K,V>	tailMap(K fromKey)\n    // 返回此地图中包含的值的Collection视图。\n    Collection<V>	values()\n```\n\n## NavigableMap\nNavigableMap的定义如下：\n```java\npublic interface NavigableMap<K,V> extends SortedMap<K,V> { }\n```\nNavigableMap是继承于SortedMap的接口。它是一个可导航的键-值对集合，具有了为给定搜索目标报告最接近匹配项的导航方法。\nNavigableMap分别提供了获取“键”、“键-值对”、“键集”、“键-值对集”的相关方法。\n\n### NavigableMap的API\n```java\n    // 返回与大于或等于给定键的最小键相关联的键值映射\n    K	ceilingKey(K key)\n    // 返回大于或等于给定键的 null键\n    Map.Entry<K,V>	ceilingEntry(K key)\n    // 返回此Map中包含的键的相反顺序NavigableSet 。\n    NavigableSet<K>	descendingKeySet()\n    // 返回此映射中包含的映射的反向排序视图。\n    NavigableMap<K,V>	descendingMap()\n    // 返回与该Map中的最小键相关联的键值映射，如果Map为空，则返回 null 。\n    Map.Entry<K,V>	firstEntry()\n    // 返回与小于或等于给定键的最大键相关联的键值映射，如果没有此键，则 null 。\n    Map.Entry<K,V>	floorEntry(K key)\n    // 返回小于或等于给定键的最大键，如果没有这样的键，则返回 null 。\n    K	floorKey(K key)\n    // 返回此Map部分的视图，其密钥严格小于 toKey 。\n    SortedMap<K,V>	headMap(K toKey)\n    // 返回该Map部分的视图，其键值小于（或等于，如果 inclusive为真） toKey 。\n    NavigableMap<K,V>	headMap(K toKey, boolean inclusive)\n    // 返回与最小密钥相关联的密钥值映射严格大于给定密钥，如果没有这样的密钥则 null 。\n    Map.Entry<K,V>	higherEntry(K key)\n    // 返回严格大于给定键的最小键，如果没有这样的键，则返回 null 。\n    K	higherKey(K key)\n    // 返回与该Map中最大键相关联的键值映射，如果Map为空，则返回 null 。\n    Map.Entry<K,V>	lastEntry()\n    // 返回与最大密钥相关联的密钥值映射严格小于给定密钥，如果没有这样的密钥则 null 。\n    Map.Entry<K,V>	lowerEntry(K key)\n    // 返回严格小于给定键的最大键，如果没有这样的键，则返回 null 。\n    K	lowerKey(K key)\n    // 返回此Map中包含的键的NavigableSet视图。\n    NavigableSet<K>	navigableKeySet()\n    // 删除并返回与该Map中的最小键相关联的键值映射，如果Map为空，则返回 null 。\n    Map.Entry<K,V>	pollFirstEntry()\n    // 删除并返回与该Map中最大键相关联的键值映射，如果Map为空，则返回 null 。\n    Map.Entry<K,V>	pollLastEntry()\n    // 返回此Map部分的视图，其关键字范围为 fromKey至 toKey 。\n    NavigableMap<K,V>	subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)\n    // 返回此Map部分的视图，其关键字范围为 fromKey （含），不 toKey toKey。\n    SortedMap<K,V>	subMap(K fromKey, K toKey)\n    // 返回此Map部分的视图，其键大于或等于 fromKey 。\n    SortedMap<K,V>	tailMap(K fromKey)\n    // 返回此Map部分的视图，其键大于（或等于，如果 inclusive为真） fromKey 。\n    NavigableMap<K,V>	tailMap(K fromKey, boolean inclusive)\n```\n\nNavigableMap除了继承SortedMap的特性外，它的提供的功能可以分为4类：<br>\n第1类，提供操作键-值对的方法。<br>\n               lowerEntry、floorEntry、ceilingEntry 和 higherEntry 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象。<br>\n               firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。<br>\n\n第2类，提供操作键的方法。这个和第1类比较类似<br>\n               lowerKey、floorKey、ceilingKey 和 higherKey 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键。<br>\n第3类，获取键集。<br>\n              navigableKeySet、descendingKeySet分别获取正序/反序的键集。<br>\n第4类，获取键-值对的子集\n \n## Dictionary\nDictionary的定义如下：\n```java\npublic abstract class Dictionary<K,V> {}\n```\nDictionary是JDK 1.0定义的键值对的接口，它也包括了操作键值对的基本函数。\n\n### Dictionary的API\n```java\n    // 返回此字典中值的枚举。\n    abstract Enumeration<V>	elements()\n    // 返回该字典中键映射到的值。\n    abstract V	get(Object key)\n    // 测试这个字典是否将键值映射到值。\n    abstract boolean	isEmpty()\n    // 返回此字典中键的枚举。\n    abstract Enumeration<K>	keys()\n    // 将指定的key key到本字典中 value的value。\n    abstract V	put(K key, V value)\n    // 从该字典中删除 key （及其对应的 value ）。\n    abstract V	remove(Object key)\n    // 返回此字典中的条目数（不同的键）。\n    abstract int	size()\n```','<h2 id=\"map数据结构\">Map数据结构</h2>\n<p><img src=\"http://oss.osalien.com/dbblog/20201010/214562be36e74df69a519a613293f98a.png\" alt=\"image.png\"></p>\n<p>1.Map 是映射接口，Map中存储的内容是键值对(key-value)。</p>\n<ol start=\"2\">\n<li>AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。</li>\n<li>SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。</li>\n<li>NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如&quot;获取大于/等于某对象的键值对&quot;、“获取小于/等于某对象的键值对”等等。 </li>\n<li>TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“有序的键值对”！</li>\n<li>HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“键值对，但不保证次序”！</li>\n<li>Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“键值对，也不保证次序”。但和HashMap相比，Hashtable是线程安全的</li>\n<li>WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，WeakHashMap的键是“弱键”。</li>\n</ol>\n<h2 id=\"map-简介\">Map 简介</h2>\n<p>Map的定义如下：</p>\n<pre><code class=\"language-java\">public interface Map&lt;K,V&gt; { }</code></pre>\n<p>Map 是一个键值对(key-value)映射接口。Map映射中不能包含重复的键；每个键最多只能映射到一个值。</p>\n<p>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。</p>\n<p>Map 映射顺序。有些实现类，可以明确保证其顺序，如 TreeMap；另一些映射实现则不保证顺序，如 HashMap 类。</p>\n<p>Map 的实现类应该提供2个“标准的”构造方法：第一个，void（无参数）构造方法，用于创建空映射；第二个，带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新映射。实际上，后一个构造方法允许用户复制任意映射，生成所需类的一个等价映射。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK 中所有通用的映射实现都遵从它。</p>\n<h3 id=\"map的api\">Map的API</h3>\n<pre><code class=\"language-java\">    // 以下是查询操作\n\n    /**\n     * 返回此Map的键值对数量\n     */\n    int size();\n\n    /**\n     * 判断Map中是否包含键值对\n     */\n    boolean isEmpty();\n\n    /**\n     * 如果此映射包含指定键的映射，则返回 true\n     */\n    boolean containsKey(Object key);\n\n    /**\n     * 如果此映射包含指定键的映射，则返回 true 。\n     */\n    boolean containsValue(Object value);\n\n    /**\n     * 返回到指定键所映射的值。\n     */\n    V get(Object key);\n\n    // 以下为修改操作\n\n    /**\n     * 将指定的值与该映射中的指定键相关联\n     */\n    V put(K key, V value);\n\n    /**\n     * 从该Map中删除一个键的映射。\n     */\n    V remove(Object key);\n\n\n    // 以下是批量操作\n\n    /**\n     * 将指定映射中的所有映射复制到此映射\n     */\n    void putAll(Map&lt;? extends K, ? extends V&gt; m);\n\n    /**\n     * 从此映射中删除所有映射\n     */\n    void clear();\n\n\n    // 以下是视图\n\n    /**\n     * 返回此映射中包含的键的视图。\n     */\n    Set&lt;K&gt; keySet();\n\n    /**\n     * 返回此映射中包含的值的视图。\n     */\n    Collection&lt;V&gt; values();\n\n    /**\n     * 返回此映射中包含的映射的视图。\n     */\n    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();\n\n\n    // 可违约的方法 defaulable\n\n    /**\n     * 返回指定键所映射到的值；如果此映射不包含该键的映射，则返回defaultValue。\n     */\n    default V getOrDefault(Object key, V defaultValue) {\n        V v;\n        return (((v = get(key)) != null) || containsKey(key))\n                ? v\n                : defaultValue;\n    }\n\n    /**\n     * Java8 forEach 遍历\n     */\n    default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {\n        Objects.requireNonNull(action);\n        for (Map.Entry&lt;K, V&gt; entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n            action.accept(k, v);\n        }\n    }\n\n    /**\n     * 将所有条目的值替换为对该条目调用给定函数的结果，直到处理完所有条目为止\n     */\n    default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {\n        Objects.requireNonNull(function);\n        for (Map.Entry&lt;K, V&gt; entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n\n            // ise thrown from function is not a cme.\n            v = function.apply(k, v);\n\n            try {\n                entry.setValue(v);\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n        }\n    }\n\n    /**\n     * 如果指定的键尚未与某个值相关联（或映射到 null ）将其与给定值相关联并返回 null ，否则返回当前值。\n     */\n    default V putIfAbsent(K key, V value) {\n        V v = get(key);\n        if (v == null) {\n            v = put(key, value);\n        }\n\n        return v;\n    }\n\n    /**\n     * 仅当指定的密钥当前映射到指定的值时删除该条目。\n     */\n    default boolean remove(Object key, Object value) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, value) ||\n                (curValue == null &amp;&amp; !containsKey(key))) {\n            return false;\n        }\n        remove(key);\n        return true;\n    }\n\n    /**\n     * 仅当当前映射到指定的值时，才能替换指定键的条目。\n     */\n    default boolean replace(K key, V oldValue, V newValue) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, oldValue) ||\n                (curValue == null &amp;&amp; !containsKey(key))) {\n            return false;\n        }\n        put(key, newValue);\n        return true;\n    }\n\n    /**\n     * 只有当目标映射到某个值时，才能替换指定键的条目。\n     */\n    default V replace(K key, V value) {\n        V curValue;\n        if (((curValue = get(key)) != null) || containsKey(key)) {\n            curValue = put(key, value);\n        }\n        return curValue;\n    }\n\n    /**\n     * 如果指定的键尚未与值相关联（或映射到 null ），则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非 null 。\n     */\n    default V computeIfAbsent(K key,\n                              Function&lt;? super K, ? extends V&gt; mappingFunction) {\n        Objects.requireNonNull(mappingFunction);\n        V v;\n        if ((v = get(key)) == null) {\n            V newValue;\n            if ((newValue = mappingFunction.apply(key)) != null) {\n                put(key, newValue);\n                return newValue;\n            }\n        }\n\n        return v;\n    }\n\n    /**\n     * 如果指定的密钥的值存在且非空，则尝试计算给定密钥及其当前映射值的新映射。\n     */\n    default V computeIfPresent(K key,\n                               BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue;\n        if ((oldValue = get(key)) != null) {\n            V newValue = remappingFunction.apply(key, oldValue);\n            if (newValue != null) {\n                put(key, newValue);\n                return newValue;\n            } else {\n                remove(key);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * 尝试计算指定键的映射及其当前映射的值（如果没有当前映射， null ）。\n     */\n    default V compute(K key,\n                      BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue = get(key);\n\n        V newValue = remappingFunction.apply(key, oldValue);\n        if (newValue == null) {\n            // delete mapping\n            if (oldValue != null || containsKey(key)) {\n                // something to remove\n                remove(key);\n                return null;\n            } else {\n                // nothing to do. Leave things as they were.\n                return null;\n            }\n        } else {\n            // add or replace old mapping\n            put(key, newValue);\n            return newValue;\n        }\n    }\n\n    /**\n     * 如果指定的键尚未与值相关联或与null相关联，则将其与给定的非空值相关联。\n     */\n    default V merge(K key, V value,\n                    BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        Objects.requireNonNull(value);\n        V oldValue = get(key);\n        V newValue = (oldValue == null) ? value :\n                remappingFunction.apply(oldValue, value);\n        if(newValue == null) {\n            remove(key);\n        } else {\n            put(key, newValue);\n        }\n        return newValue;\n    }</code></pre>\n<h2 id=\"mapentry\">Map.Entry</h2>\n<p>Map.Entry的定义如下：</p>\n<pre><code class=\"language-java\">interface Entry&lt;K,V&gt; { }</code></pre>\n<p>Map.Entry是Map中内部的一个接口，Map.Entry是键值对，Map通过 entrySet() 获取Map.Entry的键值对集合，从而通过该集合实现对键值对的操作。</p>\n<h3 id=\"mapentity的api\">Map.Entity的API</h3>\n<pre><code class=\"language-java\">   /**\n     * 返回此Entity对应的key。\n     */\n    K getKey();\n\n    /**\n     * 返回此Entity对应的value。\n     */\n    V getValue();\n\n    /**\n     * 替换此Entity的value\n     */\n    V setValue(V value);\n\n    /**\n     * equals方法\n     */\n    boolean equals(Object o);\n\n    /**\n     * 获取hashCode\n     */\n    int hashCode();\n\n    /**\n     * 返回一个比较器，该比较器以自然顺序比较key。\n     */\n    public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() {\n        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)\n                (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());\n    }\n\n    /**\n     * 返回一个比较器，该比较器以自然顺序比较value。\n     */\n    public static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() {\n        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)\n                (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());\n    }\n\n    /**\n     * 返回一个比较器，该比较器使用给定的Comparator按key比较\n     */\n    public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? super K&gt; cmp) {\n        Objects.requireNonNull(cmp);\n        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)\n                (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());\n    }\n\n    /**\n     * 返回一个比较器，该比较器使用给定的Comparator按value比较\n     */\n    public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? super V&gt; cmp) {\n        Objects.requireNonNull(cmp);\n        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)\n                (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());\n    }\n</code></pre>\n<h2 id=\"abstractmap\">AbstractMap</h2>\n<p>AbstractMap的定义如下：</p>\n<pre><code class=\"language-java\">public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; {}</code></pre>\n<p>AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。</p>\n<h3 id=\"abstractmap的api\">AbstractMap的API</h3>\n<pre><code class=\"language-java\">    // 从该Map中删除所有的映射（可选操作）。\n    void    clear()\n    // 返回此 AbstractMap实例的浅拷贝：键和值本身不被克隆。\n    protected Object    clone()\n    // 如果此映射包含指定键的映射，则返回 true 。\n    boolean    containsKey(Object key)\n    // 如果此映射将一个或多个键映射到指定的值，则返回 true 。\n    boolean    containsValue(Object value)\n    // 返回此Map中包含的映射的Set视图。\n    abstract Set&lt;Map.Entry&lt;K,V&gt;&gt;    entrySet()\n\n    boolean    equals(Object o)\n    int    hashCode()\n    String    toString()\n\n    // 返回到指定键所映射的值\n    V    get(Object key)\n    // 如果此Map不包含键值映射，则返回 true 。\n    boolean    isEmpty()\n    // 返回此地图中包含的键的Set视图。\n    Set&lt;K&gt;    keySet()\n    // 将指定的值与该映射中的指定键相关联（可选操作）。\n    V    put(K key, V value)\n    // 将指定Map的所有映射复制到此映射（可选操作）。\n    void    putAll(Map&lt;? extends K,? extends V&gt; m)\n    // 如果存在（从可选的操作），从该Map中删除一个键的映射。\n    V    remove(Object key)\n    // 返回此Map中键值映射的数量。\n    int    size()\n    // 返回此Map中包含的值的Collection视图。\n    Collection&lt;V&gt;    values()</code></pre>\n<h2 id=\"sortedmap\">SortedMap</h2>\n<p>SortedMap的定义如下：</p>\n<pre><code class=\"language-java\">public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; { }</code></pre>\n<p>SortedMap是一个继承于Map接口的接口。它是一个有序的SortedMap键值映射。\nSortedMap的排序方式有两种：自然排序 或者 用户指定比较器。 插入有序 SortedMap 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）。</p>\n<h3 id=\"sortedmap的api\">SortedMap的API</h3>\n<pre><code class=\"language-java\">    // 返回用于订购此Map中的键的比较器\n    Comparator&lt;? super K&gt;    comparator()\n    // 返回此Map中包含的映射的Set视图。\n    Set&lt;Map.Entry&lt;K,V&gt;&gt;    entrySet()\n    // 返回此Map中当前的第一个键。\n    K    firstKey()\n    // 返回该Map的部分key严格小于 toKey 。\n    SortedMap&lt;K,V&gt;    headMap(K toKey)\n    // 返回此Map中包含的键的Set视图。\n    Set&lt;K&gt;    keySet()\n    // 返回当前在此Map中的最后（最高）键。\n    K    lastKey()\n    // 返回此Map部分的视图，其关键字范围为 fromKey （含）到 toKey（不含）。\n    SortedMap&lt;K,V&gt;    subMap(K fromKey, K toKey)\n    // 返回此Map部分的视图，其键大于或等于 fromKey 。\n    SortedMap&lt;K,V&gt;    tailMap(K fromKey)\n    // 返回此地图中包含的值的Collection视图。\n    Collection&lt;V&gt;    values()</code></pre>\n<h2 id=\"navigablemap\">NavigableMap</h2>\n<p>NavigableMap的定义如下：</p>\n<pre><code class=\"language-java\">public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; { }</code></pre>\n<p>NavigableMap是继承于SortedMap的接口。它是一个可导航的键-值对集合，具有了为给定搜索目标报告最接近匹配项的导航方法。\nNavigableMap分别提供了获取“键”、“键-值对”、“键集”、“键-值对集”的相关方法。</p>\n<h3 id=\"navigablemap的api\">NavigableMap的API</h3>\n<pre><code class=\"language-java\">    // 返回与大于或等于给定键的最小键相关联的键值映射\n    K    ceilingKey(K key)\n    // 返回大于或等于给定键的 null键\n    Map.Entry&lt;K,V&gt;    ceilingEntry(K key)\n    // 返回此Map中包含的键的相反顺序NavigableSet 。\n    NavigableSet&lt;K&gt;    descendingKeySet()\n    // 返回此映射中包含的映射的反向排序视图。\n    NavigableMap&lt;K,V&gt;    descendingMap()\n    // 返回与该Map中的最小键相关联的键值映射，如果Map为空，则返回 null 。\n    Map.Entry&lt;K,V&gt;    firstEntry()\n    // 返回与小于或等于给定键的最大键相关联的键值映射，如果没有此键，则 null 。\n    Map.Entry&lt;K,V&gt;    floorEntry(K key)\n    // 返回小于或等于给定键的最大键，如果没有这样的键，则返回 null 。\n    K    floorKey(K key)\n    // 返回此Map部分的视图，其密钥严格小于 toKey 。\n    SortedMap&lt;K,V&gt;    headMap(K toKey)\n    // 返回该Map部分的视图，其键值小于（或等于，如果 inclusive为真） toKey 。\n    NavigableMap&lt;K,V&gt;    headMap(K toKey, boolean inclusive)\n    // 返回与最小密钥相关联的密钥值映射严格大于给定密钥，如果没有这样的密钥则 null 。\n    Map.Entry&lt;K,V&gt;    higherEntry(K key)\n    // 返回严格大于给定键的最小键，如果没有这样的键，则返回 null 。\n    K    higherKey(K key)\n    // 返回与该Map中最大键相关联的键值映射，如果Map为空，则返回 null 。\n    Map.Entry&lt;K,V&gt;    lastEntry()\n    // 返回与最大密钥相关联的密钥值映射严格小于给定密钥，如果没有这样的密钥则 null 。\n    Map.Entry&lt;K,V&gt;    lowerEntry(K key)\n    // 返回严格小于给定键的最大键，如果没有这样的键，则返回 null 。\n    K    lowerKey(K key)\n    // 返回此Map中包含的键的NavigableSet视图。\n    NavigableSet&lt;K&gt;    navigableKeySet()\n    // 删除并返回与该Map中的最小键相关联的键值映射，如果Map为空，则返回 null 。\n    Map.Entry&lt;K,V&gt;    pollFirstEntry()\n    // 删除并返回与该Map中最大键相关联的键值映射，如果Map为空，则返回 null 。\n    Map.Entry&lt;K,V&gt;    pollLastEntry()\n    // 返回此Map部分的视图，其关键字范围为 fromKey至 toKey 。\n    NavigableMap&lt;K,V&gt;    subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)\n    // 返回此Map部分的视图，其关键字范围为 fromKey （含），不 toKey toKey。\n    SortedMap&lt;K,V&gt;    subMap(K fromKey, K toKey)\n    // 返回此Map部分的视图，其键大于或等于 fromKey 。\n    SortedMap&lt;K,V&gt;    tailMap(K fromKey)\n    // 返回此Map部分的视图，其键大于（或等于，如果 inclusive为真） fromKey 。\n    NavigableMap&lt;K,V&gt;    tailMap(K fromKey, boolean inclusive)</code></pre>\n<p>NavigableMap除了继承SortedMap的特性外，它的提供的功能可以分为4类：<br>\n第1类，提供操作键-值对的方法。<br>\n               lowerEntry、floorEntry、ceilingEntry 和 higherEntry 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象。<br>\n               firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。<br></p>\n<p>第2类，提供操作键的方法。这个和第1类比较类似<br>\n               lowerKey、floorKey、ceilingKey 和 higherKey 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键。<br>\n第3类，获取键集。<br>\n              navigableKeySet、descendingKeySet分别获取正序/反序的键集。<br>\n第4类，获取键-值对的子集</p>\n<h2 id=\"dictionary\">Dictionary</h2>\n<p>Dictionary的定义如下：</p>\n<pre><code class=\"language-java\">public abstract class Dictionary&lt;K,V&gt; {}</code></pre>\n<p>Dictionary是JDK 1.0定义的键值对的接口，它也包括了操作键值对的基本函数。</p>\n<h3 id=\"dictionary的api\">Dictionary的API</h3>\n<pre><code class=\"language-java\">    // 返回此字典中值的枚举。\n    abstract Enumeration&lt;V&gt;    elements()\n    // 返回该字典中键映射到的值。\n    abstract V    get(Object key)\n    // 测试这个字典是否将键值映射到值。\n    abstract boolean    isEmpty()\n    // 返回此字典中键的枚举。\n    abstract Enumeration&lt;K&gt;    keys()\n    // 将指定的key key到本字典中 value的value。\n    abstract V    put(K key, V value)\n    // 从该字典中删除 key （及其对应的 value ）。\n    abstract V    remove(Object key)\n    // 返回此字典中的条目数（不同的键）。\n    abstract int    size()</code></pre>\n',48,0,2,NULL,NULL,'2019-09-21 03:30:51','2020-10-10 00:08:17',0,'32,34,56',1,0),(19,'Java集合07——HashMap','HashMap 是一个散列表，它存储的内容是键值对(key-value)映射','Bobbi','## HashMap简介\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {}\n```\nHashMap 是一个散列表，它存储的内容是键值对(key-value)映射。\n\nHashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。\nHashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。\n\nHashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。\n\n当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。\n\n通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。\n\n## HashMap数据结构\n![image.png](http://oss.osalien.com/dbblog/20201010/1ec72ba3568c452885075fb0c416fded.png)\n1. HashMap继承于AbstractMap类，实现了Map接口。Map是\"key-value键值对\"接口，AbstractMap实现了\"键值对\"的通用函数接口。 \n2. HashMap是通过\"拉链法\"实现的哈希表,即数组和链表的结合体。它包括几个重要的成员变量：table, size, threshold, loadFactor。\n3. table是一个Node[]数组类型，而Node实际上就是一个单向链表(后续会转化为红黑树)。哈希表的\"key-value键值对\"都是存储在Node数组中的。 \n4. size是HashMap的大小，它是HashMap保存的键值对的数量。 \n5. threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=\"容量*加载因子\"，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量扩容长度为以前的2倍。\n6. loadFactor就是加载因子。 \n\n### JDK1.8中HashMap数据结构\nJDK1.7前的结构：数组+链表\n![image.png](http://oss.osalien.com/dbblog/20201010/76f93e3f5a1c47f0ad7a9e5714fd11f4.png)\n\nJDK1.8后的结构：数组+链表(或红黑树)\n![image.png](http://oss.osalien.com/dbblog/20201010/91e1b46d3eb148658c69cff64d8fd608.png)\n\n在JDK 1.7、1.8中都使用了散列算法，但是在JDK 1.8中引入了红黑树，在链表的长度大于等于8并且hash桶的长度大于等于64的时候，会将链表进行树化。这里的树使用的数据结构是红黑树，红黑树是一个自平衡的二叉查找树，查找效率会从链表的o(n)降低为o(logn)，效率是非常大的提高。\n\n## HashMap初始化变量\n```java\n //默认hash桶初始长度16\n  static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; \n\n  //hash表最大容量2的30次幂\n  static final int MAXIMUM_CAPACITY = 1 << 30;\n\n  //默认负载因子 0.75\n  static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n  //链表的数量大于等于8个并且桶的数量大于等于64时链表树化 \n  static final int TREEIFY_THRESHOLD = 8;\n\n  //hash表某个节点链表的数量小于等于6时树拆分\n  static final int UNTREEIFY_THRESHOLD = 6;\n\n  //树化时最小桶的数量\n  static final int MIN_TREEIFY_CAPACITY = 64;\n\n  //hash桶\n  transient Node<K,V>[] table;                         \n\n  //键值对的数量\n  transient int size;\n\n  //HashMap结构修改的次数\n  transient int modCount;\n\n  //扩容的阀值，当键值对的数量超过这个阀值会产生扩容\n  int threshold;\n\n  //负载因子\n  final float loadFactor; \n\n```\n## HashMap构造函数\n```java\n    /**\n     * 构造一个具有指定的初始容量和负载系数的HashMap。\n     */\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n\n    /**\n     * 构造一个空的HashMap，它具有指定的初始容量和默认的负载系数（0.75）。\n     */\n    public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n\n    /**\n     * 使用默认的初始容量（16）和默认的加载因子（0.75）构造一个空的HashMap。\n     */\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n    }\n\n    /**\n     * 构造一个新的HashMap，其映射与指定的Map相同。 使用默认负载因子（0.75）。\n     */\n    public HashMap(Map<? extends K, ? extends V> m) {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        putMapEntries(m, false);\n    }\n```\n\nHashMap有4个构造函数。\n\nhash桶没有在构造函数中初始化，而是在第一次存储键值对的时候进行初始化。 这里重点看tableSizeFor(initialCapacity)方法，这个方法的作用是，将你传入的initialCapacity做计算，返回一个大于等于initialCapacity 最小的2的幂次方。\n\n所以这个操作保证无论你传入的初始化Hash桶长度参数是多少，最后hash表初始化的长度都是2的幂次方。比如你输入的是6，计算出来结果就是8。\n```java\n    /**\n     * 返回一个大于等于initialCapacity 最小的2的幂次方\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n\n## HashMap存储\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,                                     \n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //当table为空时，这里初始化table，不是通过构造函数初始化，而是在插入时通过扩容初始化，有效防止了初始化HashMap没有数据插入造成空间浪费可能造成内存泄露的情况\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    //计算数组中的位置，该位置为空则存放新键值对在数组中\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 否则存入链表或红黑树\n    else {\n        Node<K,V> e; K k;\n        //key的hash相等，equals相等，则直接覆盖\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        //如果是红黑树节点，在红黑树中查找覆盖\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n	//将新键值对放在链表的最后（单链表后或红黑树）\n        else {\n            // 遍历链表\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    //当链表的长度大于等于树化阀值8,并且hash桶的长度大于等于MIN_TREEIFY_CAPACITY 64，链表转化为红黑树链表转化为红黑树，插入键值对\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                //链表插入，如果key存在则直接覆盖\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        //map中含有旧key(被覆盖的key)，返回旧值\n        if (e != null) { \n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    //map调整次数加1\n    ++modCount;\n    //键值对的数量达到阈值需要扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\nput的过程如图：\n\n![image.png](http://oss.osalien.com/dbblog/20201010/520ee00e5b8a4d1cb9946b68ec88f5e9.png)\n\n总结：\n1. 插入的键值对是新键值对，如果hash表没有初始化会进行初始化，否则将键值对插入链表尾部，可能需要链表树化和扩容\n2. 插入的键值对中的key已经存在，覆盖键值对。在put的方法里我们注意看下hash(key)方法，这是计算键值对hash值的方法:\n\n```java\n    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n这里的Hash算法本质上就是三步： \n1. 取key的hashCode值，h = key.hashCode()； \n2. 高位参与运算，h ^ (h >>> 16)； \n3. 取模运算，h & (n-1)。\n\n\nhashCode()是一个int类型的本地方法，也就将key的hashCode无符号右移16位然后与hashCode异或从而得到hash值在putVal方法中（n - 1）& hash计算得到桶的索引位置 ，那么现在有两个疑问，为什么要计算hash值？为什么不用 hash % n?\n\n\n- 为什么要计算hash值，而不用hashCode?\n\n用为通常n是很小的，而hashCode是32位，如果（n - 1）& hashCode那么当n大于2的16次方加1，也就是65537后(n - 1)的高位数据才能与hashCode的高位数据相与，当n很小是只能使用上hashCode低16位的数据，这会产生一个问题，既键值对在hash桶中分布不均匀，导致链表过长，而把hashCode>>>16无符号右移16位让高16位间接的与（n - 1）参加计算，从而让键值对分布均匀。降低hash碰撞。\n\n\n- 为什么使用（n - 1）& hash 而不使用hash% n呢？\n\n其实这两种结果是等价的，当n总是2的n次方时，h& (n-1)运算等价于对n取模，也就是h%n，但是&比%具有更高的效率，如图：\n\n![image.png](http://oss.osalien.com/dbblog/20201010/bdb6047c3cc242a883e7fecbd6f5397c.png)\n\n上图 hash&(n - 1)的结果是2，而其实hash%n 的结果也是2, hash&(n - 1)与hash%n的结果是等价的。\n\n## HashMap扩容\nHashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。那么什么时候回产生扩容呢？\n1. 初始化HashMap时，第一次进行put操作\n2. 当键值对的个数大于threshold阀值时产生扩容，threshold=size*loadFactor\n\n\n```java\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        //如果旧hash桶不为空\n        if (oldCap > 0) {\n            //超过hash桶的最大长度，将阀值设为最大值\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            //新的hash桶的长度被扩容没有超过最大长度，将新容量阀值扩容为以前的2倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        //如果旧hash桶为空，hash表阈值已经初始化过\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        //如果旧hash桶，并且hash桶容量阈值没有初始化，那么需要初始化新的hash桶的容量和新容量阀值\n        else {              \n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        //新的局部变量阀值赋值\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        //为当前容量阀值赋值\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            //初始化hash桶\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        //如果旧的hash桶不为空，需要将旧的hash表里的键值对重新映射到新的hash桶中\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    //只有一个节点，通过索引位置直接映射\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    //如果是红黑树，需要进行树拆分然后映射\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { \n                    //如果是多个节点的链表，将原链表拆分为两个链表，两个链表的索引位置，一个为原索引，一个为原索引加上旧Hash桶长度的偏移量       \n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            //链表1\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            //链表2\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        //链表1存于原索引\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        //链表2存于原索引加上原hash桶长度的偏移量\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n\n```\n经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 \n这里写图片描述\n![image.png](http://oss.osalien.com/dbblog/20201010/2cd32b100c504d978699177868f28ca6.png)\n\n元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： \n![image.png](http://oss.osalien.com/dbblog/20201010/e5a5f0dbc027429689ac538d7bc6b514.png)\n因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： \n![image.png](http://oss.osalien.com/dbblog/20201010/1fdc6138b2fd4050bb2978983043b164.png)\n\n这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。\n\n## HashMap读取\n```java\n    public V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n\n    \n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n	// 计算Hash，如果第一个节点命中，则返回\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n	    // 有冲突，则分别从红黑树或链表中查找节点\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n```\n有了上面存储时的 hash 算法作为基础,理解起来这段代码就很容易了。从上面的源代码中可以看出\n1. 先对key的hashCode()做hash运算，计算index;\n2. 如果在bucket里的第一个节点里直接命中，则直接返回；\n3. 如果有冲突，则通过key.equals(k)去查找对应的Entry;\n若为树，则在树中通过key.equals(k)查找，O(logn)；\n若为链表，则在链表中通过key.equals(k)查找，O(n)。\n\n## HashMap注意事项\n1. HashMap允许NULL值，NULL键\n2. 不要轻易改变负载因子，负载因子过高会导致链表过长，查找键值对时间复杂度就会增高，负载因子过低会导致hash桶的数量过多，空间复杂度会增高\n4. HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap\n5. 尽量设置HashMap的初始容量，尤其在数据量大的时候，防止多次resize\n6. HashMap在JDK 1.8在做了很好性能的提升，尽量升级到JDK1.8\n','<h2 id=\"hashmap简介\">HashMap简介</h2>\n<pre><code class=\"language-java\">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;\n    implements Map&lt;K,V&gt;, Cloneable, Serializable {}</code></pre>\n<p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p>\n<p>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。\nHashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>\n<p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。</p>\n<p>当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。</p>\n<p>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p>\n<h2 id=\"hashmap数据结构\">HashMap数据结构</h2>\n<p><img src=\"http://oss.osalien.com/dbblog/20201010/1ec72ba3568c452885075fb0c416fded.png\" alt=\"image.png\"></p>\n<ol>\n<li>HashMap继承于AbstractMap类，实现了Map接口。Map是&quot;key-value键值对&quot;接口，AbstractMap实现了&quot;键值对&quot;的通用函数接口。 </li>\n<li>HashMap是通过&quot;拉链法&quot;实现的哈希表,即数组和链表的结合体。它包括几个重要的成员变量：table, size, threshold, loadFactor。</li>\n<li>table是一个Node[]数组类型，而Node实际上就是一个单向链表(后续会转化为红黑树)。哈希表的&quot;key-value键值对&quot;都是存储在Node数组中的。 </li>\n<li>size是HashMap的大小，它是HashMap保存的键值对的数量。 </li>\n<li>threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=&quot;容量*加载因子&quot;，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量扩容长度为以前的2倍。</li>\n<li>loadFactor就是加载因子。 </li>\n</ol>\n<h3 id=\"jdk18中hashmap数据结构\">JDK1.8中HashMap数据结构</h3>\n<p>JDK1.7前的结构：数组+链表\n<img src=\"http://oss.osalien.com/dbblog/20201010/76f93e3f5a1c47f0ad7a9e5714fd11f4.png\" alt=\"image.png\"></p>\n<p>JDK1.8后的结构：数组+链表(或红黑树)\n<img src=\"http://oss.osalien.com/dbblog/20201010/91e1b46d3eb148658c69cff64d8fd608.png\" alt=\"image.png\"></p>\n<p>在JDK 1.7、1.8中都使用了散列算法，但是在JDK 1.8中引入了红黑树，在链表的长度大于等于8并且hash桶的长度大于等于64的时候，会将链表进行树化。这里的树使用的数据结构是红黑树，红黑树是一个自平衡的二叉查找树，查找效率会从链表的o(n)降低为o(logn)，效率是非常大的提高。</p>\n<h2 id=\"hashmap初始化变量\">HashMap初始化变量</h2>\n<pre><code class=\"language-java\"> //默认hash桶初始长度16\n  static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; \n\n  //hash表最大容量2的30次幂\n  static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;\n\n  //默认负载因子 0.75\n  static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n  //链表的数量大于等于8个并且桶的数量大于等于64时链表树化 \n  static final int TREEIFY_THRESHOLD = 8;\n\n  //hash表某个节点链表的数量小于等于6时树拆分\n  static final int UNTREEIFY_THRESHOLD = 6;\n\n  //树化时最小桶的数量\n  static final int MIN_TREEIFY_CAPACITY = 64;\n\n  //hash桶\n  transient Node&lt;K,V&gt;[] table;                         \n\n  //键值对的数量\n  transient int size;\n\n  //HashMap结构修改的次数\n  transient int modCount;\n\n  //扩容的阀值，当键值对的数量超过这个阀值会产生扩容\n  int threshold;\n\n  //负载因子\n  final float loadFactor; \n</code></pre>\n<h2 id=\"hashmap构造函数\">HashMap构造函数</h2>\n<pre><code class=\"language-java\">    /**\n     * 构造一个具有指定的初始容量和负载系数的HashMap。\n     */\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity &lt; 0)\n            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                               initialCapacity);\n        if (initialCapacity &gt; MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n\n    /**\n     * 构造一个空的HashMap，它具有指定的初始容量和默认的负载系数（0.75）。\n     */\n    public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n\n    /**\n     * 使用默认的初始容量（16）和默认的加载因子（0.75）构造一个空的HashMap。\n     */\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n    }\n\n    /**\n     * 构造一个新的HashMap，其映射与指定的Map相同。 使用默认负载因子（0.75）。\n     */\n    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        putMapEntries(m, false);\n    }</code></pre>\n<p>HashMap有4个构造函数。</p>\n<p>hash桶没有在构造函数中初始化，而是在第一次存储键值对的时候进行初始化。 这里重点看tableSizeFor(initialCapacity)方法，这个方法的作用是，将你传入的initialCapacity做计算，返回一个大于等于initialCapacity 最小的2的幂次方。</p>\n<p>所以这个操作保证无论你传入的初始化Hash桶长度参数是多少，最后hash表初始化的长度都是2的幂次方。比如你输入的是6，计算出来结果就是8。</p>\n<pre><code class=\"language-java\">    /**\n     * 返回一个大于等于initialCapacity 最小的2的幂次方\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n &gt;&gt;&gt; 1;\n        n |= n &gt;&gt;&gt; 2;\n        n |= n &gt;&gt;&gt; 4;\n        n |= n &gt;&gt;&gt; 8;\n        n |= n &gt;&gt;&gt; 16;\n        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }</code></pre>\n<h2 id=\"hashmap存储\">HashMap存储</h2>\n<pre><code class=\"language-java\">public V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,                                     \n               boolean evict) {\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    //当table为空时，这里初始化table，不是通过构造函数初始化，而是在插入时通过扩容初始化，有效防止了初始化HashMap没有数据插入造成空间浪费可能造成内存泄露的情况\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    //计算数组中的位置，该位置为空则存放新键值对在数组中\n    if ((p = tab[i = (n - 1) &amp; hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 否则存入链表或红黑树\n    else {\n        Node&lt;K,V&gt; e; K k;\n        //key的hash相等，equals相等，则直接覆盖\n        if (p.hash == hash &amp;&amp;\n            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n            e = p;\n        //如果是红黑树节点，在红黑树中查找覆盖\n        else if (p instanceof TreeNode)\n            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n    //将新键值对放在链表的最后（单链表后或红黑树）\n        else {\n            // 遍历链表\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    //当链表的长度大于等于树化阀值8,并且hash桶的长度大于等于MIN_TREEIFY_CAPACITY 64，链表转化为红黑树链表转化为红黑树，插入键值对\n                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                //链表插入，如果key存在则直接覆盖\n                if (e.hash == hash &amp;&amp;\n                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        //map中含有旧key(被覆盖的key)，返回旧值\n        if (e != null) { \n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    //map调整次数加1\n    ++modCount;\n    //键值对的数量达到阈值需要扩容\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}</code></pre>\n<p>put的过程如图：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201010/520ee00e5b8a4d1cb9946b68ec88f5e9.png\" alt=\"image.png\"></p>\n<p>总结：</p>\n<ol>\n<li>插入的键值对是新键值对，如果hash表没有初始化会进行初始化，否则将键值对插入链表尾部，可能需要链表树化和扩容</li>\n<li>插入的键值对中的key已经存在，覆盖键值对。在put的方法里我们注意看下hash(key)方法，这是计算键值对hash值的方法:</li>\n</ol>\n<pre><code class=\"language-java\">    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n    }</code></pre>\n<p>这里的Hash算法本质上就是三步： </p>\n<ol>\n<li>取key的hashCode值，h = key.hashCode()； </li>\n<li>高位参与运算，h ^ (h &gt;&gt;&gt; 16)； </li>\n<li>取模运算，h &amp; (n-1)。</li>\n</ol>\n<p>hashCode()是一个int类型的本地方法，也就将key的hashCode无符号右移16位然后与hashCode异或从而得到hash值在putVal方法中（n - 1）&amp; hash计算得到桶的索引位置 ，那么现在有两个疑问，为什么要计算hash值？为什么不用 hash % n?</p>\n<ul>\n<li>为什么要计算hash值，而不用hashCode?</li>\n</ul>\n<p>用为通常n是很小的，而hashCode是32位，如果（n - 1）&amp; hashCode那么当n大于2的16次方加1，也就是65537后(n - 1)的高位数据才能与hashCode的高位数据相与，当n很小是只能使用上hashCode低16位的数据，这会产生一个问题，既键值对在hash桶中分布不均匀，导致链表过长，而把hashCode&gt;&gt;&gt;16无符号右移16位让高16位间接的与（n - 1）参加计算，从而让键值对分布均匀。降低hash碰撞。</p>\n<ul>\n<li>为什么使用（n - 1）&amp; hash 而不使用hash% n呢？</li>\n</ul>\n<p>其实这两种结果是等价的，当n总是2的n次方时，h&amp; (n-1)运算等价于对n取模，也就是h%n，但是&amp;比%具有更高的效率，如图：</p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201010/bdb6047c3cc242a883e7fecbd6f5397c.png\" alt=\"image.png\"></p>\n<p>上图 hash&amp;(n - 1)的结果是2，而其实hash%n 的结果也是2, hash&amp;(n - 1)与hash%n的结果是等价的。</p>\n<h2 id=\"hashmap扩容\">HashMap扩容</h2>\n<p>HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。那么什么时候回产生扩容呢？</p>\n<ol>\n<li>初始化HashMap时，第一次进行put操作</li>\n<li>当键值对的个数大于threshold阀值时产生扩容，threshold=size*loadFactor</li>\n</ol>\n<pre><code class=\"language-java\">final Node&lt;K,V&gt;[] resize() {\n        Node&lt;K,V&gt;[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        //如果旧hash桶不为空\n        if (oldCap &gt; 0) {\n            //超过hash桶的最大长度，将阀值设为最大值\n            if (oldCap &gt;= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            //新的hash桶的长度被扩容没有超过最大长度，将新容量阀值扩容为以前的2倍\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr &lt;&lt; 1; // double threshold\n        }\n        //如果旧hash桶为空，hash表阈值已经初始化过\n        else if (oldThr &gt; 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        //如果旧hash桶，并且hash桶容量阈值没有初始化，那么需要初始化新的hash桶的容量和新容量阀值\n        else {              \n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        //新的局部变量阀值赋值\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        //为当前容量阀值赋值\n        threshold = newThr;\n        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})\n            //初始化hash桶\n            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];\n        table = newTab;\n        //如果旧的hash桶不为空，需要将旧的hash表里的键值对重新映射到新的hash桶中\n        if (oldTab != null) {\n            for (int j = 0; j &lt; oldCap; ++j) {\n                Node&lt;K,V&gt; e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    //只有一个节点，通过索引位置直接映射\n                    if (e.next == null)\n                        newTab[e.hash &amp; (newCap - 1)] = e;\n                    //如果是红黑树，需要进行树拆分然后映射\n                    else if (e instanceof TreeNode)\n                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                    else { \n                    //如果是多个节点的链表，将原链表拆分为两个链表，两个链表的索引位置，一个为原索引，一个为原索引加上旧Hash桶长度的偏移量       \n                        Node&lt;K,V&gt; loHead = null, loTail = null;\n                        Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                        Node&lt;K,V&gt; next;\n                        do {\n                            next = e.next;\n                            //链表1\n                            if ((e.hash &amp; oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            //链表2\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        //链表1存于原索引\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        //链表2存于原索引加上原hash桶长度的偏移量\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n</code></pre>\n<p>经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 \n这里写图片描述\n<img src=\"http://oss.osalien.com/dbblog/20201010/2cd32b100c504d978699177868f28ca6.png\" alt=\"image.png\"></p>\n<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： \n<img src=\"http://oss.osalien.com/dbblog/20201010/e5a5f0dbc027429689ac538d7bc6b514.png\" alt=\"image.png\">\n因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： \n<img src=\"http://oss.osalien.com/dbblog/20201010/1fdc6138b2fd4050bb2978983043b164.png\" alt=\"image.png\"></p>\n<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p>\n<h2 id=\"hashmap读取\">HashMap读取</h2>\n<pre><code class=\"language-java\">    public V get(Object key) {\n        Node&lt;K,V&gt; e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n\n\n    final Node&lt;K,V&gt; getNode(int hash, Object key) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    // 计算Hash，如果第一个节点命中，则返回\n        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;\n            (first = tab[(n - 1) &amp; hash]) != null) {\n            if (first.hash == hash &amp;&amp; // always check first node\n                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))\n                return first;\n        // 有冲突，则分别从红黑树或链表中查找节点\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)\n                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }</code></pre>\n<p>有了上面存储时的 hash 算法作为基础,理解起来这段代码就很容易了。从上面的源代码中可以看出</p>\n<ol>\n<li>先对key的hashCode()做hash运算，计算index;</li>\n<li>如果在bucket里的第一个节点里直接命中，则直接返回；</li>\n<li>如果有冲突，则通过key.equals(k)去查找对应的Entry;\n若为树，则在树中通过key.equals(k)查找，O(logn)；\n若为链表，则在链表中通过key.equals(k)查找，O(n)。</li>\n</ol>\n<h2 id=\"hashmap注意事项\">HashMap注意事项</h2>\n<ol>\n<li>HashMap允许NULL值，NULL键</li>\n<li>不要轻易改变负载因子，负载因子过高会导致链表过长，查找键值对时间复杂度就会增高，负载因子过低会导致hash桶的数量过多，空间复杂度会增高</li>\n<li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap</li>\n<li>尽量设置HashMap的初始容量，尤其在数据量大的时候，防止多次resize</li>\n<li>HashMap在JDK 1.8在做了很好性能的提升，尽量升级到JDK1.8</li>\n</ol>\n',112,0,2,NULL,NULL,'2019-09-21 06:53:02','2020-10-10 00:10:54',0,'32,34,56',1,0),(20,'Java多线程基础01——线程的创建','现代操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都有各自的计数器、堆栈和局部变量等属性，并且能构访问共享的内存变量。','Bobbi','## 什么是线程\n现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序，操作系统就会创建一个Java进程。现代操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都有各自的计数器、堆栈和局部变量等属性，并且能构访问共享的内存变量。\n\n一个Java程序从main()方法开始，执行main()方法的是一个main的线程。下面使用JMX来查看一个普通的Java程序包含哪些线程\n```java\npublic class MultiThread {\n\n    public static void main(String[] args) {\n        // 获取Java线程管理MXBean\n        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n        // 仅获取线程和线程的堆栈信息\n        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\n        for (ThreadInfo threadInfo : threadInfos) {\n            System.out.println(\"[\"+threadInfo.getThreadId()+\"]  \"+threadInfo.getThreadName());\n        }\n        // 当前活动线程数\n        System.out.println(\"当前活动的线程数: \"+Thread.activeCount());\n    }\n}\n```\n\n结果如下：\n\n```shell\n[5]  Monitor Ctrl-Break  \n[4]  Signal Dispatcher \n[3]  Finalizer  \n[2]  Reference Handler\n[1]  main\n当前活动的线程数: 2\n```\n可以看到，一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其他线程的同时运行\n> 注意：当前活动线程数为2，解释如下：windows下这个Monitor Ctrl-Break是不算在活动线程的，所以这样大于1是可以执行的，但是linux下应该是大于2\n\n## 多线程的状态\n线程的状态\n1. 新建状态（New）：线程对象被创建后，就进入了新建状态。例如Thread thread = new Thread()。\n2. 就绪状态（Runnable）：也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。\n3. 运行状态（Running）：线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。\n4. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<br>(1) 等待阻塞：通过调用线程的wait()方法，让线程等待某工作的完成。<br>(2) 同步阻塞：线程在获取synchronized同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态。<br>(3) 其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n6. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\n\n![image.png](http://oss.osalien.com/dbblog/20201010/77220b89ab274708b683b8fb30148eb6.png)\n\n## 多线程的实现方式\n### Thread和Runnable简介\nRunnable是一个接口，该接口中只包含了一个run()方法。它的定义如下：\n```java\npublic interface Runnable {\n    public abstract void run();\n}\n```\nThread 是一个类。Thread本身就实现了Runnable接口。它的声明如下：\n```java\npublic class Thread implements Runnable {}\n```\n\nThread是类，Runnable是接口；Thread本身是实现了Runnable接口的类。因为“一个类只能有一个父类，但却能实现多个接口”，因此Runnable具有更好的扩展性。\n此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会**共享Runnable对象上的资源**。通常，建议通过“Runnable”实现多线程！\n\n### 使用Thread实现多线程\n```java\npublic class MyThread extends Thread {\n\n    private int ticket=5;\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 20; i++) {\n            if(ticket>0) {\n                System.out.println(Thread.currentThread().getName()+\"剩余票数\"+this.ticket--);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread thread1 = new MyThread();\n        thread1.setName(\"线程1\");\n        MyThread thread2 = new MyThread();\n        thread2.setName(\"线程2\");\n        MyThread thread3 = new MyThread();\n        thread3.setName(\"线程3\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n    }\n}\n\n```\n结果如下\n\n```shell\n线程1剩余票数5\n线程1剩余票数4\n线程1剩余票数3\n线程1剩余票数2\n线程1剩余票数1\n线程3剩余票数5\n线程3剩余票数4\n线程3剩余票数3\n线程3剩余票数2\n线程3剩余票数1\n线程2剩余票数5\n线程2剩余票数4\n线程2剩余票数3\n线程2剩余票数2\n线程2剩余票数1\n```\n结果说明：\n(1) MyThread继承于Thread，它是自定义个线程。每个MyThread都会卖出5张票。\n(2) 主线程main创建并启动3个MyThread子线程。每个子线程都各自卖出了5张票。\n(3) 线程的启动顺序具有不确定性\n\n### 使用Runnable实现多线程\n```java\npublic class MyThreadRunnable implements Runnable {\n    \n    private int ticket=10;\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            if(this.ticket>0) {\n                System.out.println(Thread.currentThread().getName()+\" 卖票：ticket \"+this.ticket--);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThreadRunnable myThreadRunnable = new MyThreadRunnable();\n	// 启动3个线程（它们公用一个Runnable对象），这三个线程共卖10张票\n        Thread thread1 = new Thread(myThreadRunnable,\"线程1\");\n        Thread thread2 = new Thread(myThreadRunnable,\"线程2\");\n        Thread thread3 = new Thread(myThreadRunnable,\"线程3\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n\n    }\n}\n```\n结果如下\n\n```shell\n线程1 卖票：ticket 9\n线程2 卖票：ticket 10\n线程3 卖票：ticket 7\n线程1 卖票：ticket 8\n线程3 卖票：ticket 5\n线程2 卖票：ticket 6\n线程3 卖票：ticket 3\n线程1 卖票：ticket 4\n线程3 卖票：ticket 1\n线程2 卖票：ticket 2\n```\n结果说明：\n(1) 和上面“MyThread继承于Thread”不同；这里的MyThread实现了Runnable接口。\n(2) 主线程main创建并启动3个子线程，而且这3个子线程都是基于“myThreadRunnable这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。\n\n### 实现带有返回值的多线程\n```java\npublic class MyCallable implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName()+\" start\");\n        return new Random().nextInt(10);\n    }\n\n    public static void main(String[] args) throws Exception {\n        MyCallable myCallable = new MyCallable();\n        FutureTask<Integer> task = new FutureTask<>(myCallable);\n        Thread t = new Thread(task,\"线程1\");\n        t.start();\n        try {\n            System.out.println(task.get());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n```\n结果如下\n\n```shell\n线程1 start\n6\n```\ncall方法可以抛出异常或者返回一个值。因为是异步的，而且是得到返回值还是捕获了异常也不清楚，这些都需要进行进一步的封装。FutureTask类是继承自Runnable接口的，它也可以配合Callable接口，使用Thread来创建多线程任务。x\nFutureTask和Callable会在后面的章节详细介绍。\n\n### 使用定时器Timer实现多线程\n```java\npublic class MyTimer {\n    public static void main(String[] args) {\n        Timer timer = new Timer();\n        // 使用schedule来调度任务，第一个参数是一个TimerTask，第二个参数时延时，第三个参数是执行间隔周期\n        timer.schedule(new TimerTask(){\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+\" start\");\n            }\n        },0,1000);\n    }\n}\n```\n\n结果如下\n```shell\nTimer-0 start\nTimer-0 start\nTimer-0 start\nTimer-0 start\nTimer-0 start\n```\n> 多线程处理定时任务时，timer只要其中之一抛出没有捕获的异常时，其他的定时任务便会停止运行，可以使用ScheduledExecutorService代替\n\n\n### 使用线程池创建线程\n```java\npublic class MyThreadPool {\n    public static void main(String[] args) {\n        ExecutorService threadPool = Executors.newFixedThreadPool(2);\n        // 循环创建10个多线程任务\n        for (int i = 0; i < 10; i++) {\n            // 使用线程池来创建多线程任务\n            threadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(Thread.currentThread().getName() + \" start\");\n                }\n            });\n        }\n        // 关闭线程池\n        threadPool.shutdown();\n\n    }\n}\n```\n结果如下\n```shell\npool-1-thread-1 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\n```\n结果解释：\n上述代码创建了两个线程的线程池，线程池只会创建2个线程分别执行这10个任务\n\n\n\n','<h2 id=\"什么是线程\">什么是线程</h2>\n<p>现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序，操作系统就会创建一个Java进程。现代操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都有各自的计数器、堆栈和局部变量等属性，并且能构访问共享的内存变量。</p>\n<p>一个Java程序从main()方法开始，执行main()方法的是一个main的线程。下面使用JMX来查看一个普通的Java程序包含哪些线程</p>\n<pre><code class=\"language-java\">public class MultiThread {\n\n    public static void main(String[] args) {\n        // 获取Java线程管理MXBean\n        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n        // 仅获取线程和线程的堆栈信息\n        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\n        for (ThreadInfo threadInfo : threadInfos) {\n            System.out.println(&quot;[&quot;+threadInfo.getThreadId()+&quot;]  &quot;+threadInfo.getThreadName());\n        }\n        // 当前活动线程数\n        System.out.println(&quot;当前活动的线程数: &quot;+Thread.activeCount());\n    }\n}</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">[5]  Monitor Ctrl-Break  \n[4]  Signal Dispatcher \n[3]  Finalizer  \n[2]  Reference Handler\n[1]  main\n当前活动的线程数: 2</code></pre>\n<p>可以看到，一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其他线程的同时运行</p>\n<blockquote>\n<p>注意：当前活动线程数为2，解释如下：windows下这个Monitor Ctrl-Break是不算在活动线程的，所以这样大于1是可以执行的，但是linux下应该是大于2</p>\n</blockquote>\n<h2 id=\"多线程的状态\">多线程的状态</h2>\n<p>线程的状态</p>\n<ol>\n<li>新建状态（New）：线程对象被创建后，就进入了新建状态。例如Thread thread = new Thread()。</li>\n<li>就绪状态（Runnable）：也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>\n<li>运行状态（Running）：线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>\n<li>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<br>(1) 等待阻塞：通过调用线程的wait()方法，让线程等待某工作的完成。<br>(2) 同步阻塞：线程在获取synchronized同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态。<br>(3) 其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>\n<li>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>\n</ol>\n<p><img src=\"http://oss.osalien.com/dbblog/20201010/77220b89ab274708b683b8fb30148eb6.png\" alt=\"image.png\"></p>\n<h2 id=\"多线程的实现方式\">多线程的实现方式</h2>\n<h3 id=\"thread和runnable简介\">Thread和Runnable简介</h3>\n<p>Runnable是一个接口，该接口中只包含了一个run()方法。它的定义如下：</p>\n<pre><code class=\"language-java\">public interface Runnable {\n    public abstract void run();\n}</code></pre>\n<p>Thread 是一个类。Thread本身就实现了Runnable接口。它的声明如下：</p>\n<pre><code class=\"language-java\">public class Thread implements Runnable {}</code></pre>\n<p>Thread是类，Runnable是接口；Thread本身是实现了Runnable接口的类。因为“一个类只能有一个父类，但却能实现多个接口”，因此Runnable具有更好的扩展性。\n此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会<strong>共享Runnable对象上的资源</strong>。通常，建议通过“Runnable”实现多线程！</p>\n<h3 id=\"使用thread实现多线程\">使用Thread实现多线程</h3>\n<pre><code class=\"language-java\">public class MyThread extends Thread {\n\n    private int ticket=5;\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 20; i++) {\n            if(ticket&gt;0) {\n                System.out.println(Thread.currentThread().getName()+&quot;剩余票数&quot;+this.ticket--);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread thread1 = new MyThread();\n        thread1.setName(&quot;线程1&quot;);\n        MyThread thread2 = new MyThread();\n        thread2.setName(&quot;线程2&quot;);\n        MyThread thread3 = new MyThread();\n        thread3.setName(&quot;线程3&quot;);\n        thread1.start();\n        thread2.start();\n        thread3.start();\n    }\n}\n</code></pre>\n<p>结果如下</p>\n<pre><code class=\"language-shell\">线程1剩余票数5\n线程1剩余票数4\n线程1剩余票数3\n线程1剩余票数2\n线程1剩余票数1\n线程3剩余票数5\n线程3剩余票数4\n线程3剩余票数3\n线程3剩余票数2\n线程3剩余票数1\n线程2剩余票数5\n线程2剩余票数4\n线程2剩余票数3\n线程2剩余票数2\n线程2剩余票数1</code></pre>\n<p>结果说明：\n(1) MyThread继承于Thread，它是自定义个线程。每个MyThread都会卖出5张票。\n(2) 主线程main创建并启动3个MyThread子线程。每个子线程都各自卖出了5张票。\n(3) 线程的启动顺序具有不确定性</p>\n<h3 id=\"使用runnable实现多线程\">使用Runnable实现多线程</h3>\n<pre><code class=\"language-java\">public class MyThreadRunnable implements Runnable {\n\n    private int ticket=10;\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 10; i++) {\n            if(this.ticket&gt;0) {\n                System.out.println(Thread.currentThread().getName()+&quot; 卖票：ticket &quot;+this.ticket--);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThreadRunnable myThreadRunnable = new MyThreadRunnable();\n    // 启动3个线程（它们公用一个Runnable对象），这三个线程共卖10张票\n        Thread thread1 = new Thread(myThreadRunnable,&quot;线程1&quot;);\n        Thread thread2 = new Thread(myThreadRunnable,&quot;线程2&quot;);\n        Thread thread3 = new Thread(myThreadRunnable,&quot;线程3&quot;);\n        thread1.start();\n        thread2.start();\n        thread3.start();\n\n    }\n}</code></pre>\n<p>结果如下</p>\n<pre><code class=\"language-shell\">线程1 卖票：ticket 9\n线程2 卖票：ticket 10\n线程3 卖票：ticket 7\n线程1 卖票：ticket 8\n线程3 卖票：ticket 5\n线程2 卖票：ticket 6\n线程3 卖票：ticket 3\n线程1 卖票：ticket 4\n线程3 卖票：ticket 1\n线程2 卖票：ticket 2</code></pre>\n<p>结果说明：\n(1) 和上面“MyThread继承于Thread”不同；这里的MyThread实现了Runnable接口。\n(2) 主线程main创建并启动3个子线程，而且这3个子线程都是基于“myThreadRunnable这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。</p>\n<h3 id=\"实现带有返回值的多线程\">实现带有返回值的多线程</h3>\n<pre><code class=\"language-java\">public class MyCallable implements Callable&lt;Integer&gt; {\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName()+&quot; start&quot;);\n        return new Random().nextInt(10);\n    }\n\n    public static void main(String[] args) throws Exception {\n        MyCallable myCallable = new MyCallable();\n        FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(myCallable);\n        Thread t = new Thread(task,&quot;线程1&quot;);\n        t.start();\n        try {\n            System.out.println(task.get());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }</code></pre>\n<p>结果如下</p>\n<pre><code class=\"language-shell\">线程1 start\n6</code></pre>\n<p>call方法可以抛出异常或者返回一个值。因为是异步的，而且是得到返回值还是捕获了异常也不清楚，这些都需要进行进一步的封装。FutureTask类是继承自Runnable接口的，它也可以配合Callable接口，使用Thread来创建多线程任务。x\nFutureTask和Callable会在后面的章节详细介绍。</p>\n<h3 id=\"使用定时器timer实现多线程\">使用定时器Timer实现多线程</h3>\n<pre><code class=\"language-java\">public class MyTimer {\n    public static void main(String[] args) {\n        Timer timer = new Timer();\n        // 使用schedule来调度任务，第一个参数是一个TimerTask，第二个参数时延时，第三个参数是执行间隔周期\n        timer.schedule(new TimerTask(){\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+&quot; start&quot;);\n            }\n        },0,1000);\n    }\n}</code></pre>\n<p>结果如下</p>\n<pre><code class=\"language-shell\">Timer-0 start\nTimer-0 start\nTimer-0 start\nTimer-0 start\nTimer-0 start</code></pre>\n<blockquote>\n<p>多线程处理定时任务时，timer只要其中之一抛出没有捕获的异常时，其他的定时任务便会停止运行，可以使用ScheduledExecutorService代替</p>\n</blockquote>\n<h3 id=\"使用线程池创建线程\">使用线程池创建线程</h3>\n<pre><code class=\"language-java\">public class MyThreadPool {\n    public static void main(String[] args) {\n        ExecutorService threadPool = Executors.newFixedThreadPool(2);\n        // 循环创建10个多线程任务\n        for (int i = 0; i &lt; 10; i++) {\n            // 使用线程池来创建多线程任务\n            threadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(Thread.currentThread().getName() + &quot; start&quot;);\n                }\n            });\n        }\n        // 关闭线程池\n        threadPool.shutdown();\n\n    }\n}</code></pre>\n<p>结果如下</p>\n<pre><code class=\"language-shell\">pool-1-thread-1 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start\npool-1-thread-2 start</code></pre>\n<p>结果解释：\n上述代码创建了两个线程的线程池，线程池只会创建2个线程分别执行这10个任务</p>\n',40,26,2,NULL,NULL,'2019-07-22 15:34:07','2020-10-10 00:14:58',0,'32,42,57',1,0),(21,'Java多线程基础02——synchronized','在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当我们调用某对象的synchronized方法时，就获取了该对象的同步锁','Bobbi','## synchronized简介\n在java中，每个对象有且仅有一个同步锁。这也意味着，**同步锁是依赖于对象而存在的**。\n\n当我们调用某个对象的synchronized方法时，就获取了该对象的同步锁。**不同线程对同步锁的访问是互斥的**,也就是说，某个时间点对象的同步锁只能被一个线程获取到！通过同步锁我们就能在多线程中实现对对象或方法的互斥访问。例如，现在有两个线程A和线程B，它们都会访问对象obj的同步锁。假设，在某一时刻，线程A获取到obj的同步锁并在执行一些操作；而此时，线程B也企图获取obj的同步锁，线程B将会获取失败，它必须等待，直到线程A释放了obj对象的同步锁之后线程B才能获取到obj对象的同步锁从而才可以运行。\n\n## synchronized基本规则\n我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\n1. 第一条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。\n2. 第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。\n3. 第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。\n\n### 第一条规则验证\n```java\nclass MyRunnable implements Runnable {\n\n    @Override\n    public void run() {\n        synchronized (this) {\n            try {\n                for (int i = 0; i < 5; i++) {\n                    Thread.sleep(100); \n                    System.out.println(Thread.currentThread().getName() + \" loop \" + i);\n                }\n                System.out.println(Thread.currentThread().getName() + \" is end\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\npublic class Synchronized01 {\n\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread1 = new Thread(myRunnable);  // 新建“线程t1”, t1是基于myRunnable这个Runnable对象\n        Thread thread2 = new Thread(myRunnable);  // 新建“线程t2”, t2是基于myRunnable这个Runnable对象\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n结果如下：\n```shell\nThread-0 loop 0\nThread-0 loop 1\nThread-0 loop 2\nThread-0 loop 3\nThread-0 loop 4\nThread-0 is end\nThread-1 loop 0\nThread-1 loop 1\nThread-1 loop 2\nThread-1 loop 3\nThread-1 loop 4\nThread-1 is end\n```\n结果说明：\nrun()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于\"myRunnable这个Runnable对象\"创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“myRunnable这个Runnable对象”；因此，线程t1和t2共享“myRunnable对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“myRunnable的同步锁”之后才能运行。\n\n\n我们将上面的代码进行修改，然后再运行看看结果怎么样\n```java\n\npublic class Synchronized01 {\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(new MyRunnable());\n        Thread thread2 = new Thread(new MyRunnable());\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n结果如下:\n```shell\nThread-1 loop 0\nThread-0 loop 1\nThread-1 loop 1\nThread-1 loop 2\nThread-0 loop 2\nThread-1 loop 3\nThread-0 loop 3\nThread-0 loop 4\nThread-1 loop 4\nThread-0 is end\nThread-1 is end\n```\n\n可以看到两条线程是交替运行的。这是因为线程t1和线程t2分别创建并运行了两个Runnable对象，此时两个线程里的synchronized(this)锁的是不同的对象，因此这两个线程没有互斥性，是随机交替运行的。\n\n### 第二条规则验证\n第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。\n```java\n\n/**\n * 共享资源类\n */\nclass ResourceObject {\n\n    // 同步方法\n    public void synMethod() {\n        synchronized (this) {\n            for (int i = 0; i < 5; i++) {\n                System.out.println(Thread.currentThread().getName()+\" synMethod running \" + i);\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    // 非同步方法\n    public void noSynMethod() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\" noSynMethod running \" + i);\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\npublic class Synchronized02 {\n    public static void main(String[] args) {\n        ResourceObject resource = new ResourceObject();\n        Thread t1 = new Thread(() -> {\n           resource.synMethod();\n        });\n        Thread t2 = new Thread(() -> {\n           resource.noSynMethod();\n        });\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n结果如下：\n```java\nThread-0 synMethod running 0\nThread-1 noSynMethod running 0\nThread-0 synMethod running 1\nThread-1 noSynMethod running 1\nThread-0 synMethod running 2\nThread-1 noSynMethod running 2\nThread-0 synMethod running 3\nThread-1 noSynMethod running 3\nThread-0 synMethod running 4\nThread-1 noSynMethod running 4\n```\n可以看到两个线程交替运行。主线程中新建了两个子线程t1和t2。t1会调用resource对象的synMethod()方法，该方法内含有同步块；而t2则会调用resource对象的noSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“resource的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“resource”同步锁。\n\n\n### 第三条规则验证\n第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。\n```java\n/**\n * 共享资源类\n */\nclass ResourceObject {\n\n    // 同步方法\n    public void synMethod() {\n        synchronized (this) {\n            for (int i = 0; i < 5; i++) {\n                System.out.println(Thread.currentThread().getName()+\" synMethod running \" + i);\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    // 同步方法2\n    public void synMethod2() {\n        synchronized (this) {\n            for (int i = 0; i < 5; i++) {\n                System.out.println(Thread.currentThread().getName() + \" noSynMethod running \" + i);\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    }\n}\npublic class Synchronized02 {\n    public static void main(String[] args) {\n        ResourceObject resource = new ResourceObject();\n        Thread t1 = new Thread(() -> {\n           resource.synMethod();\n        });\n        Thread t2 = new Thread(() -> {\n           resource.synMethod2();\n        });\n        t1.start();\n        t2.start();\n    }\n}\n```\n结果如下：\n```shell\nThread-0 synMethod running 0\nThread-0 synMethod running 1\nThread-0 synMethod running 2\nThread-0 synMethod running 3\nThread-0 synMethod running 4\nThread-1 noSynMethod running 0\nThread-1 noSynMethod running 1\nThread-1 noSynMethod running 2\nThread-1 noSynMethod running 3\nThread-1 noSynMethod running 4\n```\n可以看到两个线程依次运行。主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Resource对象，而t1和t2共用此对象。因此，在t1运行时，t2会被阻塞，等待t1运行释放“resource对象的同步锁”，t2才能运行。\n\n## synchronized方法 和 synchronized代码块\n“synchronized方法”是用synchronized修饰方法，而 “synchronized代码块”则是用synchronized修饰代码块。\n\nsynchronized方法示例\n```java\npublic synchronized void synMethod() {\n        for(int i=0; i<1000000; i++);\n    }\n```\nsynchronized代码块示例\n```java\n public void synBlock() {\n        synchronized (this) {\n            for(int i=0; i<1000000; i++);\n        }\n    }\n```\nsynchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。下面通过一个示例来演示：\n\n```java\nclass Resource {\n    public synchronized void synMethod() {\n        for(int i=0; i<1000000; i++);\n    }\n\n    public void synBlock() {\n        synchronized (this) {\n            for(int i=0; i<1000000; i++);\n        }\n    }\n\n}\n\npublic class Synchronized03 {\n    public static void main(String[] args) {\n        Resource resource = new Resource();\n        long start, diff;\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        resource.synBlock();                                // 调用“synchronized方法”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(\"synMethod() : \" + diff);\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        resource.synMethod();                                // 调用“synchronized方法块”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(\"synBlock()  : \" + diff);\n    }\n}\n```\n\n运行结果:\n```shell\nsynMethod() : 5\nsynBlock()  : 3\n```\n## 示例锁和全局锁\n\n- 实例锁 -- 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。实例锁对应的就是synchronized关键字。\n- 全局锁 -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。\n\n关于“实例锁”和“全局锁”有一个很形象的例子：\n```java\npulbic class Resource {\n    public synchronized void synA(){}\n    public synchronized void synB(){}\n    public static synchronized void synC(){}\n    public static synchronized void synD(){}\n}\n```\n\n假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。\n\n(01) x.synA()与x.synB() \n\n(02) x.synA()与y.synA()\n\n(03) x.synC()与y.synD()\n\n(04) x.synA()与Resource.synC()\n\n### (01)情况：不能被同时访问\n因为synA和synB都是同一个对象的同步锁\n```java\nclass Resource {\n   public synchronized void synA() {\n       for (int i = 0; i < 5; i++) {\n           System.out.println(Thread.currentThread().getName()+\" synA\");\n           try {\n               Thread.sleep(10);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n    public synchronized void synB() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\" synB\");\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\npublic class Synchronized03 {\n    public static void main(String[] args) {\n        Resource resource = new Resource();\n       Thread t1 = new Thread(() -> {\n           resource.synA();\n       });\n       Thread t2 =new Thread(() -> {\n           resource.synB();\n       });\n       t1.start();\n       t2.start();\n    }\n}\n\n```\n结果如下：\n```shell\nThread-0 synA\nThread-0 synA\nThread-0 synA\nThread-0 synA\nThread-0 synA\nThread-1 synB\nThread-1 synB\nThread-1 synB\nThread-1 synB\nThread-1 synB\n```\n\n### (02)情况：能被同时访问\n因为访问的不是同一个对象的同步锁，x.synA()访问的是x的同步锁，y.synB()访问的是y的同步锁\n\n```java\nclass Resource {\n   public synchronized void synA() {\n       for (int i = 0; i < 5; i++) {\n           System.out.println(Thread.currentThread().getName()+\" synA\");\n           try {\n               Thread.sleep(10);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n    public synchronized void synB() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\" synB\");\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\npublic class Synchronized03 {\n    public static void main(String[] args) {\n       Thread t1 = new Thread(() -> {\n           new Resource().synA();\n       });\n       Thread t2 =new Thread(() -> {\n           new Resource().synB();\n       });\n       t1.start();\n       t2.start();\n    }\n}\n\n```\n结果如下:\n```Shell\nThread-1 synB\nThread-0 synA\nThread-1 synB\nThread-0 synA\nThread-0 synA\nThread-1 synB\nThread-0 synA\nThread-1 synB\nThread-1 synB\nThread-0 synA\n```\n\n### (03)情况：不能被同时访问\n因为synC()和synD()都是static类型，x.synC()相当于Resource.synC()，y.synC()相当于Resource.synD()，因此它们共用一个同步锁，不能被同时反问。\n```java\nclass Resource {\n   public static synchronized void synC() {\n       for (int i = 0; i < 5; i++) {\n           System.out.println(Thread.currentThread().getName()+\" synC\");\n           try {\n               Thread.sleep(10);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n    public static synchronized void synD() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\" synD\");\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\npublic class Synchronized03 {\n    public static void main(String[] args) {\n       Thread t1 = new Thread(() -> {\n           Resource.synC();\n       });\n       Thread t2 =new Thread(() -> {\n           Resource.synD();\n       });\n       t1.start();\n       t2.start();\n    }\n}\n\n```\n结果如下：\n```shell\nThread-0 synC\nThread-0 synC\nThread-0 synC\nThread-0 synC\nThread-0 synC\nThread-1 synD\nThread-1 synD\nThread-1 synD\nThread-1 synD\nThread-1 synD\n\n```\n### (03)情况：可以同时访问\n因为x.synA()使用的对象锁是x的对象锁，而synC是静态方法，Resource.sync()可以理解为使用的锁是“类的锁”，因此它们是可以同时被访问的\n```java\nclass Resource {\n   public  synchronized void synA() {\n       for (int i = 0; i < 5; i++) {\n           System.out.println(Thread.currentThread().getName()+\" synA\");\n           try {\n               Thread.sleep(10);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n    public static synchronized void synC() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\" synC\");\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\npublic class Synchronized03 {\n    public static void main(String[] args) {\n        Resource resource = new Resource();\n       Thread t1 = new Thread(() -> {\n           resource.synA();\n       });\n       Thread t2 =new Thread(() -> {\n           Resource.synC();\n       });\n       t1.start();\n       t2.start();\n    }\n}\n```\n\n结果如下：\n```shell\nThread-0 synA\nThread-1 synC\nThread-0 synA\nThread-1 synC\nThread-0 synA\nThread-1 synC\nThread-0 synA\nThread-1 synC\nThread-0 synA\nThread-1 synC\n\n```\n\n## synchronized底层原理\n```java\npublic class SynCodeBlock {\n    public int i;\n\n    public void syncTask(){\n        synchronized (this){\n            i++;\n        }\n    }\n}\n```\n\n通过javap反编译代码，得到执行字节码\n> javap -c SynCodeBlock.class \n\n![image.png](http://oss.osalien.com/dbblog/20201010/5c4a5cecba75473e91493dd3dfb1a3a0.png)\n\n如图，从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。\n','<h2 id=\"synchronized简介\">synchronized简介</h2>\n<p>在java中，每个对象有且仅有一个同步锁。这也意味着，<strong>同步锁是依赖于对象而存在的</strong>。</p>\n<p>当我们调用某个对象的synchronized方法时，就获取了该对象的同步锁。<strong>不同线程对同步锁的访问是互斥的</strong>,也就是说，某个时间点对象的同步锁只能被一个线程获取到！通过同步锁我们就能在多线程中实现对对象或方法的互斥访问。例如，现在有两个线程A和线程B，它们都会访问对象obj的同步锁。假设，在某一时刻，线程A获取到obj的同步锁并在执行一些操作；而此时，线程B也企图获取obj的同步锁，线程B将会获取失败，它必须等待，直到线程A释放了obj对象的同步锁之后线程B才能获取到obj对象的同步锁从而才可以运行。</p>\n<h2 id=\"synchronized基本规则\">synchronized基本规则</h2>\n<p>我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。</p>\n<ol>\n<li>第一条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li>\n<li>第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</li>\n<li>第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li>\n</ol>\n<h3 id=\"第一条规则验证\">第一条规则验证</h3>\n<pre><code class=\"language-java\">class MyRunnable implements Runnable {\n\n    @Override\n    public void run() {\n        synchronized (this) {\n            try {\n                for (int i = 0; i &lt; 5; i++) {\n                    Thread.sleep(100); \n                    System.out.println(Thread.currentThread().getName() + &quot; loop &quot; + i);\n                }\n                System.out.println(Thread.currentThread().getName() + &quot; is end&quot;);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\npublic class Synchronized01 {\n\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread1 = new Thread(myRunnable);  // 新建“线程t1”, t1是基于myRunnable这个Runnable对象\n        Thread thread2 = new Thread(myRunnable);  // 新建“线程t2”, t2是基于myRunnable这个Runnable对象\n        thread1.start();\n        thread2.start();\n    }\n}</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">Thread-0 loop 0\nThread-0 loop 1\nThread-0 loop 2\nThread-0 loop 3\nThread-0 loop 4\nThread-0 is end\nThread-1 loop 0\nThread-1 loop 1\nThread-1 loop 2\nThread-1 loop 3\nThread-1 loop 4\nThread-1 is end</code></pre>\n<p>结果说明：\nrun()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于&quot;myRunnable这个Runnable对象&quot;创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“myRunnable这个Runnable对象”；因此，线程t1和t2共享“myRunnable对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“myRunnable的同步锁”之后才能运行。</p>\n<p>我们将上面的代码进行修改，然后再运行看看结果怎么样</p>\n<pre><code class=\"language-java\">\npublic class Synchronized01 {\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(new MyRunnable());\n        Thread thread2 = new Thread(new MyRunnable());\n        thread1.start();\n        thread2.start();\n    }\n}</code></pre>\n<p>结果如下:</p>\n<pre><code class=\"language-shell\">Thread-1 loop 0\nThread-0 loop 1\nThread-1 loop 1\nThread-1 loop 2\nThread-0 loop 2\nThread-1 loop 3\nThread-0 loop 3\nThread-0 loop 4\nThread-1 loop 4\nThread-0 is end\nThread-1 is end</code></pre>\n<p>可以看到两条线程是交替运行的。这是因为线程t1和线程t2分别创建并运行了两个Runnable对象，此时两个线程里的synchronized(this)锁的是不同的对象，因此这两个线程没有互斥性，是随机交替运行的。</p>\n<h3 id=\"第二条规则验证\">第二条规则验证</h3>\n<p>第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</p>\n<pre><code class=\"language-java\">\n/**\n * 共享资源类\n */\nclass ResourceObject {\n\n    // 同步方法\n    public void synMethod() {\n        synchronized (this) {\n            for (int i = 0; i &lt; 5; i++) {\n                System.out.println(Thread.currentThread().getName()+&quot; synMethod running &quot; + i);\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    // 非同步方法\n    public void noSynMethod() {\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(Thread.currentThread().getName()+&quot; noSynMethod running &quot; + i);\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\npublic class Synchronized02 {\n    public static void main(String[] args) {\n        ResourceObject resource = new ResourceObject();\n        Thread t1 = new Thread(() -&gt; {\n           resource.synMethod();\n        });\n        Thread t2 = new Thread(() -&gt; {\n           resource.noSynMethod();\n        });\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-java\">Thread-0 synMethod running 0\nThread-1 noSynMethod running 0\nThread-0 synMethod running 1\nThread-1 noSynMethod running 1\nThread-0 synMethod running 2\nThread-1 noSynMethod running 2\nThread-0 synMethod running 3\nThread-1 noSynMethod running 3\nThread-0 synMethod running 4\nThread-1 noSynMethod running 4</code></pre>\n<p>可以看到两个线程交替运行。主线程中新建了两个子线程t1和t2。t1会调用resource对象的synMethod()方法，该方法内含有同步块；而t2则会调用resource对象的noSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“resource的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“resource”同步锁。</p>\n<h3 id=\"第三条规则验证\">第三条规则验证</h3>\n<p>第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</p>\n<pre><code class=\"language-java\">/**\n * 共享资源类\n */\nclass ResourceObject {\n\n    // 同步方法\n    public void synMethod() {\n        synchronized (this) {\n            for (int i = 0; i &lt; 5; i++) {\n                System.out.println(Thread.currentThread().getName()+&quot; synMethod running &quot; + i);\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    // 同步方法2\n    public void synMethod2() {\n        synchronized (this) {\n            for (int i = 0; i &lt; 5; i++) {\n                System.out.println(Thread.currentThread().getName() + &quot; noSynMethod running &quot; + i);\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    }\n}\npublic class Synchronized02 {\n    public static void main(String[] args) {\n        ResourceObject resource = new ResourceObject();\n        Thread t1 = new Thread(() -&gt; {\n           resource.synMethod();\n        });\n        Thread t2 = new Thread(() -&gt; {\n           resource.synMethod2();\n        });\n        t1.start();\n        t2.start();\n    }\n}</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">Thread-0 synMethod running 0\nThread-0 synMethod running 1\nThread-0 synMethod running 2\nThread-0 synMethod running 3\nThread-0 synMethod running 4\nThread-1 noSynMethod running 0\nThread-1 noSynMethod running 1\nThread-1 noSynMethod running 2\nThread-1 noSynMethod running 3\nThread-1 noSynMethod running 4</code></pre>\n<p>可以看到两个线程依次运行。主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Resource对象，而t1和t2共用此对象。因此，在t1运行时，t2会被阻塞，等待t1运行释放“resource对象的同步锁”，t2才能运行。</p>\n<h2 id=\"synchronized方法-和-synchronized代码块\">synchronized方法 和 synchronized代码块</h2>\n<p>“synchronized方法”是用synchronized修饰方法，而 “synchronized代码块”则是用synchronized修饰代码块。</p>\n<p>synchronized方法示例</p>\n<pre><code class=\"language-java\">public synchronized void synMethod() {\n        for(int i=0; i&lt;1000000; i++);\n    }</code></pre>\n<p>synchronized代码块示例</p>\n<pre><code class=\"language-java\"> public void synBlock() {\n        synchronized (this) {\n            for(int i=0; i&lt;1000000; i++);\n        }\n    }</code></pre>\n<p>synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。下面通过一个示例来演示：</p>\n<pre><code class=\"language-java\">class Resource {\n    public synchronized void synMethod() {\n        for(int i=0; i&lt;1000000; i++);\n    }\n\n    public void synBlock() {\n        synchronized (this) {\n            for(int i=0; i&lt;1000000; i++);\n        }\n    }\n\n}\n\npublic class Synchronized03 {\n    public static void main(String[] args) {\n        Resource resource = new Resource();\n        long start, diff;\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        resource.synBlock();                                // 调用“synchronized方法”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(&quot;synMethod() : &quot; + diff);\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        resource.synMethod();                                // 调用“synchronized方法块”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(&quot;synBlock()  : &quot; + diff);\n    }\n}</code></pre>\n<p>运行结果:</p>\n<pre><code class=\"language-shell\">synMethod() : 5\nsynBlock()  : 3</code></pre>\n<h2 id=\"示例锁和全局锁\">示例锁和全局锁</h2>\n<ul>\n<li>实例锁 -- 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。实例锁对应的就是synchronized关键字。</li>\n<li>全局锁 -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。</li>\n</ul>\n<p>关于“实例锁”和“全局锁”有一个很形象的例子：</p>\n<pre><code class=\"language-java\">pulbic class Resource {\n    public synchronized void synA(){}\n    public synchronized void synB(){}\n    public static synchronized void synC(){}\n    public static synchronized void synD(){}\n}</code></pre>\n<p>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。</p>\n<p>(01) x.synA()与x.synB() </p>\n<p>(02) x.synA()与y.synA()</p>\n<p>(03) x.synC()与y.synD()</p>\n<p>(04) x.synA()与Resource.synC()</p>\n<h3 id=\"01情况：不能被同时访问\">(01)情况：不能被同时访问</h3>\n<p>因为synA和synB都是同一个对象的同步锁</p>\n<pre><code class=\"language-java\">class Resource {\n   public synchronized void synA() {\n       for (int i = 0; i &lt; 5; i++) {\n           System.out.println(Thread.currentThread().getName()+&quot; synA&quot;);\n           try {\n               Thread.sleep(10);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n    public synchronized void synB() {\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(Thread.currentThread().getName()+&quot; synB&quot;);\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\npublic class Synchronized03 {\n    public static void main(String[] args) {\n        Resource resource = new Resource();\n       Thread t1 = new Thread(() -&gt; {\n           resource.synA();\n       });\n       Thread t2 =new Thread(() -&gt; {\n           resource.synB();\n       });\n       t1.start();\n       t2.start();\n    }\n}\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">Thread-0 synA\nThread-0 synA\nThread-0 synA\nThread-0 synA\nThread-0 synA\nThread-1 synB\nThread-1 synB\nThread-1 synB\nThread-1 synB\nThread-1 synB</code></pre>\n<h3 id=\"02情况：能被同时访问\">(02)情况：能被同时访问</h3>\n<p>因为访问的不是同一个对象的同步锁，x.synA()访问的是x的同步锁，y.synB()访问的是y的同步锁</p>\n<pre><code class=\"language-java\">class Resource {\n   public synchronized void synA() {\n       for (int i = 0; i &lt; 5; i++) {\n           System.out.println(Thread.currentThread().getName()+&quot; synA&quot;);\n           try {\n               Thread.sleep(10);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n    public synchronized void synB() {\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(Thread.currentThread().getName()+&quot; synB&quot;);\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\npublic class Synchronized03 {\n    public static void main(String[] args) {\n       Thread t1 = new Thread(() -&gt; {\n           new Resource().synA();\n       });\n       Thread t2 =new Thread(() -&gt; {\n           new Resource().synB();\n       });\n       t1.start();\n       t2.start();\n    }\n}\n</code></pre>\n<p>结果如下:</p>\n<pre><code class=\"language-Shell\">Thread-1 synB\nThread-0 synA\nThread-1 synB\nThread-0 synA\nThread-0 synA\nThread-1 synB\nThread-0 synA\nThread-1 synB\nThread-1 synB\nThread-0 synA</code></pre>\n<h3 id=\"03情况：不能被同时访问\">(03)情况：不能被同时访问</h3>\n<p>因为synC()和synD()都是static类型，x.synC()相当于Resource.synC()，y.synC()相当于Resource.synD()，因此它们共用一个同步锁，不能被同时反问。</p>\n<pre><code class=\"language-java\">class Resource {\n   public static synchronized void synC() {\n       for (int i = 0; i &lt; 5; i++) {\n           System.out.println(Thread.currentThread().getName()+&quot; synC&quot;);\n           try {\n               Thread.sleep(10);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n    public static synchronized void synD() {\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(Thread.currentThread().getName()+&quot; synD&quot;);\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\npublic class Synchronized03 {\n    public static void main(String[] args) {\n       Thread t1 = new Thread(() -&gt; {\n           Resource.synC();\n       });\n       Thread t2 =new Thread(() -&gt; {\n           Resource.synD();\n       });\n       t1.start();\n       t2.start();\n    }\n}\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">Thread-0 synC\nThread-0 synC\nThread-0 synC\nThread-0 synC\nThread-0 synC\nThread-1 synD\nThread-1 synD\nThread-1 synD\nThread-1 synD\nThread-1 synD\n</code></pre>\n<h3 id=\"03情况：可以同时访问\">(03)情况：可以同时访问</h3>\n<p>因为x.synA()使用的对象锁是x的对象锁，而synC是静态方法，Resource.sync()可以理解为使用的锁是“类的锁”，因此它们是可以同时被访问的</p>\n<pre><code class=\"language-java\">class Resource {\n   public  synchronized void synA() {\n       for (int i = 0; i &lt; 5; i++) {\n           System.out.println(Thread.currentThread().getName()+&quot; synA&quot;);\n           try {\n               Thread.sleep(10);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n    public static synchronized void synC() {\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(Thread.currentThread().getName()+&quot; synC&quot;);\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\npublic class Synchronized03 {\n    public static void main(String[] args) {\n        Resource resource = new Resource();\n       Thread t1 = new Thread(() -&gt; {\n           resource.synA();\n       });\n       Thread t2 =new Thread(() -&gt; {\n           Resource.synC();\n       });\n       t1.start();\n       t2.start();\n    }\n}</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">Thread-0 synA\nThread-1 synC\nThread-0 synA\nThread-1 synC\nThread-0 synA\nThread-1 synC\nThread-0 synA\nThread-1 synC\nThread-0 synA\nThread-1 synC\n</code></pre>\n<h2 id=\"synchronized底层原理\">synchronized底层原理</h2>\n<pre><code class=\"language-java\">public class SynCodeBlock {\n    public int i;\n\n    public void syncTask(){\n        synchronized (this){\n            i++;\n        }\n    }\n}</code></pre>\n<p>通过javap反编译代码，得到执行字节码</p>\n<blockquote>\n<p>javap -c SynCodeBlock.class </p>\n</blockquote>\n<p><img src=\"http://oss.osalien.com/dbblog/20201010/5c4a5cecba75473e91493dd3dfb1a3a0.png\" alt=\"image.png\"></p>\n<p>如图，从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。</p>\n',40,13,2,NULL,NULL,'2019-07-24 15:32:43','2020-10-10 00:16:01',0,'32,42,57',1,0),(22,'Java多线程基础03——线程等待与唤醒','在Object中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。','Bobbi','### wait(),notify(),notifyAll()等方法介绍\n在Object中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。\n\nObject类中关于等待/唤醒的API详细信息如下：\n- notify() -- 唤醒在此对象监视器上等待的单个线程。\n- notifyAll() -- 唤醒在此对象监视器上等待的所有线程。\n- wait() -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。\n- wait(long timeout) -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。\n- wait(long timeout, int nanos)  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。\n\n> wait(), notify(), notifyAll() 需要和 synchonized 搭配使用， 否则会报“java.lang.IllegalMonitorStateException”异常。\n\n\n## wait()和notify()示例\n```java\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        synchronized (this) {\n            System.out.println(Thread.currentThread().getName()+ \" call notify\");\n            notify();\n        }\n    }\n}\npublic class WaitTest {\n    public static void main(String[] args) {\n        MyThread t1 = new MyThread();\n        synchronized (t1) {\n            // 启动“线程t1”\n            System.out.println(Thread.currentThread().getName()+\" start t1\");\n            t1.start();\n            try {\n                // 主线程等待t1通过notify()唤醒。\n                System.out.println(Thread.currentThread().getName()+\" wait()\");\n                t1.wait();\n                System.out.println(Thread.currentThread().getName()+\" continue\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n```\n结果如下：\n```shell\nmain start t1\nmain wait()\nThread-0 call notify\nmain continue\n```\n结果说明：\n\n(01) 注意，\"主线程\" 代表“主线程main”。\"线程t1\" 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。<br>\n(02) “主线程”通过 new MyThread() 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。<br>\n(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。<br>\n(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。<br>\n(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。\n\n对于以上代码，**t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？**\n\n- 注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！\n这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！\n\n\n## wait(long timeout)和notify()\nwait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。\n下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。\n\n```java\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" run \");\n        // 死循环，不断运行。\n        while(true)\n            ;\n    }\n}\npublic class WaitTest {\n    public static void main(String[] args) {\n        MyThread t1= new MyThread();\n        synchronized (t1) {\n            // 启动“线程t1”\n            System.out.println(Thread.currentThread().getName()+\" start t1\");\n            t1.start();\n            try {\n                // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。\n                System.out.println(Thread.currentThread().getName()+\" wait()\");\n                t1.wait(3000);\n\n                System.out.println(Thread.currentThread().getName()+\" continue\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n```\n运行结果：\n```shell\nmain start t1\nmain wait()\nThread-0 run // 大约三秒后\nmain continue\n```\n结果说明：<br>\n(01) 注意，\"主线程\" 代表线程main。\"线程t1\" 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。<br>\n(02) 主线程main执行t1.start()启动“线程t1”。<br>\n(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。<br>\n(04) “线程t1”运行之后，进入了死循环，一直不断的运行。<br>\n(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。<br>\n\n## wait() 和 notifyAll()\n```java\nclass MyThread extends Thread {\n\n    private String lockObject;\n\n    public MyThread(String lockObject) {\n        this.lockObject = lockObject;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lockObject) {\n            try {\n                System.out.println(Thread.currentThread().getName()+\"线程等待\");\n                lockObject.wait();\n                System.out.println(Thread.currentThread().getName()+\"线程恢复运行\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\npublic class WaitTest {\n    public static void main(String[] args) {\n        String lockObject = \"lockObject\";\n        MyThread t1 = new MyThread(lockObject);\n        MyThread t2 = new MyThread(lockObject);\n        MyThread t3 = new MyThread(lockObject);\n        t1.start();\n        t2.start();\n        t3.start();\n\n        try {\n            Thread.sleep(3000);\n            synchronized (lockObject){\n		System.out.println(\"main notifyAll()\");\n                lockObject.notifyAll();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}\n```\n运行结果：\n```shell\nThread-0线程等待\nThread-1线程等待\nThread-2线程等待\nmain notifyAll()\nThread-2线程恢复运行\nThread-1线程恢复运行\nThread-0线程恢复运行\n```\n结果说明：\n\n(01) 主线程中新建并且启动了3个线程\"t1\", \"t2\"和\"t3\"。<br>\n(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设\"t1\", \"t2\"和\"t3\"这3个线程都运行了。以\"t1\"为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，\"t2\"和\"t3\"也会等待其它线程通过nofity()或nofityAll()来唤醒它们。\n(03) 主线程休眠3秒之后，接着运行。执行 lockObject.notifyAll() 唤醒lockObject上的等待线程，即唤醒\"t1\", \"t2\"和\"t3\"这3个线程。 紧接着，主线程的synchronized(lockObject)运行完毕之后，主线程释放“lockObject锁”。这样，\"t1\", \"t2\"和\"t3\"就可以获取“obj锁”而继续运行了！\n\n## 为什么notify(), wait()等函数定义在Object中，而不是Thread中\n\nObject中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。\n\nwait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！\n\n而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。\n\n负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。**虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。**\n\n总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。\n\n','<h3 id=\"waitnotifynotifyall等方法介绍\">wait(),notify(),notifyAll()等方法介绍</h3>\n<p>在Object中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p>\n<p>Object类中关于等待/唤醒的API详细信息如下：</p>\n<ul>\n<li>notify() -- 唤醒在此对象监视器上等待的单个线程。</li>\n<li>notifyAll() -- 唤醒在此对象监视器上等待的所有线程。</li>\n<li>wait() -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。</li>\n<li>wait(long timeout) -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</li>\n<li>wait(long timeout, int nanos)  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</li>\n</ul>\n<blockquote>\n<p>wait(), notify(), notifyAll() 需要和 synchonized 搭配使用， 否则会报“java.lang.IllegalMonitorStateException”异常。</p>\n</blockquote>\n<h2 id=\"wait和notify示例\">wait()和notify()示例</h2>\n<pre><code class=\"language-java\">class MyThread extends Thread {\n    @Override\n    public void run() {\n        synchronized (this) {\n            System.out.println(Thread.currentThread().getName()+ &quot; call notify&quot;);\n            notify();\n        }\n    }\n}\npublic class WaitTest {\n    public static void main(String[] args) {\n        MyThread t1 = new MyThread();\n        synchronized (t1) {\n            // 启动“线程t1”\n            System.out.println(Thread.currentThread().getName()+&quot; start t1&quot;);\n            t1.start();\n            try {\n                // 主线程等待t1通过notify()唤醒。\n                System.out.println(Thread.currentThread().getName()+&quot; wait()&quot;);\n                t1.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; continue&quot;);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">main start t1\nmain wait()\nThread-0 call notify\nmain continue</code></pre>\n<p>结果说明：</p>\n<p>(01) 注意，&quot;主线程&quot; 代表“主线程main”。&quot;线程t1&quot; 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。<br>\n(02) “主线程”通过 new MyThread() 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。<br>\n(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。<br>\n(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。<br>\n(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。</p>\n<p>对于以上代码，<strong>t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？</strong></p>\n<ul>\n<li>注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！\n这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！</li>\n</ul>\n<h2 id=\"waitlong-timeout和notify\">wait(long timeout)和notify()</h2>\n<p>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。\n下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。</p>\n<pre><code class=\"language-java\">class MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + &quot; run &quot;);\n        // 死循环，不断运行。\n        while(true)\n            ;\n    }\n}\npublic class WaitTest {\n    public static void main(String[] args) {\n        MyThread t1= new MyThread();\n        synchronized (t1) {\n            // 启动“线程t1”\n            System.out.println(Thread.currentThread().getName()+&quot; start t1&quot;);\n            t1.start();\n            try {\n                // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。\n                System.out.println(Thread.currentThread().getName()+&quot; wait()&quot;);\n                t1.wait(3000);\n\n                System.out.println(Thread.currentThread().getName()+&quot; continue&quot;);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-shell\">main start t1\nmain wait()\nThread-0 run // 大约三秒后\nmain continue</code></pre>\n<p>结果说明：<br>\n(01) 注意，&quot;主线程&quot; 代表线程main。&quot;线程t1&quot; 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。<br>\n(02) 主线程main执行t1.start()启动“线程t1”。<br>\n(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。<br>\n(04) “线程t1”运行之后，进入了死循环，一直不断的运行。<br>\n(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。<br></p>\n<h2 id=\"wait-和-notifyall\">wait() 和 notifyAll()</h2>\n<pre><code class=\"language-java\">class MyThread extends Thread {\n\n    private String lockObject;\n\n    public MyThread(String lockObject) {\n        this.lockObject = lockObject;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lockObject) {\n            try {\n                System.out.println(Thread.currentThread().getName()+&quot;线程等待&quot;);\n                lockObject.wait();\n                System.out.println(Thread.currentThread().getName()+&quot;线程恢复运行&quot;);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\npublic class WaitTest {\n    public static void main(String[] args) {\n        String lockObject = &quot;lockObject&quot;;\n        MyThread t1 = new MyThread(lockObject);\n        MyThread t2 = new MyThread(lockObject);\n        MyThread t3 = new MyThread(lockObject);\n        t1.start();\n        t2.start();\n        t3.start();\n\n        try {\n            Thread.sleep(3000);\n            synchronized (lockObject){\n        System.out.println(&quot;main notifyAll()&quot;);\n                lockObject.notifyAll();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-shell\">Thread-0线程等待\nThread-1线程等待\nThread-2线程等待\nmain notifyAll()\nThread-2线程恢复运行\nThread-1线程恢复运行\nThread-0线程恢复运行</code></pre>\n<p>结果说明：</p>\n<p>(01) 主线程中新建并且启动了3个线程&quot;t1&quot;, &quot;t2&quot;和&quot;t3&quot;。<br>\n(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设&quot;t1&quot;, &quot;t2&quot;和&quot;t3&quot;这3个线程都运行了。以&quot;t1&quot;为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，&quot;t2&quot;和&quot;t3&quot;也会等待其它线程通过nofity()或nofityAll()来唤醒它们。\n(03) 主线程休眠3秒之后，接着运行。执行 lockObject.notifyAll() 唤醒lockObject上的等待线程，即唤醒&quot;t1&quot;, &quot;t2&quot;和&quot;t3&quot;这3个线程。 紧接着，主线程的synchronized(lockObject)运行完毕之后，主线程释放“lockObject锁”。这样，&quot;t1&quot;, &quot;t2&quot;和&quot;t3&quot;就可以获取“obj锁”而继续运行了！</p>\n<h2 id=\"为什么notify-wait等函数定义在object中，而不是thread中\">为什么notify(), wait()等函数定义在Object中，而不是Thread中</h2>\n<p>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。</p>\n<p>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！</p>\n<p>而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。</p>\n<p>负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。<strong>虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</strong></p>\n<p>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。</p>\n',30,6,2,NULL,NULL,'2019-07-25 15:33:25','2020-10-09 23:57:45',0,'32,42,57',1,0),(23,'Java多线程基础04——线程让步','yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！','Bobbi','## yield()介绍\nyield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！\n\n## yield()示例\n```java\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(Thread.currentThread().getName() + \" \"+ i);\n            // i整除4时，调用yield\n            if (i % 4 == 0) {\n                System.out.println(Thread.currentThread().getName() + \" yield\");\n                Thread.yield();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n        t1.start();\n        t2.start();\n\n    }\n}\n\n```\n结果如下：\n```shell\nThread-1 0\nThread-0 0\nThread-1 yield\nThread-0 yield\nThread-0 1\nThread-0 2\nThread-0 3\nThread-0 4\nThread-0 yield\nThread-1 1\nThread-0 5\nThread-1 2\nThread-0 6\nThread-1 3\nThread-0 7\nThread-1 4\nThread-0 8\nThread-1 yield\nThread-0 yield\nThread-1 5\nThread-0 9\nThread-1 6\nThread-1 7\nThread-1 8\nThread-1 yield\nThread-1 9\n\n```\n\n结果说明：\n可以看到，线程在满足i整除4时，有时成功“线程让步”有时却没有让步，这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。\n\n## yield() 与 wait()的比较\n我们知道，wait()的作用是使线程从“运行状态”进入“等待（阻塞）队列”，同时会释放同步锁。而yield()的作用是让步，他也会让当前线程离开“运行状态”，它们的区别是：\n\n**(1)wait()的作用是使线程从“运行状态”进入“等待（阻塞）队列”,而yield的作用是让线程从“运行状态”到“就绪状态”**\n\n**(2)wait()会释放它所持有的同步锁，yield()不会释放同步锁**\n\n下面演示yield不会释放同步锁\n```java\npublic class MyThread extends Thread {\n    private String lock;\n\n    public MyThread( String lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            for (int i = 0; i < 10; i++) {\n                System.out.println(Thread.currentThread().getName() + \" \"+ i);\n                // i整除4时，调用yield\n                if (i % 4 == 0) {\n                    System.out.println(Thread.currentThread().getName() + \" yield\");\n                    Thread.yield();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String lock = \"lock\";\n        MyThread t1 = new MyThread(lock);\n        MyThread t2 = new MyThread(lock);\n        t1.start();\n        t2.start();\n\n    }\n}\n```\n运行结果：\n```shell\nThread-0 0\nThread-0 yield\nThread-0 1\nThread-0 2\nThread-0 3\nThread-0 4\nThread-0 yield\nThread-0 5\nThread-0 6\nThread-0 7\nThread-0 8\nThread-0 yield\nThread-0 9\nThread-1 0\nThread-1 yield\nThread-1 1\nThread-1 2\nThread-1 3\nThread-1 4\nThread-1 yield\nThread-1 5\nThread-1 6\nThread-1 7\nThread-1 8\nThread-1 yield\nThread-1 9\n```\n结果说明：\n线程t1和t2共同持有同一把对象锁，从结果中可以看到，在t1运行过程中，虽然调用了yield方法，但是，t2并不会获取cpu的执行权的，因为t1没有释放所持有的对象锁。','<h2 id=\"yield介绍\">yield()介绍</h2>\n<p>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</p>\n<h2 id=\"yield示例\">yield()示例</h2>\n<pre><code class=\"language-java\">public class MyThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 10; i++) {\n            System.out.println(Thread.currentThread().getName() + &quot; &quot;+ i);\n            // i整除4时，调用yield\n            if (i % 4 == 0) {\n                System.out.println(Thread.currentThread().getName() + &quot; yield&quot;);\n                Thread.yield();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n        t1.start();\n        t2.start();\n\n    }\n}\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">Thread-1 0\nThread-0 0\nThread-1 yield\nThread-0 yield\nThread-0 1\nThread-0 2\nThread-0 3\nThread-0 4\nThread-0 yield\nThread-1 1\nThread-0 5\nThread-1 2\nThread-0 6\nThread-1 3\nThread-0 7\nThread-1 4\nThread-0 8\nThread-1 yield\nThread-0 yield\nThread-1 5\nThread-0 9\nThread-1 6\nThread-1 7\nThread-1 8\nThread-1 yield\nThread-1 9\n</code></pre>\n<p>结果说明：\n可以看到，线程在满足i整除4时，有时成功“线程让步”有时却没有让步，这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。</p>\n<h2 id=\"yield-与-wait的比较\">yield() 与 wait()的比较</h2>\n<p>我们知道，wait()的作用是使线程从“运行状态”进入“等待（阻塞）队列”，同时会释放同步锁。而yield()的作用是让步，他也会让当前线程离开“运行状态”，它们的区别是：</p>\n<p><strong>(1)wait()的作用是使线程从“运行状态”进入“等待（阻塞）队列”,而yield的作用是让线程从“运行状态”到“就绪状态”</strong></p>\n<p><strong>(2)wait()会释放它所持有的同步锁，yield()不会释放同步锁</strong></p>\n<p>下面演示yield不会释放同步锁</p>\n<pre><code class=\"language-java\">public class MyThread extends Thread {\n    private String lock;\n\n    public MyThread( String lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            for (int i = 0; i &lt; 10; i++) {\n                System.out.println(Thread.currentThread().getName() + &quot; &quot;+ i);\n                // i整除4时，调用yield\n                if (i % 4 == 0) {\n                    System.out.println(Thread.currentThread().getName() + &quot; yield&quot;);\n                    Thread.yield();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String lock = &quot;lock&quot;;\n        MyThread t1 = new MyThread(lock);\n        MyThread t2 = new MyThread(lock);\n        t1.start();\n        t2.start();\n\n    }\n}</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-shell\">Thread-0 0\nThread-0 yield\nThread-0 1\nThread-0 2\nThread-0 3\nThread-0 4\nThread-0 yield\nThread-0 5\nThread-0 6\nThread-0 7\nThread-0 8\nThread-0 yield\nThread-0 9\nThread-1 0\nThread-1 yield\nThread-1 1\nThread-1 2\nThread-1 3\nThread-1 4\nThread-1 yield\nThread-1 5\nThread-1 6\nThread-1 7\nThread-1 8\nThread-1 yield\nThread-1 9</code></pre>\n<p>结果说明：\n线程t1和t2共同持有同一把对象锁，从结果中可以看到，在t1运行过程中，虽然调用了yield方法，但是，t2并不会获取cpu的执行权的，因为t1没有释放所持有的对象锁。</p>\n',18,1,2,NULL,NULL,'2019-07-26 04:36:47','2020-10-09 23:56:52',0,'32,42,57',1,0),(24,'Java多线程基础05——线程休眠','sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。','Bobbi','sleep()的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“阻塞（休眠）状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度运行\n\n## sleep 示例\n```java\npublic class MyThread extends Thread {\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\n            // i整除4时，调用yield\n            if (i % 4 == 0) {\n                System.out.println(Thread.currentThread().getName() + \" sleep 1000ms\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread t1 = new MyThread();\n        t1.start();\n\n    }\n}\n\n```\n运行结果：\n\n```shell\nThread-0 0\nThread-0 sleep 1000ms\nThread-0 1\nThread-0 2\nThread-0 3\nThread-0 4\nThread-0 sleep 1000ms\nThread-0 5\nThread-0 6\nThread-0 7\nThread-0 8\nThread-0 sleep 1000ms\nThread-0 9\n```\n结果说明：\n程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(1000)休眠1000毫秒。\n\n## sleep()和wait的比较\n(1) wait()的作用是让线程从“运行状态”进入“阻塞（等待）状态”，sleep()也是让线程由“运行状态”进入“阻塞(休眠)状态”\n\n**(2)wait()会释放对象的同步锁，而sleep不会释放锁**\n\n下面是sleep()不会释放对象锁的示例\n```java\npublic class MyThread extends Thread {\n    private String lock;\n\n    public MyThread(String lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            for (int i = 0; i < 10; i++) {\n                System.out.println(Thread.currentThread().getName() + \" \"+ i);\n                // i整除4时，调用yield\n                if (i % 4 == 0) {\n                    System.out.println(Thread.currentThread().getName() + \" sleep 1000ms\");\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String lock = \"lock\";\n        MyThread t1 = new MyThread(lock);\n        MyThread t2 = new MyThread(lock);\n        t1.start();\n        t2.start();\n\n    }\n}\n\n```\n运行结果：\n```shell\nThread-0 0\nThread-0 sleep 1000ms\nThread-0 1\nThread-0 2\nThread-0 3\nThread-0 4\nThread-0 sleep 1000ms\nThread-0 5\nThread-0 6\nThread-0 7\nThread-0 8\nThread-0 sleep 1000ms\nThread-0 9\nThread-1 0\nThread-1 sleep 1000ms\nThread-1 1\nThread-1 2\nThread-1 3\nThread-1 4\nThread-1 sleep 1000ms\nThread-1 5\nThread-1 6\nThread-1 7\nThread-1 8\nThread-1 sleep 1000ms\nThread-1 9\n```\n结果说明：\n主线程main启动了两个线程t1和t2。t1和t2在运行的时候会引用同一个对象锁。在t1运行的过程中，虽然调用了Thread.sleep(1000)但是，t2并不会获取cpu的执行权。因为，t1没有释放这个对象锁','<p>sleep()的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“阻塞（休眠）状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度运行</p>\n<h2 id=\"sleep-示例\">sleep 示例</h2>\n<pre><code class=\"language-java\">public class MyThread extends Thread {\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 10; i++) {\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\n            // i整除4时，调用yield\n            if (i % 4 == 0) {\n                System.out.println(Thread.currentThread().getName() + &quot; sleep 1000ms&quot;);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread t1 = new MyThread();\n        t1.start();\n\n    }\n}\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-shell\">Thread-0 0\nThread-0 sleep 1000ms\nThread-0 1\nThread-0 2\nThread-0 3\nThread-0 4\nThread-0 sleep 1000ms\nThread-0 5\nThread-0 6\nThread-0 7\nThread-0 8\nThread-0 sleep 1000ms\nThread-0 9</code></pre>\n<p>结果说明：\n程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(1000)休眠1000毫秒。</p>\n<h2 id=\"sleep和wait的比较\">sleep()和wait的比较</h2>\n<p>(1) wait()的作用是让线程从“运行状态”进入“阻塞（等待）状态”，sleep()也是让线程由“运行状态”进入“阻塞(休眠)状态”</p>\n<p><strong>(2)wait()会释放对象的同步锁，而sleep不会释放锁</strong></p>\n<p>下面是sleep()不会释放对象锁的示例</p>\n<pre><code class=\"language-java\">public class MyThread extends Thread {\n    private String lock;\n\n    public MyThread(String lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            for (int i = 0; i &lt; 10; i++) {\n                System.out.println(Thread.currentThread().getName() + &quot; &quot;+ i);\n                // i整除4时，调用yield\n                if (i % 4 == 0) {\n                    System.out.println(Thread.currentThread().getName() + &quot; sleep 1000ms&quot;);\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String lock = &quot;lock&quot;;\n        MyThread t1 = new MyThread(lock);\n        MyThread t2 = new MyThread(lock);\n        t1.start();\n        t2.start();\n\n    }\n}\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-shell\">Thread-0 0\nThread-0 sleep 1000ms\nThread-0 1\nThread-0 2\nThread-0 3\nThread-0 4\nThread-0 sleep 1000ms\nThread-0 5\nThread-0 6\nThread-0 7\nThread-0 8\nThread-0 sleep 1000ms\nThread-0 9\nThread-1 0\nThread-1 sleep 1000ms\nThread-1 1\nThread-1 2\nThread-1 3\nThread-1 4\nThread-1 sleep 1000ms\nThread-1 5\nThread-1 6\nThread-1 7\nThread-1 8\nThread-1 sleep 1000ms\nThread-1 9</code></pre>\n<p>结果说明：\n主线程main启动了两个线程t1和t2。t1和t2在运行的时候会引用同一个对象锁。在t1运行的过程中，虽然调用了Thread.sleep(1000)但是，t2并不会获取cpu的执行权。因为，t1没有释放这个对象锁</p>\n',19,1,2,NULL,NULL,'2019-07-27 06:40:12','2020-10-09 23:57:02',0,'32,42,57',1,0),(25,'Java多线程基础06——join()','join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。','Bobbi','join() 的作用：让“当前线程”等待“另一个线程”结束之后才能继续运行。\n## join()示例\n```java\nclass MainThread extends Thread {\n    public MainThread(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        SubThread subThread = new SubThread(\"subThread\");\n        subThread.start();\n        try {\n            subThread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        for (int i = 0; i < 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\" is running\");\n        }\n    }\n}\nclass SubThread extends Thread {\n    public SubThread(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\" is running\");\n        }\n    }\n}\n\npublic class Mythread {\n    public static void main(String[] args) {\n        MainThread mainThread = new MainThread(\"mainThread\");\n        mainThread.start();\n    }\n}\n```\n运行结果：\n```shell\nsubThread is running\nsubThread is running\nsubThread is running\nsubThread is running\nsubThread is running\nmainThread is running\nmainThread is running\nmainThread is running\nmainThread is running\nmainThread is running\n```\n结果说明：\n上面有两个类，SubThread是在MainThread中创建并启动的，所以MainThrea是“主线程”，SubThread是“子线程”\n\n在MainThread中，调用了subThread.join()，所以，主线程MainThread会一直等待直到子线程subThread运行完毕,MainThread主线程才能继续运行\n\n## join()源码分析(基于JDK8)\n```java\n public final synchronized void join(long millis)\n    throws InterruptedException {\n        long base = System.currentTimeMillis();\n        long now = 0;\n\n        if (millis < 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n\n        if (millis == 0) {\n            while (isAlive()) {\n                wait(0);\n            }\n        } else {\n            while (isAlive()) {\n                long delay = millis - now;\n                if (delay <= 0) {\n                    break;\n                }\n                wait(delay);\n                now = System.currentTimeMillis() - base;\n            }\n        }\n    }\n```\n说明：\n从代码中，可以发现，当millis==0时；只要子线程是活的，主线程就不停的等待。join的底层原理是其实是无限的等待。','<p>join() 的作用：让“当前线程”等待“另一个线程”结束之后才能继续运行。</p>\n<h2 id=\"join示例\">join()示例</h2>\n<pre><code class=\"language-java\">class MainThread extends Thread {\n    public MainThread(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        SubThread subThread = new SubThread(&quot;subThread&quot;);\n        subThread.start();\n        try {\n            subThread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(Thread.currentThread().getName()+&quot; is running&quot;);\n        }\n    }\n}\nclass SubThread extends Thread {\n    public SubThread(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(Thread.currentThread().getName()+&quot; is running&quot;);\n        }\n    }\n}\n\npublic class Mythread {\n    public static void main(String[] args) {\n        MainThread mainThread = new MainThread(&quot;mainThread&quot;);\n        mainThread.start();\n    }\n}</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-shell\">subThread is running\nsubThread is running\nsubThread is running\nsubThread is running\nsubThread is running\nmainThread is running\nmainThread is running\nmainThread is running\nmainThread is running\nmainThread is running</code></pre>\n<p>结果说明：\n上面有两个类，SubThread是在MainThread中创建并启动的，所以MainThrea是“主线程”，SubThread是“子线程”</p>\n<p>在MainThread中，调用了subThread.join()，所以，主线程MainThread会一直等待直到子线程subThread运行完毕,MainThread主线程才能继续运行</p>\n<h2 id=\"join源码分析基于jdk8\">join()源码分析(基于JDK8)</h2>\n<pre><code class=\"language-java\"> public final synchronized void join(long millis)\n    throws InterruptedException {\n        long base = System.currentTimeMillis();\n        long now = 0;\n\n        if (millis &lt; 0) {\n            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);\n        }\n\n        if (millis == 0) {\n            while (isAlive()) {\n                wait(0);\n            }\n        } else {\n            while (isAlive()) {\n                long delay = millis - now;\n                if (delay &lt;= 0) {\n                    break;\n                }\n                wait(delay);\n                now = System.currentTimeMillis() - base;\n            }\n        }\n    }</code></pre>\n<p>说明：\n从代码中，可以发现，当millis==0时；只要子线程是活的，主线程就不停的等待。join的底层原理是其实是无限的等待。</p>\n',25,1,2,NULL,NULL,'2019-07-27 09:00:09','2020-10-09 23:57:10',0,'32,42,57',1,0),(26,'Java多线程基础07——线程中断','在介绍终止线程的方式之前，有必要先对interrupt()进行了解','Bobbi','## interrupt()介绍\n在介绍终止线程的方式之前，有必要先对interrupt()进行了解。关于interrupt()，jdk的文档描述如下：\n- interrupt()的作用是中断本线程。本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。\n\n- 如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。\n\n- 如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。\n\n- 如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。\n中断一个“已终止的线程”不会产生任何操作。\n\n通过上面的分析，我们可以总结，**调用线程类的interrupt()方法，其本质只是设置该线程的中断标志，将中断标志设置为true，并根据线程状态决定是否抛出异常。** 因此，通过interrupt()方法真正实现线程的中断原理是：开发人员根据中断标志的具体值，来决定如何退出线程。\n\n## 终止线程的方式\nThread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！\n\n### 终止处于“阻塞状态”的线程\n当线程由于被调用了sleep().wait(),join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，**中断标记会被清除**，同时产生一个InterruptedException异常。将InterrupedException放在适当的位置就能终止线程，形式如下：\n```java\n@Override\npublic void run() {\n    try {\n        while (true) {\n            // 执行任务...\n        }\n    } catch (InterruptedException ie) {  \n        // 由于产生InterruptedException异常，退出while(true)循环，线程终止！\n    }\n}\n```\n说明：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！\n\n注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：\n``` java\n@Override\npublic void run() {\n    while (true) {\n        try {\n            // 执行任务...\n        } catch (InterruptedException ie) {  \n            // InterruptedException在while(true)循环体内。\n            // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出\n            break;\n        }\n    }\n}\n```\n说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。\n\n### 终止处于“运行状态”的线程\n通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。\n\n#### (1) 通过“中断”标记终止线程\n```java\n@Override\npublic void run() {\n    while (!isInterrupted()) {\n        // 执行任务...\n    }\n}\n```\n说明：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。\n\n注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。\n\n#### (2) 通过“额外添加标记”。\n```java\nprivate volatile boolean flag= true;\nprotected void stopTask() {\n    flag = false;\n}\n\n@Override\npublic void run() {\n    while (flag) {\n        // 执行任务...\n    }\n}\n```\n说明：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。\n\n注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。\n\n### 处于“阻塞状态”和“运行状态”的终止方式\n```java\n@Override\npublic void run() {\n    try {\n        // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n        while (!isInterrupted()) {\n            // 执行任务...\n        }\n    } catch (InterruptedException ie) {  \n        // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n    }\n}\n```\n\n## 终止线程示例\n```java\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        try {\n            int i = 0;\n            while (!isInterrupted()) {\n                Thread.sleep(100);\n                i++;\n                System.out.println(Thread.currentThread().getName() + \"(\" + this.getState() + \") loop \" + i);\n            }\n        } catch (InterruptedException e) {\n            System.out.println(Thread.currentThread().getName() + \"(\" + this.getState() + \") catch InterruptedException\");\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            MyThread t1 = new MyThread();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is new.\");\n\n            t1.start();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is started.\");\n\n            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n            Thread.sleep(300);\n            t1.interrupt();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is interrupted.\");\n\n            // 主线程休眠300ms，然后查看t1的状态\n            Thread.sleep(300);\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is interrupted now.\");\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n运行结果：\n``` shell\nThread-0 (NEW) is new.\nThread-0 (RUNNABLE) is started.\nThread-0(RUNNABLE) loop 1\nThread-0(RUNNABLE) loop 2\nThread-0 (TIMED_WAITING) is interrupted.\nThread-0(RUNNABLE) catch InterruptedException\nThread-0 (TERMINATED) is interrupted now.\n```\n结果说明：<br>\n(1)主线程main创建一个线程t1,并且启动t1<br>\n(2)t1启动之后，会不断检查它的中断标记，如果中断标记为false，则休眠100ms<br>\n(3) t1休眠之后，会切换到主线程，执行t1.interrupt()中断线程t1。t1收到中断指令后，会将t1的中断标记设置为false(**阻塞状态标记清除为false并抛出异常**),而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体之外捕获的异常；因此循环被终止。\n\n\n\n我们将程序稍稍改一下，将run()方法中捕获的InterruptedException异常代码快移到while()循环体内\n\n```java\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n\n        int i = 0;\n        while (!isInterrupted()) {\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                System.out.println(Thread.currentThread().getName() + \"(\" + this.getState() + \") catch InterruptedException\");\n            }\n            i++;\n            System.out.println(Thread.currentThread().getName() + \"(\" + this.getState() + \") loop \" + i);\n\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            MyThread t1 = new MyThread();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is new.\");\n\n            t1.start();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is started.\");\n\n            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n            Thread.sleep(300);\n            t1.interrupt();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is interrupted.\");\n\n            // 主线程休眠300ms，然后查看t1的状态\n            Thread.sleep(300);\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is interrupted now.\");\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n结果如下：\n```shell\nThread-0 (NEW) is new.\nThread-0 (RUNNABLE) is started.\nThread-0(RUNNABLE) loop 1\nThread-0(RUNNABLE) loop 2\nThread-0 (TIMED_WAITING) is interrupted.\nThread-0(RUNNABLE) catch InterruptedException\nThread-0(RUNNABLE) loop 3\nThread-0(RUNNABLE) loop 4\nThread-0(RUNNABLE) loop 5\nThread-0 (TIMED_WAITING) is interrupted now.\nThread-0(RUNNABLE) loop 6\nThread-0(RUNNABLE) loop 7\nThread-0(RUNNABLE) loop 8\nThread-0(RUNNABLE) loop 9\nThread-0(RUNNABLE) loop 10\nThread-0(RUNNABLE) loop 11\nThread-0(RUNNABLE) loop 12\nThread-0(RUNNABLE) loop 13\nThread-0(RUNNABLE) loop 14\n...\n```\n\n结果说明：程序进入了死循环！为什么会这样呢？这是因为t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。<br>\n\n\n解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。','<h2 id=\"interrupt介绍\">interrupt()介绍</h2>\n<p>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。关于interrupt()，jdk的文档描述如下：</p>\n<ul>\n<li><p>interrupt()的作用是中断本线程。本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。</p>\n</li>\n<li><p>如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。</p>\n</li>\n<li><p>如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。</p>\n</li>\n<li><p>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。\n中断一个“已终止的线程”不会产生任何操作。</p>\n</li>\n</ul>\n<p>通过上面的分析，我们可以总结，<strong>调用线程类的interrupt()方法，其本质只是设置该线程的中断标志，将中断标志设置为true，并根据线程状态决定是否抛出异常。</strong> 因此，通过interrupt()方法真正实现线程的中断原理是：开发人员根据中断标志的具体值，来决定如何退出线程。</p>\n<h2 id=\"终止线程的方式\">终止线程的方式</h2>\n<p>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！</p>\n<h3 id=\"终止处于阻塞状态的线程\">终止处于“阻塞状态”的线程</h3>\n<p>当线程由于被调用了sleep().wait(),join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，<strong>中断标记会被清除</strong>，同时产生一个InterruptedException异常。将InterrupedException放在适当的位置就能终止线程，形式如下：</p>\n<pre><code class=\"language-java\">@Override\npublic void run() {\n    try {\n        while (true) {\n            // 执行任务...\n        }\n    } catch (InterruptedException ie) {  \n        // 由于产生InterruptedException异常，退出while(true)循环，线程终止！\n    }\n}</code></pre>\n<p>说明：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！</p>\n<p>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：</p>\n<pre><code class=\"language-java\">@Override\npublic void run() {\n    while (true) {\n        try {\n            // 执行任务...\n        } catch (InterruptedException ie) {  \n            // InterruptedException在while(true)循环体内。\n            // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出\n            break;\n        }\n    }\n}</code></pre>\n<p>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。</p>\n<h3 id=\"终止处于运行状态的线程\">终止处于“运行状态”的线程</h3>\n<p>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。</p>\n<h4 id=\"1-通过中断标记终止线程\">(1) 通过“中断”标记终止线程</h4>\n<pre><code class=\"language-java\">@Override\npublic void run() {\n    while (!isInterrupted()) {\n        // 执行任务...\n    }\n}</code></pre>\n<p>说明：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。</p>\n<p>注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。</p>\n<h4 id=\"2-通过额外添加标记。\">(2) 通过“额外添加标记”。</h4>\n<pre><code class=\"language-java\">private volatile boolean flag= true;\nprotected void stopTask() {\n    flag = false;\n}\n\n@Override\npublic void run() {\n    while (flag) {\n        // 执行任务...\n    }\n}</code></pre>\n<p>说明：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。</p>\n<p>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。</p>\n<h3 id=\"处于阻塞状态和运行状态的终止方式\">处于“阻塞状态”和“运行状态”的终止方式</h3>\n<pre><code class=\"language-java\">@Override\npublic void run() {\n    try {\n        // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n        while (!isInterrupted()) {\n            // 执行任务...\n        }\n    } catch (InterruptedException ie) {  \n        // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n    }\n}</code></pre>\n<h2 id=\"终止线程示例\">终止线程示例</h2>\n<pre><code class=\"language-java\">public class MyThread extends Thread {\n    @Override\n    public void run() {\n        try {\n            int i = 0;\n            while (!isInterrupted()) {\n                Thread.sleep(100);\n                i++;\n                System.out.println(Thread.currentThread().getName() + &quot;(&quot; + this.getState() + &quot;) loop &quot; + i);\n            }\n        } catch (InterruptedException e) {\n            System.out.println(Thread.currentThread().getName() + &quot;(&quot; + this.getState() + &quot;) catch InterruptedException&quot;);\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            MyThread t1 = new MyThread();\n            System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is new.&quot;);\n\n            t1.start();\n            System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is started.&quot;);\n\n            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n            Thread.sleep(300);\n            t1.interrupt();\n            System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is interrupted.&quot;);\n\n            // 主线程休眠300ms，然后查看t1的状态\n            Thread.sleep(300);\n            System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is interrupted now.&quot;);\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-shell\">Thread-0 (NEW) is new.\nThread-0 (RUNNABLE) is started.\nThread-0(RUNNABLE) loop 1\nThread-0(RUNNABLE) loop 2\nThread-0 (TIMED_WAITING) is interrupted.\nThread-0(RUNNABLE) catch InterruptedException\nThread-0 (TERMINATED) is interrupted now.</code></pre>\n<p>结果说明：<br>\n(1)主线程main创建一个线程t1,并且启动t1<br>\n(2)t1启动之后，会不断检查它的中断标记，如果中断标记为false，则休眠100ms<br>\n(3) t1休眠之后，会切换到主线程，执行t1.interrupt()中断线程t1。t1收到中断指令后，会将t1的中断标记设置为false(<strong>阻塞状态标记清除为false并抛出异常</strong>),而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体之外捕获的异常；因此循环被终止。</p>\n<p>我们将程序稍稍改一下，将run()方法中捕获的InterruptedException异常代码快移到while()循环体内</p>\n<pre><code class=\"language-java\">public class MyThread extends Thread {\n    @Override\n    public void run() {\n\n        int i = 0;\n        while (!isInterrupted()) {\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                System.out.println(Thread.currentThread().getName() + &quot;(&quot; + this.getState() + &quot;) catch InterruptedException&quot;);\n            }\n            i++;\n            System.out.println(Thread.currentThread().getName() + &quot;(&quot; + this.getState() + &quot;) loop &quot; + i);\n\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            MyThread t1 = new MyThread();\n            System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is new.&quot;);\n\n            t1.start();\n            System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is started.&quot;);\n\n            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n            Thread.sleep(300);\n            t1.interrupt();\n            System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is interrupted.&quot;);\n\n            // 主线程休眠300ms，然后查看t1的状态\n            Thread.sleep(300);\n            System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is interrupted now.&quot;);\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">Thread-0 (NEW) is new.\nThread-0 (RUNNABLE) is started.\nThread-0(RUNNABLE) loop 1\nThread-0(RUNNABLE) loop 2\nThread-0 (TIMED_WAITING) is interrupted.\nThread-0(RUNNABLE) catch InterruptedException\nThread-0(RUNNABLE) loop 3\nThread-0(RUNNABLE) loop 4\nThread-0(RUNNABLE) loop 5\nThread-0 (TIMED_WAITING) is interrupted now.\nThread-0(RUNNABLE) loop 6\nThread-0(RUNNABLE) loop 7\nThread-0(RUNNABLE) loop 8\nThread-0(RUNNABLE) loop 9\nThread-0(RUNNABLE) loop 10\nThread-0(RUNNABLE) loop 11\nThread-0(RUNNABLE) loop 12\nThread-0(RUNNABLE) loop 13\nThread-0(RUNNABLE) loop 14\n...</code></pre>\n<p>结果说明：程序进入了死循环！为什么会这样呢？这是因为t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。<br></p>\n<p>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。</p>\n',26,0,2,NULL,NULL,'2019-07-27 11:03:24','2020-10-09 23:57:19',0,'32,42,57',1,0),(27,'Java多线程基础08——线程优先级和守护线程','java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。\n\njava 中有两种线程：用户线程和守护线程。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。','Bobbi','## 线程优先级介绍\njava 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。<br>\njava 中有两种线程：用户线程和守护线程。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。\n\n用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：当只有守护线程运行时，JVM会自动退出。\n\n## 优先级示例\n```java\npublic class Mythread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(Thread.currentThread().getName() + \"(\" + Thread.currentThread().getPriority() + \") loop \" + i);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Thread.currentThread().getName()\n                +\"(\"+Thread.currentThread().getPriority()+ \")\");\n        Mythread t1 = new Mythread();\n        Mythread t2 = new Mythread();\n        t1.setPriority(1);\n        t2.setPriority(10);\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n结果如下：\n```shell\nmain(5)\nThread-1(10) loop 0\nThread-0(1) loop 0\nThread-1(10) loop 1\nThread-0(1) loop 1\nThread-0(1) loop 2\nThread-0(1) loop 3\nThread-0(1) loop 4\nThread-1(10) loop 2\nThread-1(10) loop 3\nThread-1(10) loop 4\n```\n结果说明：<br>\n(1)主线程main的优先级是5<br>\n(2) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。\n\n## 守护线程的示例\n```java\nclass MyDaemon extends Thread{\n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run(){\n        try {\n            for (int i=0; i<10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() +\"(isDaemon=\"+this.isDaemon()+ \")\" +\", loop \"+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n}\npublic class Mythread extends Thread {\n    public Mythread(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            try {\n                Thread.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(this.getName() +\"(isDaemon=\"+this.isDaemon()+ \")\" +\", loop \"+i);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Thread.currentThread().getName()\n                +\"(isDaemon=\"+Thread.currentThread().isDaemon()+ \")\");\n\n        Mythread t1=new Mythread(\"t1\");    // 新建t1\n        MyDaemon t2=new MyDaemon(\"MyDaemon\");    // 新建t2\n        t2.setDaemon(true);                // 设置t2为守护线程\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }\n}\n```\n\n结果如下：\n```shell\nmain(isDaemon=false)\nMyDaemon(isDaemon=true), loop 0\nMyDaemon(isDaemon=true), loop 1\nt1(isDaemon=false), loop 0\nMyDaemon(isDaemon=true), loop 2\nMyDaemon(isDaemon=true), loop 3\nMyDaemon(isDaemon=true), loop 4\nt1(isDaemon=false), loop 1\nMyDaemon(isDaemon=true), loop 5\nMyDaemon(isDaemon=true), loop 6\nMyDaemon(isDaemon=true), loop 7\nt1(isDaemon=false), loop 2\nMyDaemon(isDaemon=true), loop 8\nMyDaemon(isDaemon=true), loop 9\nt1(isDaemon=false), loop 3\nMyDaemon(isDaemon=true), loop 10\nMyDaemon(isDaemon=true), loop 11\nMyDaemon(isDaemon=true), loop 12\nt1(isDaemon=false), loop 4\nMyDaemon(isDaemon=true), loop 13\n\n```\n结果说明：<br>\n(1) 主线程main是用户线程，它创建的子线程t1也是用户线程。<br>\n(2) myDeamon是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩myDeamon这个守护线程的时候，JVM自动退出。','<h2 id=\"线程优先级介绍\">线程优先级介绍</h2>\n<p>java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。<br>\njava 中有两种线程：用户线程和守护线程。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。</p>\n<p>用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：当只有守护线程运行时，JVM会自动退出。</p>\n<h2 id=\"优先级示例\">优先级示例</h2>\n<pre><code class=\"language-java\">public class Mythread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(Thread.currentThread().getName() + &quot;(&quot; + Thread.currentThread().getPriority() + &quot;) loop &quot; + i);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Thread.currentThread().getName()\n                +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;);\n        Mythread t1 = new Mythread();\n        Mythread t2 = new Mythread();\n        t1.setPriority(1);\n        t2.setPriority(10);\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">main(5)\nThread-1(10) loop 0\nThread-0(1) loop 0\nThread-1(10) loop 1\nThread-0(1) loop 1\nThread-0(1) loop 2\nThread-0(1) loop 3\nThread-0(1) loop 4\nThread-1(10) loop 2\nThread-1(10) loop 3\nThread-1(10) loop 4</code></pre>\n<p>结果说明：<br>\n(1)主线程main的优先级是5<br>\n(2) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。</p>\n<h2 id=\"守护线程的示例\">守护线程的示例</h2>\n<pre><code class=\"language-java\">class MyDaemon extends Thread{\n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run(){\n        try {\n            for (int i=0; i&lt;10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; +&quot;, loop &quot;+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n}\npublic class Mythread extends Thread {\n    public Mythread(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 5; i++) {\n            try {\n                Thread.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; +&quot;, loop &quot;+i);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Thread.currentThread().getName()\n                +&quot;(isDaemon=&quot;+Thread.currentThread().isDaemon()+ &quot;)&quot;);\n\n        Mythread t1=new Mythread(&quot;t1&quot;);    // 新建t1\n        MyDaemon t2=new MyDaemon(&quot;MyDaemon&quot;);    // 新建t2\n        t2.setDaemon(true);                // 设置t2为守护线程\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }\n}</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">main(isDaemon=false)\nMyDaemon(isDaemon=true), loop 0\nMyDaemon(isDaemon=true), loop 1\nt1(isDaemon=false), loop 0\nMyDaemon(isDaemon=true), loop 2\nMyDaemon(isDaemon=true), loop 3\nMyDaemon(isDaemon=true), loop 4\nt1(isDaemon=false), loop 1\nMyDaemon(isDaemon=true), loop 5\nMyDaemon(isDaemon=true), loop 6\nMyDaemon(isDaemon=true), loop 7\nt1(isDaemon=false), loop 2\nMyDaemon(isDaemon=true), loop 8\nMyDaemon(isDaemon=true), loop 9\nt1(isDaemon=false), loop 3\nMyDaemon(isDaemon=true), loop 10\nMyDaemon(isDaemon=true), loop 11\nMyDaemon(isDaemon=true), loop 12\nt1(isDaemon=false), loop 4\nMyDaemon(isDaemon=true), loop 13\n</code></pre>\n<p>结果说明：<br>\n(1) 主线程main是用户线程，它创建的子线程t1也是用户线程。<br>\n(2) myDeamon是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩myDeamon这个守护线程的时候，JVM自动退出。</p>\n',25,0,2,NULL,NULL,'2019-07-28 08:20:50','2020-10-09 23:57:28',0,'32,42,57',1,0),(28,'Java多线程基础09——生产者和消费者  ','生产/消费者问题是个非常典型的多线程问题，涉及到的对象包括“生产者”、“消费者”、“仓库”和“产品”。他们之间的关系如下','Bobbi','## 生产者消费者模型\n生产/消费者问题是个非常典型的多线程问题，涉及到的对象包括“生产者”、“消费者”、“仓库”和“产品”。他们之间的关系如下：\n1. 生产者仅仅在仓储未满时候生产，仓满则停止生产。\n2. 消费者仅仅在仓储有产品时候才能消费，仓空则等待。\n3. 当消费者发现仓储没产品可消费时候会通知生产者生产。\n4. 生产者在生产出可消费产品时候，应该通知等待的消费者去消费。\n\n## 生产者消费者实现\n```java\nclass Store {\n    private int count;\n    private final int MAX_SIZE = 5;\n\n    // 加库存\n    public synchronized void product() {\n\n        try {\n            Thread.sleep(new Random().nextInt(300));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        while (count >= MAX_SIZE) {\n            try {\n                System.out.println(\"producer wait\");\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        count++;\n        System.out.println(\"producer生产，剩余\" + count);\n        notifyAll();\n\n    }\n\n    // 减库存\n    public synchronized void consume() {\n\n        try {\n            Thread.sleep(new Random().nextInt(300));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        while (count <= 0) {\n            try {\n                System.out.println(\"consumer wait\");\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        count--;\n        System.out.println(\"consumer 消费，剩余\" + count);\n        notifyAll();\n\n    }\n\n}\n\n// 生产者\nclass Producer extends Thread {\n    private Store store;\n\n    public Producer(Store store) {\n        this.store = store;\n    }\n\n    @Override\n    public void run() {\n        // 生产者开始不断生产\n        while (true) {\n            store.product();\n            try {\n                Thread.sleep(300);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n// 消费者\nclass Consumer extends Thread {\n    private Store store;\n\n    public Consumer(Store store) {\n        this.store = store;\n    }\n\n    @Override\n    public void run() {\n        // 消费者开始不断消费\n        while (true) {\n            store.consume();\n            try {\n                Thread.sleep(300);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\npublic class ProducerAndConsumerTest {\n    public static void main(String[] args) {\n        // 创建仓库类\n        Store store = new Store();\n        // 创建5个生产者线程\n        Producer producer1 = new Producer(store);\n        Producer producer2 = new Producer(store);\n        Producer producer3 = new Producer(store);\n        Producer producer4 = new Producer(store);\n        Producer producer5 = new Producer(store);\n        // 创建3个消费者线程\n        Consumer consumer1 = new Consumer(store);\n        Consumer consumer2 = new Consumer(store);\n        Consumer consumer3 = new Consumer(store);\n        // 启动线程\n        producer1.start();\n        producer2.start();\n        producer3.start();\n        producer4.start();\n        producer5.start();\n        consumer1.start();\n        consumer2.start();\n        consumer3.start();\n    }\n}\n```\n运行结果：\n```shell\nproducer生产，剩余1\nconsumer 消费，剩余0\nconsumer wait\nconsumer wait\nproducer生产，剩余1\nproducer生产，剩余2\nproducer生产，剩余3\nproducer生产，剩余4\nproducer生产，剩余5\nproducer wait\nconsumer 消费，剩余4\nconsumer 消费，剩余3\nconsumer 消费，剩余2\nproducer生产，剩余3\n...\n```\n结果说明：<br>\n在上面的代码中，有一个仓库类Store，它的store()和consum()方法负责存入或消费商品，这两个方法都是加锁的，并且是以当前Store对象为锁。\n\n在store()方法中，首先判断了当前库存量是否大于最大库存量，如果大于就使当前线程开始等待，如果没有达到最大库存量，就开始增加库存，并且调用notifyAll()方法唤醒所有线程。\n\n在consum()方法中，首先判断了当前库存量是否小于等于0，如果满足就使当前线程开始等待，如果仓库还有库存，就开始消费商品，并且调用notifyAll()方法唤醒所有线程。\n\n生产者和消费者分别对应Producer和Consumer两个类，这两个类的实现非常简单，就是循环调用仓库的store()和consum()方法分别生成商品和消费商品。需要注意的是，在主要代码中，Producer和Consumer两个类的实例中的Store实例是同一个，也就是说生产者和消费者是针对同一个仓库进行生产和消费操作的。\n\n在主线程中，分别开启了五个生产线程和三个消费线程。\n\n当Producer生产线程在生产的产品达到最大库存量时，会停下来等待，而当Consumer消费线程在消费到仓库库存为0时也会停下来等待；而每次生产或消费的时候都会执行notifyAll()方法唤醒所有线程，这个唤醒操作会唤醒等待的生产或消费线程继续进行生产或消费。\n\n','<h2 id=\"生产者消费者模型\">生产者消费者模型</h2>\n<p>生产/消费者问题是个非常典型的多线程问题，涉及到的对象包括“生产者”、“消费者”、“仓库”和“产品”。他们之间的关系如下：</p>\n<ol>\n<li>生产者仅仅在仓储未满时候生产，仓满则停止生产。</li>\n<li>消费者仅仅在仓储有产品时候才能消费，仓空则等待。</li>\n<li>当消费者发现仓储没产品可消费时候会通知生产者生产。</li>\n<li>生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</li>\n</ol>\n<h2 id=\"生产者消费者实现\">生产者消费者实现</h2>\n<pre><code class=\"language-java\">class Store {\n    private int count;\n    private final int MAX_SIZE = 5;\n\n    // 加库存\n    public synchronized void product() {\n\n        try {\n            Thread.sleep(new Random().nextInt(300));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        while (count &gt;= MAX_SIZE) {\n            try {\n                System.out.println(&quot;producer wait&quot;);\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        count++;\n        System.out.println(&quot;producer生产，剩余&quot; + count);\n        notifyAll();\n\n    }\n\n    // 减库存\n    public synchronized void consume() {\n\n        try {\n            Thread.sleep(new Random().nextInt(300));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        while (count &lt;= 0) {\n            try {\n                System.out.println(&quot;consumer wait&quot;);\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        count--;\n        System.out.println(&quot;consumer 消费，剩余&quot; + count);\n        notifyAll();\n\n    }\n\n}\n\n// 生产者\nclass Producer extends Thread {\n    private Store store;\n\n    public Producer(Store store) {\n        this.store = store;\n    }\n\n    @Override\n    public void run() {\n        // 生产者开始不断生产\n        while (true) {\n            store.product();\n            try {\n                Thread.sleep(300);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n// 消费者\nclass Consumer extends Thread {\n    private Store store;\n\n    public Consumer(Store store) {\n        this.store = store;\n    }\n\n    @Override\n    public void run() {\n        // 消费者开始不断消费\n        while (true) {\n            store.consume();\n            try {\n                Thread.sleep(300);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\npublic class ProducerAndConsumerTest {\n    public static void main(String[] args) {\n        // 创建仓库类\n        Store store = new Store();\n        // 创建5个生产者线程\n        Producer producer1 = new Producer(store);\n        Producer producer2 = new Producer(store);\n        Producer producer3 = new Producer(store);\n        Producer producer4 = new Producer(store);\n        Producer producer5 = new Producer(store);\n        // 创建3个消费者线程\n        Consumer consumer1 = new Consumer(store);\n        Consumer consumer2 = new Consumer(store);\n        Consumer consumer3 = new Consumer(store);\n        // 启动线程\n        producer1.start();\n        producer2.start();\n        producer3.start();\n        producer4.start();\n        producer5.start();\n        consumer1.start();\n        consumer2.start();\n        consumer3.start();\n    }\n}</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-shell\">producer生产，剩余1\nconsumer 消费，剩余0\nconsumer wait\nconsumer wait\nproducer生产，剩余1\nproducer生产，剩余2\nproducer生产，剩余3\nproducer生产，剩余4\nproducer生产，剩余5\nproducer wait\nconsumer 消费，剩余4\nconsumer 消费，剩余3\nconsumer 消费，剩余2\nproducer生产，剩余3\n...</code></pre>\n<p>结果说明：<br>\n在上面的代码中，有一个仓库类Store，它的store()和consum()方法负责存入或消费商品，这两个方法都是加锁的，并且是以当前Store对象为锁。</p>\n<p>在store()方法中，首先判断了当前库存量是否大于最大库存量，如果大于就使当前线程开始等待，如果没有达到最大库存量，就开始增加库存，并且调用notifyAll()方法唤醒所有线程。</p>\n<p>在consum()方法中，首先判断了当前库存量是否小于等于0，如果满足就使当前线程开始等待，如果仓库还有库存，就开始消费商品，并且调用notifyAll()方法唤醒所有线程。</p>\n<p>生产者和消费者分别对应Producer和Consumer两个类，这两个类的实现非常简单，就是循环调用仓库的store()和consum()方法分别生成商品和消费商品。需要注意的是，在主要代码中，Producer和Consumer两个类的实例中的Store实例是同一个，也就是说生产者和消费者是针对同一个仓库进行生产和消费操作的。</p>\n<p>在主线程中，分别开启了五个生产线程和三个消费线程。</p>\n<p>当Producer生产线程在生产的产品达到最大库存量时，会停下来等待，而当Consumer消费线程在消费到仓库库存为0时也会停下来等待；而每次生产或消费的时候都会执行notifyAll()方法唤醒所有线程，这个唤醒操作会唤醒等待的生产或消费线程继续进行生产或消费。</p>\n',41,23,2,NULL,NULL,'2019-07-28 15:37:47','2020-10-09 23:57:37',0,'32,42,57',1,0),(29,'Java开发者成长路线','从零讲Java ，给你一条 清晰地学习道路！该学什么就学什么！！','nbalive2001','## 1. 计算机基础：\n### 1.1 数据结构基础：\n\n主要学习：\n1. 向量，链表，栈，队列和堆，词典。熟悉\n2. 树，二叉搜索树。熟悉\n3. 图，有向图，无向图，基本概念\n4. 二叉搜索A，B，C类熟练，9大排序熟悉。\n5. 树的前中后，层次，之字，最短路。\n6. KMP等字符串算法。\n\n### 1.2 操作系统：\n\n主要学习：\n1. 进程，线程，进程线程区别。进程间通信\n2. 进程调度算法理解\n3. 存储，虚拟内存，分页分段，内存调度算法\n4. 文件系统，链式，索引\n5. 死锁：原因，避免，解除k\n6. Linux基本操作命令，会一门脚本编程：shell，Python\n\n### 1.3 计算机网络：\n\n主要学习：\n1. 网络分层：五层，七层，四层等\n2. 网络层：IP分类，子网划分，超网。ARP协议，ICMP协议。理解内部网关和外部网关，vpn等\n3. 运输层：端口，UDP协议理解，TCP协议理解，三次握手，四次断开。\n4. 应用层：了解常用协议使用的端口和底层协议。\n5. 更加深入理解：TCP/IP 对拥塞控制，滑动窗口，如何实现可靠等。\n\n### 1.4 基础算法：\n\n主要学习：\n1. 理解大O等记号\n2. 动态规划如：几类背包问题最好有现成的代码用于笔试。最长公共子序列\n3. 贪心算法：理解赫夫曼编码（笔试常考概念）\n4. B树B+树用于理解数据库索引\n5. 常用的图算法：广度优先，深度优先，最短路径算法（最好有现成的代码），最小生成树。\n\n## 2. JAVA知识基础：\n### 2.1 JAVA基础\n\n推荐书籍：编程思想\n1. 掌握java常用技术，io、多线程、反射、常用集合框架\n2. 对处理输入输出的IO进行熟悉，用于笔试\n3. 对Iterator，Iterable和Comparable,Comparator了解，以及常用集合的遍历和排序。\n4. 对NIO一定要熟悉，以及了解JMS和RPC\n5. 对JAVA基础概念要熟悉，比如抽象类和接口区别等，这些熟记。\n\n### 2.2 JAVA源码\n\n1. hashmap，hashtable，concurrentHashMap源码以及区别\n2. 其他集合框架：linkedHashMap，LinkedHashSet，Copy-On-Write等\n3. 对Lock，Object，String等类的源码了解。\n\n### 2.3 JAVA并发API\n\n推荐书籍：应付笔试面试：JAVA多线程编程与核心技术。真正神书：JAVA并发编程实战。\n\n#### 2.3.1 Synchronize 和 Lock 的区别与用法\n\n1. wait()和await() notify()和signal()，wait()和sleep()区别与用法\n\n2. 其他的API用法：yield，join等\n\n3. voliate深入理解，以及CAS理解\n\n4. JAVA锁底层实现：自旋锁，阻塞锁，可重入锁，偏向锁，等。\n\n5. 线程池和阻塞队列\n\n6. 以及一些常用的并发实现案例如生产者和消费者\n\n### 2.4 理解JVM\n\n推荐书籍：深入理解JAVA虚拟机\n\n1. JAVA内存模型，哪个区域存放哪些内容\n\n2. 引用技术法和可达性分析法\n\n3. 对象的强、软、弱和虚引用区别与作用\n\n4. jvm垃圾回收机制，以及回收算法\n\n5. 常见的OOM和SOF的原因和解决方案，以及通过什么工具进行分析。\n\n6. 常见的JVM输入参数熟悉\n\n7. 了解GC停顿，逃逸分析，TLAB区，堆外内存等\n\n8. 常用垃圾收集器：G1，CMS等\n\n9. 了解常用性能监控工具：如visualvm jconsole等\n\n10. 必须熟悉虚拟机类加载机制，包括原理步骤，以及双亲委派方式的原理。\n\n## 3. 常规储备知识学习\n\n### 3.1 数据库：\n\n推荐书籍：sql入门：Mysql必知必会。深入理解：高性能Mysql\n\n1. 常用关联查询语法，自己所动手写几个\n\n2. 数据库索引深入认识和理解\n\n3. JDBC学习\n\n4. 常用数据库调优手段：比如通过索引调优\n\n5. InnoDB和MyISAM 区别\n\n6. 了解主键，外键，索引，唯一索引\n\n7. 了解索引、视图、触发器、游标和存储过程\n\n8. 常用关系型数据库和非关系型数据库：关系型了解：Mysql，Oracle 非关系型了解：redis，Hbase，monogodb等\n\n### 3.2 设计模式：\n\n推荐书籍：设计模式之禅\n\n1. 单例模式的几种写法一定要会\n\n2. JDK中对应的设计模式：如IO中的装饰模式和设配器模式等\n\n3. 框架中常用的设计模式：如Struts中的责任链模式，Spring中的工厂模式，动态代理模式等\n\n4. 了解6大设计原则\n\n### 3.3 HTTP协议：\n\n推荐书籍：HTTP权威指南\n\n1. 什么是HTTP，协议版本等\n\n2. 学会使用浏览器查看HTTP请求与响应\n\n3. 熟悉HTTP请求头和请求体\n\n4. 熟悉HTTP响应头和响应体\n\n5. 了解Rest风格\n\n### 3.4 神一般的Spring：\n\n推荐书籍：Spring实战和Spring技术内幕\n\n1. 了解IOC原理和作用\n\n2. 了解AOP原理和作用\n\n3. 常用的XML配置\n\n4. Spring事务原理和使用\n\n5. SpringMVC\n\n6. 了解Spring的webflow，远程服务，rest，消息，安全等\n\n7. 新功能：Spring boot和cloud\n\n## 4. 后端学习之路\n\n### 4.1 WEB后端学习之路\n\n推荐书籍：可以选择一些SSH整合开发之类的\n\n1. JSP和Servlet学习\n\n2. XML和JSON解析学习\n\n3. 前端知识：HTML、css，js，Vue，React\n\n4. JDBC学习，文件上传\\下载，JAVAMail等\n\n5. 可以利用jsp和Servlet开发简单项目\n\n6. 接着框架学习：Struts2，Hibernate，Spring以及相互整合开发\n\n7. 接着可以了解：SpringMvc，Mybatis，Lucene，shiro等\n\n8. 利用框架实现简单项目比如CMS。\n\n### 4.2 服务架构学习之路（此部分笔试面试不一定学习）\n\n推荐书籍：分布式服务框架原理与实践和微服务设计\n\n1. 了解SOA和微服务\n\n2. 负载均衡：LVS，NGINX等\n\n3. RPC框架学习：RMI，Thrift等\n\n4. 消息框架学习：ActiveMq等\n\n5. Netty通信框架学习\n\n6. 服务框架：dubbo\n\n### 4.3 Hadoop学习之路（此部分笔试面试不一定学习）\n\n推荐书籍：Hadoop权威指南\n\n1. 熟悉mapReduce和HDfS\n\n2. Hadoop集群搭建\n\n3. 了解：zk，hive，hbase，pig，mahout等\n\n4. zk几个常用作用如做注册中心，放配置信息等。\n\n\n最后，推荐一个专注于Java学习的公众号\n\n\n<center>\n\n![Coding实验室](http://oss.osalien.com/dbblog/20201012/3e27261931c042f1a4383fcd75b38026.png)\n\n<center>\n\n','<h2 id=\"1-计算机基础：\">1. 计算机基础：</h2>\n<h3 id=\"11-数据结构基础：\">1.1 数据结构基础：</h3>\n<p>主要学习：</p>\n<ol>\n<li>向量，链表，栈，队列和堆，词典。熟悉</li>\n<li>树，二叉搜索树。熟悉</li>\n<li>图，有向图，无向图，基本概念</li>\n<li>二叉搜索A，B，C类熟练，9大排序熟悉。</li>\n<li>树的前中后，层次，之字，最短路。</li>\n<li>KMP等字符串算法。</li>\n</ol>\n<h3 id=\"12-操作系统：\">1.2 操作系统：</h3>\n<p>主要学习：</p>\n<ol>\n<li>进程，线程，进程线程区别。进程间通信</li>\n<li>进程调度算法理解</li>\n<li>存储，虚拟内存，分页分段，内存调度算法</li>\n<li>文件系统，链式，索引</li>\n<li>死锁：原因，避免，解除k</li>\n<li>Linux基本操作命令，会一门脚本编程：shell，Python</li>\n</ol>\n<h3 id=\"13-计算机网络：\">1.3 计算机网络：</h3>\n<p>主要学习：</p>\n<ol>\n<li>网络分层：五层，七层，四层等</li>\n<li>网络层：IP分类，子网划分，超网。ARP协议，ICMP协议。理解内部网关和外部网关，vpn等</li>\n<li>运输层：端口，UDP协议理解，TCP协议理解，三次握手，四次断开。</li>\n<li>应用层：了解常用协议使用的端口和底层协议。</li>\n<li>更加深入理解：TCP/IP 对拥塞控制，滑动窗口，如何实现可靠等。</li>\n</ol>\n<h3 id=\"14-基础算法：\">1.4 基础算法：</h3>\n<p>主要学习：</p>\n<ol>\n<li>理解大O等记号</li>\n<li>动态规划如：几类背包问题最好有现成的代码用于笔试。最长公共子序列</li>\n<li>贪心算法：理解赫夫曼编码（笔试常考概念）</li>\n<li>B树B+树用于理解数据库索引</li>\n<li>常用的图算法：广度优先，深度优先，最短路径算法（最好有现成的代码），最小生成树。</li>\n</ol>\n<h2 id=\"2-java知识基础：\">2. JAVA知识基础：</h2>\n<h3 id=\"21-java基础\">2.1 JAVA基础</h3>\n<p>推荐书籍：编程思想</p>\n<ol>\n<li>掌握java常用技术，io、多线程、反射、常用集合框架</li>\n<li>对处理输入输出的IO进行熟悉，用于笔试</li>\n<li>对Iterator，Iterable和Comparable,Comparator了解，以及常用集合的遍历和排序。</li>\n<li>对NIO一定要熟悉，以及了解JMS和RPC</li>\n<li>对JAVA基础概念要熟悉，比如抽象类和接口区别等，这些熟记。</li>\n</ol>\n<h3 id=\"22-java源码\">2.2 JAVA源码</h3>\n<ol>\n<li>hashmap，hashtable，concurrentHashMap源码以及区别</li>\n<li>其他集合框架：linkedHashMap，LinkedHashSet，Copy-On-Write等</li>\n<li>对Lock，Object，String等类的源码了解。</li>\n</ol>\n<h3 id=\"23-java并发api\">2.3 JAVA并发API</h3>\n<p>推荐书籍：应付笔试面试：JAVA多线程编程与核心技术。真正神书：JAVA并发编程实战。</p>\n<h4 id=\"231-synchronize-和-lock-的区别与用法\">2.3.1 Synchronize 和 Lock 的区别与用法</h4>\n<ol>\n<li><p>wait()和await() notify()和signal()，wait()和sleep()区别与用法</p>\n</li>\n<li><p>其他的API用法：yield，join等</p>\n</li>\n<li><p>voliate深入理解，以及CAS理解</p>\n</li>\n<li><p>JAVA锁底层实现：自旋锁，阻塞锁，可重入锁，偏向锁，等。</p>\n</li>\n<li><p>线程池和阻塞队列</p>\n</li>\n<li><p>以及一些常用的并发实现案例如生产者和消费者</p>\n</li>\n</ol>\n<h3 id=\"24-理解jvm\">2.4 理解JVM</h3>\n<p>推荐书籍：深入理解JAVA虚拟机</p>\n<ol>\n<li><p>JAVA内存模型，哪个区域存放哪些内容</p>\n</li>\n<li><p>引用技术法和可达性分析法</p>\n</li>\n<li><p>对象的强、软、弱和虚引用区别与作用</p>\n</li>\n<li><p>jvm垃圾回收机制，以及回收算法</p>\n</li>\n<li><p>常见的OOM和SOF的原因和解决方案，以及通过什么工具进行分析。</p>\n</li>\n<li><p>常见的JVM输入参数熟悉</p>\n</li>\n<li><p>了解GC停顿，逃逸分析，TLAB区，堆外内存等</p>\n</li>\n<li><p>常用垃圾收集器：G1，CMS等</p>\n</li>\n<li><p>了解常用性能监控工具：如visualvm jconsole等</p>\n</li>\n<li><p>必须熟悉虚拟机类加载机制，包括原理步骤，以及双亲委派方式的原理。</p>\n</li>\n</ol>\n<h2 id=\"3-常规储备知识学习\">3. 常规储备知识学习</h2>\n<h3 id=\"31-数据库：\">3.1 数据库：</h3>\n<p>推荐书籍：sql入门：Mysql必知必会。深入理解：高性能Mysql</p>\n<ol>\n<li><p>常用关联查询语法，自己所动手写几个</p>\n</li>\n<li><p>数据库索引深入认识和理解</p>\n</li>\n<li><p>JDBC学习</p>\n</li>\n<li><p>常用数据库调优手段：比如通过索引调优</p>\n</li>\n<li><p>InnoDB和MyISAM 区别</p>\n</li>\n<li><p>了解主键，外键，索引，唯一索引</p>\n</li>\n<li><p>了解索引、视图、触发器、游标和存储过程</p>\n</li>\n<li><p>常用关系型数据库和非关系型数据库：关系型了解：Mysql，Oracle 非关系型了解：redis，Hbase，monogodb等</p>\n</li>\n</ol>\n<h3 id=\"32-设计模式：\">3.2 设计模式：</h3>\n<p>推荐书籍：设计模式之禅</p>\n<ol>\n<li><p>单例模式的几种写法一定要会</p>\n</li>\n<li><p>JDK中对应的设计模式：如IO中的装饰模式和设配器模式等</p>\n</li>\n<li><p>框架中常用的设计模式：如Struts中的责任链模式，Spring中的工厂模式，动态代理模式等</p>\n</li>\n<li><p>了解6大设计原则</p>\n</li>\n</ol>\n<h3 id=\"33-http协议：\">3.3 HTTP协议：</h3>\n<p>推荐书籍：HTTP权威指南</p>\n<ol>\n<li><p>什么是HTTP，协议版本等</p>\n</li>\n<li><p>学会使用浏览器查看HTTP请求与响应</p>\n</li>\n<li><p>熟悉HTTP请求头和请求体</p>\n</li>\n<li><p>熟悉HTTP响应头和响应体</p>\n</li>\n<li><p>了解Rest风格</p>\n</li>\n</ol>\n<h3 id=\"34-神一般的spring：\">3.4 神一般的Spring：</h3>\n<p>推荐书籍：Spring实战和Spring技术内幕</p>\n<ol>\n<li><p>了解IOC原理和作用</p>\n</li>\n<li><p>了解AOP原理和作用</p>\n</li>\n<li><p>常用的XML配置</p>\n</li>\n<li><p>Spring事务原理和使用</p>\n</li>\n<li><p>SpringMVC</p>\n</li>\n<li><p>了解Spring的webflow，远程服务，rest，消息，安全等</p>\n</li>\n<li><p>新功能：Spring boot和cloud</p>\n</li>\n</ol>\n<h2 id=\"4-后端学习之路\">4. 后端学习之路</h2>\n<h3 id=\"41-web后端学习之路\">4.1 WEB后端学习之路</h3>\n<p>推荐书籍：可以选择一些SSH整合开发之类的</p>\n<ol>\n<li><p>JSP和Servlet学习</p>\n</li>\n<li><p>XML和JSON解析学习</p>\n</li>\n<li><p>前端知识：HTML、css，js，Vue，React</p>\n</li>\n<li><p>JDBC学习，文件上传\\下载，JAVAMail等</p>\n</li>\n<li><p>可以利用jsp和Servlet开发简单项目</p>\n</li>\n<li><p>接着框架学习：Struts2，Hibernate，Spring以及相互整合开发</p>\n</li>\n<li><p>接着可以了解：SpringMvc，Mybatis，Lucene，shiro等</p>\n</li>\n<li><p>利用框架实现简单项目比如CMS。</p>\n</li>\n</ol>\n<h3 id=\"42-服务架构学习之路（此部分笔试面试不一定学习）\">4.2 服务架构学习之路（此部分笔试面试不一定学习）</h3>\n<p>推荐书籍：分布式服务框架原理与实践和微服务设计</p>\n<ol>\n<li><p>了解SOA和微服务</p>\n</li>\n<li><p>负载均衡：LVS，NGINX等</p>\n</li>\n<li><p>RPC框架学习：RMI，Thrift等</p>\n</li>\n<li><p>消息框架学习：ActiveMq等</p>\n</li>\n<li><p>Netty通信框架学习</p>\n</li>\n<li><p>服务框架：dubbo</p>\n</li>\n</ol>\n<h3 id=\"43-hadoop学习之路（此部分笔试面试不一定学习）\">4.3 Hadoop学习之路（此部分笔试面试不一定学习）</h3>\n<p>推荐书籍：Hadoop权威指南</p>\n<ol>\n<li><p>熟悉mapReduce和HDfS</p>\n</li>\n<li><p>Hadoop集群搭建</p>\n</li>\n<li><p>了解：zk，hive，hbase，pig，mahout等</p>\n</li>\n<li><p>zk几个常用作用如做注册中心，放配置信息等。</p>\n</li>\n</ol>\n<p>最后，推荐一个专注于Java学习的公众号</p>\n<center>\n\n<p><img src=\"http://oss.osalien.com/dbblog/20201012/3e27261931c042f1a4383fcd75b38026.png\" alt=\"Coding实验室\"></p>\n<center>\n\n',408,0,52,NULL,NULL,'2018-01-02 02:35:00','2020-10-11 19:15:29',0,'58,59',1,0),(30,'Java开发者成长路线图','Java开发者成长路线图','Coding实验室','\n\n### Java开发者成长路线图\n\n![Java开发](http://oss.osalien.com/JavaDevelop.svg)\n\n![Java学习](http://oss.osalien.com/dbblog/20201013/78f4b1ab5a4549c2abafcd1579a32a60.jpg)\n\n![Java学习路线](http://oss.osalien.com/dbblog/20201013/c2ffd400a7214f4eb2c276e25ceab168.png)\n\n\n','<h3 id=\"java开发者成长路线图\">Java开发者成长路线图</h3>\n<p><img src=\"http://oss.osalien.com/JavaDevelop.svg\" alt=\"Java开发\"></p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201013/78f4b1ab5a4549c2abafcd1579a32a60.jpg\" alt=\"Java学习\"></p>\n<p><img src=\"http://oss.osalien.com/dbblog/20201013/c2ffd400a7214f4eb2c276e25ceab168.png\" alt=\"Java学习路线\"></p>\n',2,0,0,NULL,NULL,'2019-10-12 22:42:42','2020-10-12 22:42:53',0,'58,59',1,0);
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `book`
--

DROP TABLE IF EXISTS `book`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(100) DEFAULT NULL COMMENT '标题',
  `cover` varchar(255) DEFAULT NULL COMMENT '封面',
  `author` varchar(50) DEFAULT NULL COMMENT '作者',
  `category_id` varchar(20) DEFAULT NULL COMMENT '分类类别',
  `recommend` tinyint(1) DEFAULT '0' COMMENT '是否推荐',
  `publisher` varchar(100) DEFAULT NULL COMMENT '出版社',
  `publish_date` date DEFAULT NULL COMMENT '出版日期',
  `page_num` int(11) DEFAULT NULL COMMENT '页数',
  `grade` double DEFAULT NULL COMMENT '评分',
  `description` text COMMENT '简介',
  `catalogue` text COMMENT '原书目录',
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  `read_num` int(11) DEFAULT '0' COMMENT '阅读量',
  `comment_num` int(11) DEFAULT '0' COMMENT '评论量',
  `like_num` int(11) DEFAULT '0' COMMENT '点赞量',
  `publish` tinyint(1) DEFAULT '0' COMMENT '是否发布',
  `progress` int(11) DEFAULT '0' COMMENT '读书状态',
  `reading` tinyint(1) DEFAULT NULL COMMENT '是否阅读',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='图书表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book`
--

LOCK TABLES `book` WRITE;
/*!40000 ALTER TABLE `book` DISABLE KEYS */;
INSERT INTO `book` VALUES (1,'LeetCode','http://oss.osalien.com/dbblog/20200629/4e1dd67b2f5c45ddb50fe26aab551ca6.jpg','leetcode','55,31',1,'leetcode出版社','2016-11-01',1699,5,'<p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><span style=\"color: rgb(38, 38, 38);\">﻿每一个不曾起舞的日子都是对生命的一种辜负</span></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p>','<p>1. 两数之和</p><p>2. 两数相加</p><p>3. 无重复字符的最长子串</p><p>4. 寻找两个有序数组的中位数</p><p>6. Z字形变换</p><p>7. 反转整数</p><p>8. 字符串转换整数</p><p>9. 回文数</p><p>12. 整数转罗马数字</p><p>13. 罗马数字转整数</p><p>14. 最长公共前缀</p><p>15. 三数之和</p><p>16. 最接近的三数之和</p><p>17. 电话号码的字母组合</p><p>18. 四数之和</p><p>19. 删除链表的倒数第N个节点</p><p>20. 有效的括号</p><p><br></p><p>waiting...</p>','2019-06-29 00:23:17','2020-09-30 08:56:20',25,0,0,1,10,1),(2,'Java核心技术·卷 I（原书第10版）','http://oss.osalien.com/dbblog/20200930/8d3ff46326fb4e59ae2b916af98b45af.jpg','凯 S.霍斯特曼 (Cay S. Horstmann)','52,39',1,'机械工业出版社出版','2016-09-01',711,4,'<p>Java领域最有影响力和价值的著作之一，由拥有20多年教学与研究经验的资深Java技术专家撰写(获Jolt大奖)，与《Java编程思想》齐名，10余年全球畅销不衰，广受好评。第10版根据Java SE 8全面更新，同时修正了第9版中的不足，系统全面讲解了Java语言的核 心概念、语法、重要特性和开发方法，包含大量案例，实践性强。</p><p>一直以来，《Java核心技术》都被认为是面向高级程序员的经典教程和参考书，它内容翔实、客观准确，不拖泥带水，是想为实际应用编写健壮Java代码的程序员的首选。如今，本版进行了全面更新， 以反映近年来人们翘首以待、变革最大的Java版本（Java SE 8）的内容。这一版经过重写，并重新组织，全面阐释了新的Java SE 8特性、惯用法和*佳实践，其中包含数百个示例程序，所有这些代码都经过精心设计，不仅易于理解，也很容易实际应用。</p><p>本书为专业程序员解决实际问题而写，可以帮助你深入了解Java语言和库。在卷I中，Horstmann主要强调基本语言概念和现代用户界面编程基础，深入介绍了从Java面向对象编程到泛型、集合、lambda表达式、Swing UI设计以及并发和函数式编程的*新方法等内容。</p>','<p><span style=\"color: rgb(17, 17, 17);\">译者序</span></p><p><span style=\"color: rgb(17, 17, 17);\">前言</span></p><p><span style=\"color: rgb(17, 17, 17);\">致谢</span></p><p><span style=\"color: rgb(17, 17, 17);\">第1章　Java程序设计概述 1</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.1　Java程序设计平台 1</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2　Java“白皮书”的关键术语 2</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.1　简单性 2</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.2　面向对象 2</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.3　分布式 3</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.4　健壮性 3</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.5　安全性 3</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.6　体系结构中立 4</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.7　可移植性 4</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.8　解释型 5</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.9　高性能 5</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.10　多线程 5</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.2.11　动态性 5</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.3　Java applet与Internet 6</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.4　Java发展简史 7</span></p><p><span style=\"color: rgb(17, 17, 17);\">1.5　关于Java的常见误解 9</span></p><p><span style=\"color: rgb(17, 17, 17);\">第2章　Java程序设计环境 12</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.1　安装Java开发工具包 12</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.1.1　下载JDK 12</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.1.2　设置JDK 13</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.1.3　安装库源文件和文档 15</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.2　使用命令行工具 16</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.3　使用集成开发环境 18</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.4　运行图形化应用程序 21</span></p><p><span style=\"color: rgb(17, 17, 17);\">2.5　构建并运行applet 23</span></p><p><span style=\"color: rgb(17, 17, 17);\">第3章　Java的基本程序设计结构 28</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.1　一个简单的Java应用程序 28</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.2　注释 31</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3　数据类型 32</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3.1　整型 32</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3.2　浮点类型 33</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3.3　char类型 34</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3.4　Unicode和char类型 35</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.3.5　boolean类型 35</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.4　变量 36</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.4.1　变量初始化 37</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.4.2　常量 37</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5　运算符 38</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.1　数学函数与常量 39</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.2　数值类型之间的转换 40</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.3　强制类型转换 41</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.4　结合赋值和运算符 42</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.5　自增与自减运算符 42</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.6　关系和boolean运算符 42</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.7　位运算符 43</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.8　括号与运算符级别 44</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.5.9　枚举类型 45</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6　字符串 45</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.1　子串 45</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.2　拼接 46</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.3　不可变字符串 46</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.4　检测字符串是否相等 47</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.5　空串与Null串 48</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.6　码点与代码单元 49</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.7　String API 50</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.8　阅读联机API文档 52</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.6.9　构建字符串 54</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.7　输入输出 55</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.7.1　读取输入 55</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.7.2　格式化输出 58</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.7.3　文件输入与输出 61</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8　控制流程 63</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.1　块作用域 63</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.2　条件语句 63</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.3　循环 66</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.4　确定循环 69</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.5　多重选择：switch语句 72</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.8.6　中断控制流程语句 74</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.9　大数值 76</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10　数组 78</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.1　for each循环 79</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.2　数组初始化以及匿名数组 80</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.3　数组拷贝 81</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.4　命令行参数 81</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.5　数组排序 82</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.6　多维数组 85</span></p><p><span style=\"color: rgb(17, 17, 17);\">3.10.7　不规则数组 88</span></p><p><span style=\"color: rgb(17, 17, 17);\">第4章　对象与类 91</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.1　面向对象程序设计概述 91</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.1.1　类 92</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.1.2　对象 93</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.1.3　识别类 93</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.1.4　类之间的关系 94</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.2　使用预定义类 95</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.2.1　对象与对象变量 95</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.2.2　Java类库中的LocalDate类 98</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.2.3　更改器方法与访问器方法 100</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3　用户自定义类 103</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.1　Employee类 103</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.2　多个源文件的使用 105</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.3　剖析Employee类 106</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.4　从构造器开始 106</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.5　隐式参数与显式参数 108</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.6　封装的优点 109</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.7　基于类的访问权限 111</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.8　私有方法 111</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.3.9　final实例域 112</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4　静态域与静态方法 112</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4.1　静态域 112</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4.2　静态常量 113</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4.3　静态方法 114</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4.4　工厂方法 115</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.4.5　main方法 115</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.5　方法参数 118</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6　对象构造 123</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.1　重载 123</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.2　默认域初始化 123</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.3　无参数的构造器 124</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.4　显式域初始化 125</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.5　参数名 125</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.6　调用另一个构造器 126</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.7　初始化块 127</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.6.8　对象析构与finalize方法 130</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.7　包 131</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.7.1　类的导入 131</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.7.2　静态导入 133</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.7.3　将类放入包中 133</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.7.4　包作用域 136</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.8　类路径 137</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.8.1　设置类路径 139</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9　文档注释 140</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.1　注释的插入 140</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.2　类注释 140</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.3　方法注释 141</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.4　域注释 142</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.5　通用注释 142</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.6　包与概述注释 143</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.9.7　注释的抽取 143</span></p><p><span style=\"color: rgb(17, 17, 17);\">4.10　类设计技巧 144</span></p><p><span style=\"color: rgb(17, 17, 17);\">第5章　继承 147</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1　类、超类和子类 147</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.1　定义子类 147</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.2　覆盖方法 149</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.3　子类构造器 150</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.4　继承层次 153</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.5　多态 154</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.6　理解方法调用 155</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.7　阻止继承：final类和方法 157</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.8　强制类型转换 158</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.9　抽象类 160</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.1.10　受保护访问 165</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.2　Object：所有类的超类 166</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.2.1　equals方法 166</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.2.2　相等测试与继承 167</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.2.3　hashCode方法 170</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.2.4　toString方法 172</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.3　泛型数组列表 178</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.3.1　访问数组列表元素 180</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.3.2　类型化与原始数组列表的兼容性 183</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.4　对象包装器与自动装箱 184</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.5　参数数量可变的方法 187</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.6　枚举类 188</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7　反射 190</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.1　Class类 190</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.2　捕获异常 192</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.3　利用反射分析类的能力 194</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.4　在运行时使用反射分析对象 198</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.5　使用反射编写泛型数组代码 202</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.7.6　调用任意方法 205</span></p><p><span style=\"color: rgb(17, 17, 17);\">5.8　继承的设计技巧 208</span></p><p><span style=\"color: rgb(17, 17, 17);\">第6章　接口、lambda表达式与内部类 211</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1　接口 211</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.1　接口概念 211</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.2　接口的特性 217</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.3　接口与抽象类 218</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.4　静态方法 218</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.5　默认方法 219</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.1.6　解决默认方法冲突 220</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.2　接口示例 222</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.2.1　接口与回调 222</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.2.2　Comparator接口 224</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.2.3　对象克隆 225</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3　lambda表达式 231</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.1　为什么引入lambda表达式 231</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.2　lambda表达式的语法 232</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.3　函数式接口 234</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.4　方法引用 235</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.5　构造器引用 237</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.6　变量作用域 237</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.7　处理lambda表达式 239</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.3.8　再谈Comparator 242</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4　内部类 242</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.1　使用内部类访问对象状态 244</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.2　内部类的特殊语法规则 247</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.3　内部类是否有用、必要和安全 248</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.4　局部内部类 250</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.5　由外部方法访问变量 250</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.6　匿名内部类 252</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.4.7　静态内部类 255</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.5　代理 258</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.5.1　何时使用代理 259</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.5.2　创建代理对象 259</span></p><p><span style=\"color: rgb(17, 17, 17);\">6.5.3　代理类的特性 262</span></p><p><span style=\"color: rgb(17, 17, 17);\">第7章　异常、断言和日志 264</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.1　处理错误 264</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.1.1　异常分类 265</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.1.2　声明受查异常 267</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.1.3　如何抛出异常 269</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.1.4　创建异常类 270</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2　捕获异常 271</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.1　捕获异常 271</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.2　捕获多个异常 273</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.3　再次抛出异常与异常链 274</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.4　finally子句 275</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.5　带资源的try语句 278</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.2.6　分析堆栈轨迹元素 280</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.3　使用异常机制的技巧 282</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.4　使用断言 285</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.4.1　断言的概念 285</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.4.2　启用和禁用断言 286</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.4.3　使用断言完成参数检查 287</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.4.4　为文档假设使用断言 288</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5　记录日志 289</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.1　基本日志 289</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.2　高级日志 289</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.3　修改日志管理器配置 291</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.4　本地化 292</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.5　处理器 293</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.6　过滤器 296</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.7　格式化器 296</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.5.8　日志记录说明 296</span></p><p><span style=\"color: rgb(17, 17, 17);\">7.6　调试技巧 304</span></p><p><span style=\"color: rgb(17, 17, 17);\">第8章　泛型程序设计 309</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.1　为什么要使用泛型程序设计 309</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.1.1　类型参数的好处 309</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.1.2　谁想成为泛型程序员 310</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.2　定义简单泛型类 311</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.3　泛型方法 313</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.4　类型变量的限定 314</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.5　泛型代码和虚拟机 316</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.5.1　类型擦除 316</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.5.2　翻译泛型表达式 317</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.5.3　翻译泛型方法 318</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.5.4　调用遗留代码 319</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6　约束与局限性 320</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.1　不能用基本类型实例化类型参数 320</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.2　运行时类型查询只适用于原始类型 321</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.3　不能创建参数化类型的数组 321</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.4　Varargs警告 322</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.5　不能实例化类型变量 323</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.6　不能构造泛型数组 323</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.7　泛型类的静态上下文中类型变量无效 325</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.8　不能抛出或捕获泛型类的实例 325</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.9　可以消除对受查异常的检查 326</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.6.10　注意擦除后的冲突 327</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.7　泛型类型的继承规则 328</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.8　通配符类型 330</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.8.1　通配符概念 330</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.8.2　通配符的超类型限定 331</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.8.3　无限定通配符 334</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.8.4　通配符捕获 334</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.9　反射和泛型 337</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.9.1　泛型Class类 337</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.9.2　使用Class参数进行类型匹配 338</span></p><p><span style=\"color: rgb(17, 17, 17);\">8.9.3　虚拟机中的泛型类型信息 338</span></p><p><span style=\"color: rgb(17, 17, 17);\">第9章　集合 344</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1　Java集合框架 344</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1.1　将集合的接口与实现分离 344</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1.2　Collection接口 346</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1.3　迭代器 347</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1.4　泛型实用方法 349</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.1.5　集合框架中的接口 352</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2　具体的集合 353</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.1　链表 355</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.2　数组列表 362</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.3　散列集 363</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.4　树集 366</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.5　队列与双端队列 369</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.2.6　优先级队列 371</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3　映射 372</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.1　基本映射操作 372</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.2　更新映射项 375</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.3　映射视图 376</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.4　弱散列映射 377</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.5　链接散列集与映射 378</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.6　枚举集与映射 379</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.3.7　标识散列映射 380</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4　视图与包装器 381</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.1　轻量级集合包装器 382</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.2　子范围 382</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.3　不可修改的视图 383</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.4　同步视图 384</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.5　受查视图 384</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.4.6　关于可选操作的说明 385</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5　算法 388</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.1　排序与混排 389</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.2　二分查找 391</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.3　简单算法 392</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.4　批操作 394</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.5　集合与数组的转换 394</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.5.6　编写自己的算法 395</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6　遗留的集合 396</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6.1　Hashtable类 397</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6.2　枚举 397</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6.3　属性映射 398</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6.4　栈 399</span></p><p><span style=\"color: rgb(17, 17, 17);\">9.6.5　位集 399</span></p><p><span style=\"color: rgb(17, 17, 17);\">第10章　图形程序设计 403</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.1　Swing概述 403</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.2　创建框架 407</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.3　框架定位 409</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.3.1　框架属性 411</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.3.2　确定合适的框架大小 411</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.4　在组件中显示信息 415</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.5　处理2D图形 419</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.6　使用颜色 426</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.7　文本使用特殊字体 429</span></p><p><span style=\"color: rgb(17, 17, 17);\">10.8　显示图像 435</span></p><p><span style=\"color: rgb(17, 17, 17);\">第11章　事件处理 439</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.1　事件处理基础 439</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.1.1　实例：处理按钮点击事件 441</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.1.2　简洁地指定监听器 445</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.1.3　实例：改变观感 447</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.1.4　适配器类 450</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.2　动作 453</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.3　鼠标事件 459</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.4　AWT事件继承层次 465</span></p><p><span style=\"color: rgb(17, 17, 17);\">11.4.1　语义事件和底层事件 466</span></p><p><span style=\"color: rgb(17, 17, 17);\">第12章　Swing用户界面组件 469</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.1　Swing和模型–视图–控制器设计模式 469</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.1.1　设计模式 469</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.1.2　模型–视图–控制器模式 470</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.1.3　Swing按钮的模型–视图–控制器分析 473</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.2　布局管理概述 474</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.2.1　边框布局 477</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.2.2　网格布局 478</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3　文本输入 481</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3.1　文本域 482</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3.2　标签和标签组件 483</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3.3　密码域 484</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3.4　文本区 485</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.3.5　滚动窗格 485</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4　选择组件 488</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4.1　复选框 488</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4.2　单选钮 490</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4.3　边框 493</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4.4　组合框 496</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.4.5　滑动条 499</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5　菜单 504</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.1　菜单创建 504</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.2　菜单项中的图标 507</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.3　复选框和单选钮菜单项 508</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.4　弹出菜单 508</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.5　快捷键和加速器 510</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.6　启用和禁用菜单项 511</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.7　工具栏 515</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.5.8　工具提示 516</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6　复杂的布局管理 518</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6.1　网格组布局 520</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6.2　组布局 528</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6.3　不使用布局管理器 537</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6.4　定制布局管理器 537</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.6.5　遍历顺序 541</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7　对话框 541</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7.1　选项对话框 542</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7.2　创建对话框 551</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7.3　数据交换 554</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7.4　文件对话框 559</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.7.5　颜色选择器 569</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.8　GUI程序排错 573</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.8.1　调试技巧 573</span></p><p><span style=\"color: rgb(17, 17, 17);\">12.8.2　让AWT机器人完成工作 576</span></p><p><span style=\"color: rgb(17, 17, 17);\">第13章　部署Java应用程序 580</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1　JAR文件 580</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1.1　创建JAR文件 580</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1.2　清单文件 581</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1.3　可执行JAR文件 582</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1.4　资源 583</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.1.5　密封 585</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.2　应用首选项的存储 586</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.2.1　属性映射 586</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.2.2　首选项API 591</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.3　服务加载器 596</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4　applet 598</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.1　一个简单的applet 599</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.2　applet HTML标记和属性 602</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.3　使用参数向applet传递信息 603</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.4　访问图像和音频文件 608</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.5　applet上下文 609</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.6　applet间通信 609</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.7　在浏览器中显示信息项 610</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.8　沙箱 611</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.4.9　签名代码 612</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.5　Java Web Start 614</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.5.1　发布Java Web Start应用 614</span></p><p><span style=\"color: rgb(17, 17, 17);\">13.5.2　JNLP API 617</span></p><p><span style=\"color: rgb(17, 17, 17);\">第14章　并发 624</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.1　什么是线程 624</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.1.1　使用线程给其他任务提供机会 629</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.2　中断线程 632</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.3　线程状态 635</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.3.1　新创建线程 635</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.3.2　可运行线程 635</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.3.3　被阻塞线程和等待线程 636</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.3.4　被终止的线程 636</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.4　线程属性 638</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.4.1　线程优先级 638</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.4.2　守护线程 639</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.4.3　未捕获异常处理器 639</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5　同步 640</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.1　竞争条件的一个例子 641</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.2　竞争条件详解 644</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.3　锁对象 646</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.4　条件对象 648</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.5　synchronized关键字 653</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.6　同步阻塞 656</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.7　监视器概念 657</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.8　Volatile域 658</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.9　final变量 659</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.10　原子性 659</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.11　死锁 661</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.12　线程局部变量 663</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.13　锁测试与超时 665</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.14　读/写锁 666</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.5.15　为什么弃用stop和suspend方法 667</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.6　阻塞队列 668</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7　线程安全的集合 673</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.1　高效的映射、集和队列 674</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.2　映射条目的原子更新 675</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.3　对并发散列映射的批操作 676</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.4　并发集视图 678</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.5　写数组的拷贝 679</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.6　并行数组算法 679</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.7.7　较早的线程安全集合 680</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.8　Callable与Future 681</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9　执行器 685</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9.1　线程池 685</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9.2　预定执行 689</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9.3　控制任务组 690</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9.4　Fork-Join框架 691</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.9.5　可完成Future 694</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10　同步器 696</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10.1　信号量 696</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10.2　倒计时门栓 697</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10.3　障栅 697</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10.4　交换器 698</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.10.5　同步队列 698</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.11　线程与Swing 698</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.11.1　运行耗时的任务 699</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.11.2　使用Swing工作线程 703</span></p><p><span style=\"color: rgb(17, 17, 17);\">14.11.3　单一线程规则 708</span></p><p><span style=\"color: rgb(17, 17, 17);\">附录A　Java关键字 710</span></p>','2020-09-29 18:08:54','2020-09-30 08:55:30',9,0,0,1,0,NULL);
/*!40000 ALTER TABLE `book` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `book_note`
--

DROP TABLE IF EXISTS `book_note`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book_note` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(50) NOT NULL COMMENT '笔记标题',
  `description` varchar(255) DEFAULT NULL COMMENT '笔记描述',
  `author` varchar(50) DEFAULT NULL COMMENT '笔记作者',
  `content` longtext COMMENT '笔记内容',
  `content_format` longtext COMMENT 'html的context',
  `read_num` int(11) DEFAULT '0' COMMENT '阅读量',
  `comment_num` int(11) DEFAULT '0' COMMENT '评论量',
  `like_num` int(11) DEFAULT '0' COMMENT '点赞量',
  `cover` text COMMENT '封面',
  `book_id` int(11) DEFAULT NULL COMMENT '所属书本',
  `chapter` varchar(255) DEFAULT NULL COMMENT '所属章节',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  `recommend` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否推荐笔记',
  `category_id` varchar(50) DEFAULT NULL COMMENT '分类类别存在多级分类，用逗号隔开',
  `publish` tinyint(4) DEFAULT '0' COMMENT '发布状态',
  `cover_type` int(11) DEFAULT NULL COMMENT '封面类型',
  `top` tinyint(1) DEFAULT NULL COMMENT '是否置顶',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='笔记';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book_note`
--

LOCK TABLES `book_note` WRITE;
/*!40000 ALTER TABLE `book_note` DISABLE KEYS */;
INSERT INTO `book_note` VALUES (1,'删除排序数组中的重复项','给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。','Coding实验室','给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n \n\n#### 示例 1\n\n```text\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n#### 示例 2\n\n```text\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n#### 说明\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n```text\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n  \n  \n\n#### 解答\n\n```text\n   /**\n     * 官方题解：双指针法\n     *\n     * 数组完成排序后，我们可以放置两个指针i 和j，其中i 是慢指针，而j 是快指针。\n     *只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。\n     * 当我们遇到 nums[j] != nums[i]，跳过重复项的运行已经结束\n     *因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程\n     *直到 j 到达数组的末尾为止。\n     *\n     * 复杂度分析\n     * 时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。\n     * 空间复杂度：O(1)\n    **/\n    public static int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        int i = 0;\n        for (int j = 1; j < nums.length; j++) {\n            if (nums[j] != nums[i]) {\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i + 1;\n    }\n```','<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n<h4 id=\"示例-1\">示例 1</h4>\n<pre><code class=\"language-text\">给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。</code></pre>\n<h4 id=\"示例-2\">示例 2</h4>\n<pre><code class=\"language-text\">给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。</code></pre>\n<h4 id=\"说明\">说明</h4>\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\n<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n<p>你可以想象内部操作如下:</p>\n<pre><code class=\"language-text\">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i &lt; len; i++) {\n    print(nums[i]);\n}</code></pre>\n<h4 id=\"解答\">解答</h4>\n<pre><code class=\"language-text\">   /**\n     * 官方题解：双指针法\n     *\n     * 数组完成排序后，我们可以放置两个指针i 和j，其中i 是慢指针，而j 是快指针。\n     *只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。\n     * 当我们遇到 nums[j] != nums[i]，跳过重复项的运行已经结束\n     *因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程\n     *直到 j 到达数组的末尾为止。\n     *\n     * 复杂度分析\n     * 时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。\n     * 空间复杂度：O(1)\n    **/\n    public static int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        int i = 0;\n        for (int j = 1; j &lt; nums.length; j++) {\n            if (nums[j] != nums[i]) {\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i + 1;\n    }</code></pre>\n',29,0,0,NULL,1,'数组','2019-06-29 00:32:35','2020-09-30 00:57:20',0,'55,31',1,NULL,0),(2,'买卖股票的最佳时机 II','给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。','Coding实验室','给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n### 示例 1\n```text\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n```\n### 示例 2\n```text\n输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n```\n### 示例 3\n```text\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n ```\n\n**提示：**\n```text\n1 <= prices.length <= 3 * 10 ^ 4\n0 <= prices[i] <= 10 ^ 4\n```\n\n### 解题思路\n&nbsp;&nbsp;&nbsp;&nbsp;可以采用<font color=\'red\'>贪心策略</font>来解决：首先我们需要理解一点，第i天买入，第j天卖出得到的收益和第i天买入，第i+p天卖出，第i+p天再买入，第j天卖出得到的收益是相同的。比如[1,2,3,4,5]，很明显我们知道最大收益是4，可以看作是第一天买入，第五天卖出，但是也可以看作是第1天买入，第二天卖出，同时买入，第三天又卖出，同时买入······\n\n&nbsp;&nbsp;&nbsp;&nbsp;理解了这一点，我们就清楚这里为什么能用贪心的思想了，从第一天开始买入，只要有收益就可以直接卖出，接下来再买入，同样一旦有收益就可以卖出，这是一种典型的贪心思想，<font color=\'red\'>局部最优达到全局最优</font>。\n\n### 解题\n```text\nclass Solution {\n    public int maxProfit(int[] prices) {\n        //贪心法\n        if(prices==null || prices.length==0)\n            return 0;\n        int profit=0;\n        for(int i=1;i<prices.length;i++){\n            if(prices[i]>prices[i-1])\n                profit+=(prices[i]-prices[i-1]);\n        }\n        return profit;\n    }\n}\n```','<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<h3 id=\"示例-1\">示例 1</h3>\n<pre><code class=\"language-text\">输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</code></pre>\n<h3 id=\"示例-2\">示例 2</h3>\n<pre><code class=\"language-text\">输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre>\n<h3 id=\"示例-3\">示例 3</h3>\n<pre><code class=\"language-text\">输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre>\n<p><strong>提示：</strong></p>\n<pre><code class=\"language-text\">1 &lt;= prices.length &lt;= 3 * 10 ^ 4\n0 &lt;= prices[i] &lt;= 10 ^ 4</code></pre>\n<h3 id=\"解题思路\">解题思路</h3>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;可以采用<font color=\'red\'>贪心策略</font>来解决：首先我们需要理解一点，第i天买入，第j天卖出得到的收益和第i天买入，第i+p天卖出，第i+p天再买入，第j天卖出得到的收益是相同的。比如[1,2,3,4,5]，很明显我们知道最大收益是4，可以看作是第一天买入，第五天卖出，但是也可以看作是第1天买入，第二天卖出，同时买入，第三天又卖出，同时买入······</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;理解了这一点，我们就清楚这里为什么能用贪心的思想了，从第一天开始买入，只要有收益就可以直接卖出，接下来再买入，同样一旦有收益就可以卖出，这是一种典型的贪心思想，<font color=\'red\'>局部最优达到全局最优</font>。</p>\n<h3 id=\"解题\">解题</h3>\n<pre><code class=\"language-text\">class Solution {\n    public int maxProfit(int[] prices) {\n        //贪心法\n        if(prices==null || prices.length==0)\n            return 0;\n        int profit=0;\n        for(int i=1;i&lt;prices.length;i++){\n            if(prices[i]&gt;prices[i-1])\n                profit+=(prices[i]-prices[i-1]);\n        }\n        return profit;\n    }\n}</code></pre>\n',15,0,0,NULL,1,'数组','2019-06-30 18:25:12','2020-09-30 00:57:13',0,'55,31',1,NULL,0);
/*!40000 ALTER TABLE `book_note` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `book_sense`
--

DROP TABLE IF EXISTS `book_sense`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book_sense` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `author` varchar(20) DEFAULT NULL COMMENT '作者',
  `content` text COMMENT '内容',
  `book_id` int(11) DEFAULT NULL COMMENT '关联图书Id',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='读后感';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book_sense`
--

LOCK TABLES `book_sense` WRITE;
/*!40000 ALTER TABLE `book_sense` DISABLE KEYS */;
/*!40000 ALTER TABLE `book_sense` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `category`
--

DROP TABLE IF EXISTS `category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(255) DEFAULT NULL COMMENT '名称',
  `type` int(11) DEFAULT NULL COMMENT '类型：0文章，1阅读',
  `rank` int(11) DEFAULT NULL COMMENT '级别',
  `parent_id` int(11) DEFAULT '0' COMMENT '父主键',
  PRIMARY KEY (`id`),
  UNIQUE KEY `operation_category_id_uindex` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=61 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `category`
--

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;
INSERT INTO `category` VALUES (1,'本站相关',0,0,-1),(2,'前端技术',0,0,-1),(17,'关系型数据库',0,1,45),(19,'mysql',0,2,17),(21,'非关系型数据库',0,1,45),(31,'LeetCode',1,1,55),(32,'后端技术',0,0,-1),(34,'Java基础',0,1,32),(37,'高并发',0,1,46),(39,'Java基础',1,1,52),(42,'Java进阶',0,1,32),(43,'工具',0,1,32),(44,'框架',0,1,32),(45,'数据库',0,0,-1),(46,'架构设计',0,0,-1),(47,'数据结构与算法',0,0,-1),(48,'Spring',0,2,44),(49,'SpringBoot',0,2,44),(50,'验证码',0,2,43),(51,'前端技术',1,0,-1),(52,'后端技术',1,0,-1),(53,'数据库',1,0,-1),(54,'架构设计',1,0,-1),(55,'数据结构与算法',1,0,-1),(56,'Java集合',0,2,34),(57,'多线程基础',0,2,42),(58,'开发者成长路线',0,0,-1),(59,'Java',0,1,58),(60,'IoT',0,1,58);
/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `link`
--

DROP TABLE IF EXISTS `link`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `link` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(50) DEFAULT NULL COMMENT '链接名称',
  `url` varchar(500) DEFAULT NULL COMMENT '链接地址',
  `avatar` varchar(255) DEFAULT NULL COMMENT '头像',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COMMENT='友链';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `link`
--

LOCK TABLES `link` WRITE;
/*!40000 ALTER TABLE `link` DISABLE KEYS */;
INSERT INTO `link` VALUES (1,'个人站点','https://site.osalien.com','http://oss.osalien.com/dbblog/20200515/ed94c174a32f47b6b01b3a85b150da63.png'),(2,'每日分享','https://news.osalien.com','http://oss.osalien.com/dbblog/20200515/db33dd399ee74175a8bd2ef2b5e620ee.png'),(3,'Java工程师成神之路','https://hollischuang.github.io/toBeTopJavaer','http://oss.osalien.com/dbblog/20200515/d55bd0c8a0d24ea098dcb6da308c40b6.png'),(4,'Spring源码阅读','https://github.com/seaswalker/spring-analysis','http://oss.osalien.com/dbblog/20200515/0b809a4d668b4761bd60df9aa78d049d.png'),(5,'On Java 8','https://lingcoder.github.io/OnJava8','http://oss.osalien.com/dbblog/20200701/01990d1d80864b9390f1da1675197f48.jpg'),(6,'云点网','https://www.yundr.net','http://oss.osalien.com/dbblog/20200810/75e68b3e566f45ed9c82af610641b6a4.png');
/*!40000 ALTER TABLE `link` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `log_like`
--

DROP TABLE IF EXISTS `log_like`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `log_like` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `type` varchar(50) DEFAULT NULL COMMENT '点赞类型',
  `params` varchar(5000) DEFAULT NULL COMMENT '请求参数',
  `time` bigint(20) NOT NULL COMMENT '执行时长(毫秒)',
  `ip` varchar(64) DEFAULT NULL COMMENT 'IP地址',
  `create_date` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 COMMENT='点赞日志';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `log_like`
--

LOCK TABLES `log_like` WRITE;
/*!40000 ALTER TABLE `log_like` DISABLE KEYS */;
INSERT INTO `log_like` VALUES (1,'article','6',0,'172.17.0.1','2020-05-15 07:42:04'),(2,'article','6',0,'172.17.0.1','2020-05-15 07:49:17'),(3,'article','1',0,'172.17.0.1','2020-05-15 08:07:21'),(4,'article','1',0,'172.17.0.1','2020-05-15 08:07:22'),(5,'article','1',0,'172.17.0.1','2020-05-15 08:07:27'),(6,'article','1',0,'172.17.0.1','2020-05-15 08:07:27'),(7,'article','1',0,'172.17.0.1','2020-05-15 08:07:28'),(8,'article','1',0,'172.17.0.1','2020-05-15 08:07:28'),(9,'article','1',0,'172.17.0.1','2020-05-15 08:07:28'),(10,'article','9',0,'172.17.0.1','2020-09-27 09:05:02'),(11,'article','10',0,'172.17.0.1','2020-09-28 06:45:55');
/*!40000 ALTER TABLE `log_like` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `log_view`
--

DROP TABLE IF EXISTS `log_view`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `log_view` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `type` varchar(50) DEFAULT NULL COMMENT '浏览类型',
  `method` varchar(200) DEFAULT NULL COMMENT '请求方法',
  `params` varchar(5000) DEFAULT NULL COMMENT '请求参数',
  `time` bigint(20) NOT NULL COMMENT '执行时长(毫秒)',
  `ip` varchar(64) DEFAULT NULL COMMENT 'IP地址',
  `create_date` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=406 DEFAULT CHARSET=utf8 COMMENT='阅读日志';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `log_view`
--

LOCK TABLES `log_view` WRITE;
/*!40000 ALTER TABLE `log_view` DISABLE KEYS */;
INSERT INTO `log_view` VALUES (1,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',38,'172.17.0.1','2020-05-12 12:51:29'),(2,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',15,'172.17.0.1','2020-05-12 12:56:59'),(3,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','3',16,'172.17.0.1','2020-05-12 12:57:04'),(4,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',13,'172.17.0.1','2020-05-12 13:00:41'),(5,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',17,'172.17.0.1','2020-05-12 13:06:35'),(6,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',11,'172.17.0.1','2020-05-12 13:07:41'),(7,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',165,'172.17.0.1','2020-05-14 06:24:29'),(8,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',229,'172.17.0.1','2020-05-14 06:25:23'),(9,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',45,'172.17.0.1','2020-05-14 06:26:53'),(10,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',25,'172.17.0.1','2020-05-14 06:26:57'),(11,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',17,'172.17.0.1','2020-05-14 06:27:05'),(12,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',17,'172.17.0.1','2020-05-14 06:28:23'),(13,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',16,'172.17.0.1','2020-05-14 06:37:19'),(14,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',21,'172.17.0.1','2020-05-14 06:37:35'),(15,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',11,'172.17.0.1','2020-05-14 06:38:22'),(16,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',10,'172.17.0.1','2020-05-14 06:38:27'),(17,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',44,'172.17.0.1','2020-05-14 07:54:14'),(18,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',29,'172.17.0.1','2020-05-15 07:41:50'),(19,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',31,'172.17.0.1','2020-05-15 07:43:22'),(20,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',32,'172.17.0.1','2020-05-15 07:43:40'),(21,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',19,'172.17.0.1','2020-05-15 07:44:21'),(22,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',15,'172.17.0.1','2020-05-15 07:45:23'),(23,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',18,'172.17.0.1','2020-05-15 07:45:28'),(24,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',29,'172.17.0.1','2020-05-15 07:45:38'),(25,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',18,'172.17.0.1','2020-05-15 07:46:12'),(26,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-05-15 07:46:31'),(27,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',13,'172.17.0.1','2020-05-15 07:47:07'),(28,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',26,'172.17.0.1','2020-05-15 07:47:41'),(29,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',27,'172.17.0.1','2020-05-15 07:48:25'),(30,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',251,'172.17.0.1','2020-05-15 07:48:51'),(31,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',508,'172.17.0.1','2020-05-15 07:51:47'),(32,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',21,'172.17.0.1','2020-05-15 07:57:40'),(33,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',9,'172.17.0.1','2020-05-15 07:59:54'),(34,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',23,'172.17.0.1','2020-05-15 08:07:20'),(35,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-15 10:17:27'),(36,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',715,'172.17.0.1','2020-05-15 10:18:17'),(37,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-15 10:18:52'),(38,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-15 10:19:26'),(39,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-15 10:19:39'),(40,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',255,'172.17.0.1','2020-05-15 10:42:20'),(41,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',27,'172.17.0.1','2020-05-15 10:44:38'),(42,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',11,'172.17.0.1','2020-05-15 11:07:01'),(43,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',5,'172.17.0.1','2020-05-15 11:58:47'),(44,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',10,'172.17.0.1','2020-05-15 11:59:39'),(45,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',10,'172.17.0.1','2020-05-15 11:59:55'),(46,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',25,'172.17.0.1','2020-05-15 12:00:19'),(47,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',247,'172.17.0.1','2020-05-15 13:03:49'),(48,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',446,'172.17.0.1','2020-05-15 13:03:49'),(49,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-15 13:50:28'),(50,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',9,'172.17.0.1','2020-05-15 14:16:49'),(51,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',18,'172.17.0.1','2020-05-15 14:18:22'),(52,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',24,'172.17.0.1','2020-05-15 14:23:06'),(53,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',112,'172.17.0.1','2020-05-16 15:22:10'),(54,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',10,'172.17.0.1','2020-05-16 15:24:35'),(55,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',95,'172.17.0.1','2020-05-16 23:01:56'),(56,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',58,'172.17.0.1','2020-05-17 01:27:59'),(57,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',9,'172.17.0.1','2020-05-17 01:28:00'),(58,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-05-17 01:29:50'),(59,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',14,'172.17.0.1','2020-05-17 01:29:51'),(60,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',270,'172.17.0.1','2020-05-17 07:52:21'),(61,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',12,'172.17.0.1','2020-05-17 08:01:37'),(62,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',9,'172.17.0.1','2020-05-17 08:02:42'),(63,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',13,'172.17.0.1','2020-05-17 08:09:01'),(64,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-05-17 08:12:12'),(65,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-05-17 08:15:46'),(66,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',10,'172.17.0.1','2020-05-17 08:19:51'),(67,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',10,'172.17.0.1','2020-05-17 08:20:39'),(68,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',37,'172.17.0.1','2020-05-17 10:25:50'),(69,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',10,'172.17.0.1','2020-05-17 10:25:51'),(70,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',7,'172.17.0.1','2020-05-17 10:25:53'),(71,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',7,'172.17.0.1','2020-05-17 10:27:06'),(72,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',13,'172.17.0.1','2020-05-17 10:27:15'),(73,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',86,'172.17.0.1','2020-05-18 08:51:22'),(74,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',34,'172.17.0.1','2020-05-18 08:52:42'),(75,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',13,'172.17.0.1','2020-05-18 08:53:33'),(76,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',8,'172.17.0.1','2020-05-18 08:54:15'),(77,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',246,'172.17.0.1','2020-05-18 08:54:52'),(78,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',11,'172.17.0.1','2020-05-18 08:54:59'),(79,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',449,'172.17.0.1','2020-05-18 08:59:39'),(80,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',6,'172.17.0.1','2020-05-18 09:00:05'),(81,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',7,'172.17.0.1','2020-05-18 09:01:06'),(82,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',12,'172.17.0.1','2020-05-18 09:06:07'),(83,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',66,'172.17.0.1','2020-05-19 07:42:10'),(84,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',254,'172.17.0.1','2020-05-19 07:42:39'),(85,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',94,'172.17.0.1','2020-05-19 09:01:31'),(86,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',13,'172.17.0.1','2020-05-19 09:01:53'),(87,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',33,'172.17.0.1','2020-05-19 09:02:21'),(88,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',9,'172.17.0.1','2020-05-19 09:02:29'),(89,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',118,'172.17.0.1','2020-05-19 10:58:53'),(90,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',82,'172.17.0.1','2020-05-20 06:05:37'),(91,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2241,'172.17.0.1','2020-05-20 07:51:07'),(92,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',5347,'172.17.0.1','2020-05-20 07:51:34'),(93,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2896,'172.17.0.1','2020-05-20 07:51:51'),(94,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1379,'172.17.0.1','2020-05-20 08:02:11'),(95,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',14,'172.17.0.1','2020-05-20 08:03:33'),(96,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',660,'172.17.0.1','2020-05-20 08:03:55'),(97,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',956,'172.17.0.1','2020-05-20 08:04:30'),(98,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',941,'172.17.0.1','2020-05-20 08:04:58'),(99,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1071,'172.17.0.1','2020-05-20 08:19:36'),(100,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',997,'172.17.0.1','2020-05-20 08:19:57'),(101,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',918,'172.17.0.1','2020-05-20 08:21:01'),(102,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',958,'172.17.0.1','2020-05-20 08:27:46'),(103,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',917,'172.17.0.1','2020-05-20 08:30:40'),(104,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2291,'172.17.0.1','2020-05-20 08:32:00'),(105,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',950,'172.17.0.1','2020-05-20 08:32:26'),(106,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',682,'172.17.0.1','2020-05-20 08:32:47'),(107,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',949,'172.17.0.1','2020-05-20 08:55:10'),(108,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',922,'172.17.0.1','2020-05-20 08:59:26'),(109,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',11,'172.17.0.1','2020-05-20 08:59:48'),(110,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',9,'172.17.0.1','2020-05-20 08:59:55'),(111,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',927,'172.17.0.1','2020-05-20 09:00:17'),(112,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',11,'172.17.0.1','2020-05-20 09:02:32'),(113,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 09:03:53'),(114,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',17,'172.17.0.1','2020-05-20 09:05:32'),(115,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2725,'172.17.0.1','2020-05-20 09:15:46'),(116,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',80,'172.17.0.1','2020-05-20 09:15:56'),(117,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',3540,'172.17.0.1','2020-05-20 09:16:12'),(118,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',9,'172.17.0.1','2020-05-20 09:16:23'),(119,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',5,'172.17.0.1','2020-05-20 09:17:07'),(120,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',4874,'172.17.0.1','2020-05-20 09:17:32'),(121,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',924,'172.17.0.1','2020-05-20 09:20:04'),(122,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',981,'172.17.0.1','2020-05-20 09:23:24'),(123,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',916,'172.17.0.1','2020-05-20 09:23:53'),(124,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',3067,'172.17.0.1','2020-05-20 09:24:11'),(125,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',11,'172.17.0.1','2020-05-20 09:24:21'),(126,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',919,'172.17.0.1','2020-05-20 09:26:52'),(127,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',978,'172.17.0.1','2020-05-20 09:27:00'),(128,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1594,'172.17.0.1','2020-05-20 09:27:03'),(129,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',234,'172.17.0.1','2020-05-20 09:27:03'),(130,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',937,'172.17.0.1','2020-05-20 09:27:06'),(131,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',703,'172.17.0.1','2020-05-20 09:27:53'),(132,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',966,'172.17.0.1','2020-05-20 09:29:24'),(133,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1031,'172.17.0.1','2020-05-20 09:41:16'),(134,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',904,'172.17.0.1','2020-05-20 09:41:28'),(135,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',742,'172.17.0.1','2020-05-20 09:43:24'),(136,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',75,'172.17.0.1','2020-05-20 13:12:08'),(137,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',20,'172.17.0.1','2020-05-20 13:12:23'),(138,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 13:13:12'),(139,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',20,'172.17.0.1','2020-05-20 13:13:17'),(140,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',11,'172.17.0.1','2020-05-20 13:16:48'),(141,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',5,'172.17.0.1','2020-05-20 13:17:37'),(142,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 13:18:07'),(143,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-05-20 13:18:14'),(144,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 13:23:35'),(145,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 13:45:29'),(146,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',11,'172.17.0.1','2020-05-20 13:45:41'),(147,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',16,'172.17.0.1','2020-05-20 13:47:45'),(148,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',7,'172.17.0.1','2020-05-20 13:53:19'),(149,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',7,'172.17.0.1','2020-05-20 13:53:27'),(150,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 14:14:17'),(151,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',5,'172.17.0.1','2020-05-20 14:16:29'),(152,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',5,'172.17.0.1','2020-05-20 14:16:50'),(153,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-05-20 14:42:01'),(154,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',8,'172.17.0.1','2020-05-20 14:50:45'),(155,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',41,'172.17.0.1','2020-05-27 13:39:40'),(156,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',1450,'172.17.0.1','2020-06-08 09:25:47'),(157,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',271,'172.17.0.1','2020-06-08 23:12:35'),(158,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',1688,'172.17.0.1','2020-06-21 12:17:48'),(159,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',483,'172.17.0.1','2020-06-21 15:19:24'),(160,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',2106,'172.17.0.1','2020-06-21 21:40:34'),(161,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',403,'172.17.0.1','2020-06-22 00:51:20'),(162,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2214,'172.17.0.1','2020-06-27 03:19:11'),(163,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',362,'172.17.0.1','2020-06-27 03:20:02'),(164,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',34,'172.17.0.1','2020-06-27 03:20:10'),(165,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',1511,'172.17.0.1','2020-06-28 01:40:43'),(166,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',393,'172.17.0.1','2020-06-28 01:42:31'),(167,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',3215,'172.17.0.1','2020-06-28 01:42:51'),(168,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1174,'172.17.0.1','2020-06-28 01:42:59'),(169,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1227,'172.17.0.1','2020-06-28 02:05:08'),(170,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2388,'172.17.0.1','2020-06-28 10:11:51'),(171,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1251,'172.17.0.1','2020-06-28 10:13:02'),(172,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',17,'172.17.0.1','2020-06-28 10:17:30'),(173,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1032,'172.17.0.1','2020-06-28 10:37:43'),(174,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',17,'172.17.0.1','2020-06-29 08:33:36'),(175,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-06-29 08:33:49'),(176,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-06-29 08:35:11'),(177,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-06-29 08:36:39'),(178,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-06-29 08:37:13'),(179,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',11,'172.17.0.1','2020-06-29 08:38:32'),(180,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',5,'172.17.0.1','2020-06-29 08:39:14'),(181,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',16,'172.17.0.1','2020-06-29 08:52:09'),(182,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',3,'172.17.0.1','2020-06-29 08:52:15'),(183,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',61,'172.17.0.1','2020-06-29 08:52:17'),(184,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',25,'172.17.0.1','2020-06-29 08:57:17'),(185,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',19,'172.17.0.1','2020-06-29 08:57:30'),(186,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',14,'172.17.0.1','2020-06-29 08:58:14'),(187,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',26,'172.17.0.1','2020-06-29 08:59:35'),(188,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',3,'172.17.0.1','2020-06-29 09:00:54'),(189,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',3,'172.17.0.1','2020-06-29 09:01:14'),(190,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',43,'172.17.0.1','2020-06-29 09:01:31'),(191,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',928,'172.17.0.1','2020-06-29 09:01:36'),(192,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',12,'172.17.0.1','2020-06-29 09:01:43'),(193,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',10,'172.17.0.1','2020-06-29 09:24:03'),(194,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',8,'172.17.0.1','2020-06-29 09:53:11'),(195,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',3,'172.17.0.1','2020-07-01 02:27:05'),(196,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',8,'172.17.0.1','2020-07-01 02:27:46'),(197,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',8,'172.17.0.1','2020-07-01 02:29:05'),(198,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',2,'172.17.0.1','2020-07-01 02:29:08'),(199,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',2,'172.17.0.1','2020-07-01 02:29:48'),(200,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',2,'172.17.0.1','2020-07-01 02:30:44'),(201,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',5,'172.17.0.1','2020-07-01 02:34:57'),(202,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',206,'172.17.0.1','2020-07-01 05:59:49'),(203,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',5,'172.17.0.1','2020-07-01 05:59:51'),(204,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',86,'172.17.0.1','2020-07-01 09:56:24'),(205,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',95,'172.17.0.1','2020-07-01 10:16:20'),(206,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',718,'172.17.0.1','2020-07-01 22:11:09'),(207,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',1630,'172.17.0.1','2020-07-05 23:14:00'),(208,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',65,'172.17.0.1','2020-07-08 09:48:21'),(209,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',481,'172.17.0.1','2020-07-08 19:52:44'),(210,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',928,'172.17.0.1','2020-07-09 15:37:01'),(211,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',155,'172.17.0.1','2020-07-10 20:44:09'),(212,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',287,'172.17.0.1','2020-07-11 14:14:19'),(213,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',326,'172.17.0.1','2020-07-12 00:28:22'),(214,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1987,'172.17.0.1','2020-07-12 14:57:48'),(215,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',778,'172.17.0.1','2020-07-14 05:37:26'),(216,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',1636,'172.17.0.1','2020-07-14 12:59:49'),(217,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',184,'172.17.0.1','2020-07-14 14:29:04'),(218,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',1875,'172.17.0.1','2020-07-16 00:59:37'),(219,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',1708,'172.17.0.1','2020-07-17 09:14:53'),(220,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',240,'172.17.0.1','2020-07-28 12:17:49'),(221,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',306,'172.17.0.1','2020-07-28 15:09:11'),(222,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',202,'172.17.0.1','2020-07-28 16:28:38'),(223,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2665,'172.17.0.1','2020-07-28 20:33:42'),(224,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',966,'172.17.0.1','2020-07-28 20:33:48'),(225,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',353,'172.17.0.1','2020-07-29 04:44:24'),(226,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',169,'172.17.0.1','2020-07-29 05:58:05'),(227,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',1061,'172.17.0.1','2020-07-29 10:52:49'),(228,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',308,'172.17.0.1','2020-07-29 13:10:03'),(229,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',14,'172.17.0.1','2020-07-29 13:30:22'),(230,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',223,'172.17.0.1','2020-07-29 23:22:58'),(231,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1821,'172.17.0.1','2020-07-31 15:51:22'),(232,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',2074,'172.17.0.1','2020-08-01 18:26:09'),(233,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',11,'172.17.0.1','2020-08-06 06:30:57'),(234,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',3,'172.17.0.1','2020-08-06 06:31:15'),(235,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',100,'172.17.0.1','2020-08-06 06:31:24'),(236,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',36,'172.17.0.1','2020-08-06 06:35:50'),(237,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1210,'172.17.0.1','2020-08-07 06:38:35'),(238,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',16,'172.17.0.1','2020-08-07 06:39:12'),(239,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',13,'172.17.0.1','2020-08-07 06:43:34'),(240,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',27,'172.17.0.1','2020-08-07 06:43:59'),(241,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',17,'172.17.0.1','2020-08-07 06:44:32'),(242,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',20,'172.17.0.1','2020-08-07 06:49:20'),(243,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',20,'172.17.0.1','2020-08-07 06:57:01'),(244,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',259,'172.17.0.1','2020-08-10 09:13:28'),(245,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',19,'172.17.0.1','2020-08-10 09:39:15'),(246,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',12,'172.17.0.1','2020-08-10 09:39:47'),(247,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',22,'172.17.0.1','2020-08-10 09:45:06'),(248,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',1328,'172.17.0.1','2020-08-10 10:34:49'),(249,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',88,'172.17.0.1','2020-08-13 03:09:50'),(250,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',21,'172.17.0.1','2020-08-13 03:10:05'),(251,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',52,'172.17.0.1','2020-08-13 03:10:23'),(252,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',199,'172.17.0.1','2020-08-13 14:54:09'),(253,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',21,'172.17.0.1','2020-08-14 09:33:44'),(254,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',23,'172.17.0.1','2020-08-14 09:34:39'),(255,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',735,'172.17.0.1','2020-08-14 09:36:38'),(256,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',18,'172.17.0.1','2020-08-14 09:36:48'),(257,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',14,'172.17.0.1','2020-08-14 09:38:34'),(258,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',36,'172.17.0.1','2020-08-14 09:42:56'),(259,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','6',30,'172.17.0.1','2020-08-14 09:47:16'),(260,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',991,'172.17.0.1','2020-08-14 09:47:34'),(261,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',521,'172.17.0.1','2020-08-20 15:23:37'),(262,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',200,'172.17.0.1','2020-08-29 15:13:27'),(263,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',181,'172.17.0.1','2020-08-30 12:47:50'),(264,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',380,'172.17.0.1','2020-09-04 14:45:57'),(265,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',45,'172.17.0.1','2020-09-05 02:49:35'),(266,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',99,'172.17.0.1','2020-09-05 10:09:18'),(267,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',140,'172.17.0.1','2020-09-05 11:01:21'),(268,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',91,'172.17.0.1','2020-09-05 21:45:44'),(269,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',63,'172.17.0.1','2020-09-08 06:11:11'),(270,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',24,'172.17.0.1','2020-09-08 15:43:57'),(271,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',185,'172.17.0.1','2020-09-09 01:27:58'),(272,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',264,'172.17.0.1','2020-09-09 03:26:26'),(273,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',38,'172.17.0.1','2020-09-09 03:26:27'),(274,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',809,'172.17.0.1','2020-09-09 03:33:17'),(275,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',1113,'172.17.0.1','2020-09-09 03:33:21'),(276,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',8,'172.17.0.1','2020-09-09 03:36:22'),(277,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',34,'172.17.0.1','2020-09-09 03:36:27'),(278,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',31,'172.17.0.1','2020-09-09 03:39:41'),(279,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',107,'172.17.0.1','2020-09-27 07:16:05'),(280,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',743,'172.17.0.1','2020-09-27 07:16:34'),(281,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',665,'172.17.0.1','2020-09-27 07:16:40'),(282,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',713,'172.17.0.1','2020-09-27 07:16:58'),(283,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',46,'172.17.0.1','2020-09-27 07:38:22'),(284,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',35,'172.17.0.1','2020-09-27 07:41:42'),(285,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',21,'172.17.0.1','2020-09-27 07:48:54'),(286,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',31,'172.17.0.1','2020-09-27 07:51:42'),(287,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',14,'172.17.0.1','2020-09-27 09:05:00'),(288,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',18,'172.17.0.1','2020-09-27 09:05:13'),(289,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',12,'172.17.0.1','2020-09-27 09:05:17'),(290,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',148,'172.17.0.1','2020-09-27 09:05:20'),(291,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',23,'172.17.0.1','2020-09-27 09:06:01'),(292,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',30,'172.17.0.1','2020-09-27 10:34:48'),(293,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',32,'172.17.0.1','2020-09-28 06:45:52'),(294,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',11,'172.17.0.1','2020-09-28 06:47:09'),(295,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',13,'172.17.0.1','2020-09-28 07:29:33'),(296,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',25,'172.17.0.1','2020-09-28 07:29:41'),(297,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',12,'172.17.0.1','2020-09-28 07:49:05'),(298,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',58,'172.17.0.1','2020-09-28 09:06:34'),(299,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','8',693,'172.17.0.1','2020-09-28 09:06:45'),(300,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',88,'172.17.0.1','2020-09-28 09:06:57'),(301,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',45,'172.17.0.1','2020-09-29 03:18:00'),(302,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',169,'172.17.0.1','2020-09-29 03:18:28'),(303,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',7,'172.17.0.1','2020-09-29 03:20:47'),(304,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',8,'172.17.0.1','2020-09-29 03:31:21'),(305,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',7,'172.17.0.1','2020-09-29 03:34:13'),(306,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',10,'172.17.0.1','2020-09-29 03:34:18'),(307,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',6,'172.17.0.1','2020-09-29 03:34:45'),(308,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',18,'172.17.0.1','2020-09-29 03:35:01'),(309,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',11,'172.17.0.1','2020-09-29 03:36:56'),(310,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',11,'172.17.0.1','2020-09-29 03:37:43'),(311,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',12,'172.17.0.1','2020-09-29 03:39:22'),(312,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',19,'172.17.0.1','2020-09-29 03:43:21'),(313,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',8,'172.17.0.1','2020-09-29 03:50:15'),(314,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',5,'172.17.0.1','2020-09-29 04:02:46'),(315,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',6,'172.17.0.1','2020-09-29 04:15:11'),(316,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',119,'172.17.0.1','2020-09-29 04:15:39'),(317,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',7,'172.17.0.1','2020-09-29 04:17:17'),(318,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',8,'172.17.0.1','2020-09-29 04:18:37'),(319,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',9,'172.17.0.1','2020-09-29 07:14:02'),(320,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',15,'172.17.0.1','2020-09-29 07:36:42'),(321,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',17,'172.17.0.1','2020-09-29 07:37:00'),(322,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',55,'172.17.0.1','2020-09-29 09:16:20'),(323,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',10,'172.17.0.1','2020-09-29 09:50:01'),(324,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',12,'172.17.0.1','2020-09-29 09:50:07'),(325,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',96,'172.17.0.1','2020-09-30 02:16:10'),(326,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',29,'172.17.0.1','2020-09-30 02:16:13'),(327,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',73,'172.17.0.1','2020-09-30 02:16:51'),(328,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',20,'172.17.0.1','2020-09-30 06:29:26'),(329,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',6,'172.17.0.1','2020-09-30 06:32:03'),(330,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',11,'172.17.0.1','2020-09-30 06:45:53'),(331,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','7',17,'172.17.0.1','2020-09-30 06:48:12'),(332,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',7,'172.17.0.1','2020-09-30 08:18:15'),(333,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',21,'172.17.0.1','2020-09-30 08:45:49'),(334,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',7,'172.17.0.1','2020-09-30 08:49:52'),(335,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',11,'172.17.0.1','2020-09-30 09:00:36'),(336,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',46,'172.17.0.1','2020-09-30 09:05:55'),(337,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-09-30 15:05:43'),(338,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',39,'172.17.0.1','2020-10-01 01:30:23'),(339,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',52,'172.17.0.1','2020-10-01 21:44:39'),(340,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',305,'172.17.0.1','2020-10-01 21:44:40'),(341,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',2917,'172.17.0.1','2020-10-01 21:44:44'),(342,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','10',1345,'172.17.0.1','2020-10-01 21:44:46'),(343,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',120,'172.17.0.1','2020-10-01 23:35:54'),(344,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','2',221,'172.17.0.1','2020-10-02 10:38:25'),(345,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',164,'172.17.0.1','2020-10-02 16:14:14'),(346,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',96,'172.17.0.1','2020-10-09 05:35:46'),(347,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',2429,'172.17.0.1','2020-10-09 05:36:11'),(348,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',1751,'172.17.0.1','2020-10-09 05:37:05'),(349,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','9',17,'172.17.0.1','2020-10-09 05:52:58'),(350,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',192,'172.17.0.1','2020-10-09 05:53:28'),(351,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',35,'172.17.0.1','2020-10-09 05:55:28'),(352,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',69,'172.17.0.1','2020-10-09 05:56:11'),(353,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',495,'172.17.0.1','2020-10-09 05:57:32'),(354,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',34,'172.17.0.1','2020-10-09 05:58:25'),(355,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',40,'172.17.0.1','2020-10-09 05:59:20'),(356,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','14',7,'172.17.0.1','2020-10-10 08:03:59'),(357,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','20',8,'172.17.0.1','2020-10-10 08:11:13'),(358,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','21',9,'172.17.0.1','2020-10-10 08:11:35'),(359,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',162,'172.17.0.1','2020-10-10 09:41:29'),(360,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','18',9,'172.17.0.1','2020-10-10 10:06:52'),(361,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','15',36,'172.17.0.1','2020-10-10 10:06:55'),(362,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','19',16,'172.17.0.1','2020-10-10 10:07:03'),(363,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',4,'172.17.0.1','2020-10-10 10:50:21'),(364,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',248,'172.17.0.1','2020-10-11 12:45:25'),(365,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',422,'172.17.0.1','2020-10-11 13:35:37'),(366,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',32,'172.17.0.1','2020-10-11 23:07:54'),(367,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',8,'172.17.0.1','2020-10-11 23:38:08'),(368,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',104,'172.17.0.1','2020-10-12 02:58:11'),(369,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','29',47,'172.17.0.1','2020-10-12 02:58:46'),(370,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','29',29,'172.17.0.1','2020-10-12 03:11:45'),(371,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','29',955,'172.17.0.1','2020-10-12 03:12:33'),(372,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','29',325,'172.17.0.1','2020-10-12 03:15:32'),(373,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','29',40,'172.17.0.1','2020-10-12 05:00:24'),(374,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',50,'172.17.0.1','2020-10-12 05:29:55'),(375,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',15,'172.17.0.1','2020-10-12 06:09:28'),(376,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',27,'172.17.0.1','2020-10-12 06:11:30'),(377,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',270,'172.17.0.1','2020-10-12 06:11:34'),(378,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',227,'172.17.0.1','2020-10-12 06:11:40'),(379,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',21,'172.17.0.1','2020-10-12 06:12:05'),(380,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',14,'172.17.0.1','2020-10-12 06:26:18'),(381,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','28',83,'172.17.0.1','2020-10-12 08:41:05'),(382,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',15,'172.17.0.1','2020-10-12 21:16:14'),(383,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',7,'172.17.0.1','2020-10-12 21:28:23'),(384,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',116,'172.17.0.1','2020-10-12 22:47:24'),(385,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',129,'172.17.0.1','2020-10-13 04:28:32'),(386,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','30',6,'172.17.0.1','2020-10-13 06:43:27'),(387,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','30',8,'172.17.0.1','2020-10-13 06:45:43'),(388,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','29',16,'172.17.0.1','2020-10-13 23:01:15'),(389,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','12',2174,'172.17.0.1','2020-10-13 23:01:17'),(390,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','19',48,'172.17.0.1','2020-10-13 23:04:33'),(391,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','26',24,'172.17.0.1','2020-10-13 23:04:34'),(392,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','18',31,'172.17.0.1','2020-10-13 23:04:34'),(393,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','28',610,'172.17.0.1','2020-10-13 23:04:35'),(394,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','24',252,'172.17.0.1','2020-10-13 23:04:36'),(395,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','15',1996,'172.17.0.1','2020-10-13 23:04:36'),(396,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','27',892,'172.17.0.1','2020-10-13 23:04:36'),(397,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','17',1586,'172.17.0.1','2020-10-13 23:04:37'),(398,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','18',3069,'172.17.0.1','2020-10-13 23:04:38'),(399,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','25',91,'172.17.0.1','2020-10-13 23:05:04'),(400,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','11',158,'172.17.0.1','2020-10-15 19:55:53'),(401,'article','cn.dblearn.blog.portal.article.controller.ArticleController.getArticle()','1',6,'172.17.0.1','2020-10-18 02:19:54'),(402,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','1',154,'172.17.0.1','2020-10-19 17:09:50'),(403,'book','cn.dblearn.blog.portal.book.controller.BookController.getBook()','2',141,'172.17.0.1','2020-10-19 21:25:52'),(404,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',240,'172.17.0.1','2020-10-20 11:45:48'),(405,'bookNote','cn.dblearn.blog.portal.book.controller.BookNoteController.getBookNote()','1',82,'172.17.0.1','2020-10-21 08:23:56');
/*!40000 ALTER TABLE `log_view` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `oss_resource`
--

DROP TABLE IF EXISTS `oss_resource`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `oss_resource` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(255) DEFAULT NULL COMMENT '名称',
  `url` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=153 DEFAULT CHARSET=utf8 COMMENT='云存储资源表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `oss_resource`
--

LOCK TABLES `oss_resource` WRITE;
/*!40000 ALTER TABLE `oss_resource` DISABLE KEYS */;
INSERT INTO `oss_resource` VALUES (1,'bike_03.jpg','http://oss.osalien.com/dbblog/20200512/0587dad599224030a9779ac5b90f509d.jpg'),(2,'Mine.jpg','http://oss.osalien.com/dbblog/20200515/3b4a103561854dccb40eccf97b37673d.jpg'),(3,'微信图片_20200429220243.jpg','http://oss.osalien.com/dbblog/20200515/ae3b2b4518c747e198066e481fde27f2.jpg'),(4,'java.png','http://oss.osalien.com/dbblog/20200515/4e940ad498e24a87b11ee341620b5351.png'),(5,'Java (1).png','http://oss.osalien.com/dbblog/20200515/d55bd0c8a0d24ea098dcb6da308c40b6.png'),(6,'Site layout.png','http://oss.osalien.com/dbblog/20200515/ed94c174a32f47b6b01b3a85b150da63.png'),(7,'新闻.png','http://oss.osalien.com/dbblog/20200515/db33dd399ee74175a8bd2ef2b5e620ee.png'),(8,'SPRINGCLOUD.png','http://oss.osalien.com/dbblog/20200515/d511cbd6385e407d9d1047c36a38d590.png'),(9,'SpringBean连接.png','http://oss.osalien.com/dbblog/20200515/d24900bc28b84269bbc3f841d1d67e16.png'),(10,'SPRINGCLOUD.png','http://oss.osalien.com/dbblog/20200515/046761e7492646cd8c6bd8529fdc2ac5.png'),(11,'SpringBean连接.png','http://oss.osalien.com/dbblog/20200515/0b809a4d668b4761bd60df9aa78d049d.png'),(12,'image.png','http://oss.osalien.com/dbblog/20200515/f7c810ad1b274bb996c32f91184a86d5.png'),(13,'image.png','http://oss.osalien.com/dbblog/20200515/e0c082e148cd42e092deef117ac25719.png'),(14,'image.png','http://oss.osalien.com/dbblog/20200518/a55c974deb1b463c945c6a43205d055a.png'),(15,'image.png','http://oss.osalien.com/dbblog/20200518/7da093a7d1b541e8aec90f5da63f6b8f.png'),(16,'image.png','http://oss.osalien.com/dbblog/20200518/ef398346fe4349fa8b60cd8ca28c26c0.png'),(17,'image.png','http://oss.osalien.com/dbblog/20200518/76da426c28094d8aaa0b7401c4b5ac0e.png'),(18,'image.png','http://oss.osalien.com/dbblog/20200520/967eae0f814441f6ae52d3b8d1e6116d.png'),(19,'image.png','http://oss.osalien.com/dbblog/20200520/2de3ac3554d84c9eabff1d50eed3e5c8.png'),(20,'image.png','http://oss.osalien.com/dbblog/20200520/cbfc0b05edac444098b395de90f5e463.png'),(21,'leetcode1.jpg','http://oss.osalien.com/dbblog/20200629/4ad72089f23740d89b6a992c796d2ec1.jpg'),(22,'leetcode2.jpg','http://oss.osalien.com/dbblog/20200629/ec00fe6c4fe946c8bb3fb80d6452add1.jpg'),(23,'Leetcode.png','http://oss.osalien.com/dbblog/20200629/4060019fe40541a18405e18a09b06e43.png'),(24,'leetcode3.jpg','http://oss.osalien.com/dbblog/20200629/ca6dd0aa94394c3bb303fa25d791fe32.jpg'),(25,'leetcode3.jpg','http://oss.osalien.com/dbblog/20200629/4e1dd67b2f5c45ddb50fe26aab551ca6.jpg'),(26,'cover_small.jpg','http://oss.osalien.com/dbblog/20200701/4dc8fde7b8d9493985824f3911861e15.jpg'),(27,'cover_small.jpg','http://oss.osalien.com/dbblog/20200701/01990d1d80864b9390f1da1675197f48.jpg'),(28,'云点网.png','http://oss.osalien.com/dbblog/20200810/75e68b3e566f45ed9c82af610641b6a4.png'),(29,'image.png','http://oss.osalien.com/dbblog/20200927/51088a60dacc4833957527fac2844112.png'),(30,'image.png','http://oss.osalien.com/dbblog/20200927/4d3063f95d3146e69fb055529eb7fc51.png'),(31,'image.png','http://oss.osalien.com/dbblog/20200927/64260df48d8e479aa622e6abec438226.png'),(32,'image.png','http://oss.osalien.com/dbblog/20200927/40053d2583464b7dacc3c01d9efea4cc.png'),(33,'image.png','http://oss.osalien.com/dbblog/20200927/50a17df0f7fc46b7b09ff51d5e450c35.png'),(34,'image.png','http://oss.osalien.com/dbblog/20200927/00191170740a4c9ab97d74fefa5752f0.png'),(35,'image.png','http://oss.osalien.com/dbblog/20200927/502ca37449a34d7cb8b9c56bde8f44f0.png'),(36,'image.png','http://oss.osalien.com/dbblog/20200927/4b4fdc089d314bfdb22d765987cc7d1d.png'),(37,'image.png','http://oss.osalien.com/dbblog/20200927/aa7143128acd4f0d89ce8243e3c5244f.png'),(38,'image.png','http://oss.osalien.com/dbblog/20200927/d65364523ffe4627bc21060288426fe3.png'),(39,'image.png','http://oss.osalien.com/dbblog/20200927/afb65634d6e14d58806b064849276d5f.png'),(40,'image.png','http://oss.osalien.com/dbblog/20200927/b64d2d4bf4bc41589777bb2f87512701.png'),(41,'image.png','http://oss.osalien.com/dbblog/20200927/2a1a637457e442c38276a70ec299bb3d.png'),(42,'image.png','http://oss.osalien.com/dbblog/20200927/5e7516d8d1f242fab10893c3366cf7ae.png'),(43,'image.png','http://oss.osalien.com/dbblog/20200927/7eb344242dac44149e49d3940413a8c7.png'),(44,'image.png','http://oss.osalien.com/dbblog/20200927/493832f84a6c42d697dc99ad950ce40f.png'),(45,'image.png','http://oss.osalien.com/dbblog/20200927/c77ba53413d14c53bf743c9dc778ab25.png'),(46,'image.png','http://oss.osalien.com/dbblog/20200927/cd2ff0ab0f4040abbbeecda1346ce5b3.png'),(47,'image.png','http://oss.osalien.com/dbblog/20200927/0850ccbbaed74e378cb26dbd55c4f6cf.png'),(48,'image.png','http://oss.osalien.com/dbblog/20200927/23c7e2cca8e5434bba9018de4b52d862.png'),(49,'image.png','http://oss.osalien.com/dbblog/20200927/a8c14c3d89e34704be5f3b297b3349ec.png'),(50,'image.png','http://oss.osalien.com/dbblog/20200927/d03469988e6d415cb4cc0bb6e03c6e6f.png'),(51,'image.png','http://oss.osalien.com/dbblog/20200927/33a6a32a894048339e08dd3d58aaca16.png'),(52,'image.png','http://oss.osalien.com/dbblog/20200927/b0d2663195684681808be4f9ce6f63c2.png'),(53,'image.png','http://oss.osalien.com/dbblog/20200927/adb9024fdec142288d6fea276f3d0cc5.png'),(54,'image.png','http://oss.osalien.com/dbblog/20200927/f103f46c9fc841bab92f8887a7d9acb2.png'),(55,'image.png','http://oss.osalien.com/dbblog/20200927/e558705edeb44f37bb1d05955becfb4f.png'),(56,'image.png','http://oss.osalien.com/dbblog/20200927/2fa5e653c1ac426bb59ea404c61fde65.png'),(57,'image.png','http://oss.osalien.com/dbblog/20200927/efdae087278e44eb9a48b0c228aea9ec.png'),(58,'image.png','http://oss.osalien.com/dbblog/20200927/acf65856afa64289abcfd72b316d929b.png'),(59,'image.png','http://oss.osalien.com/dbblog/20200927/af1f8ebd7a064e0da4d46c9e0a685b1c.png'),(60,'image.png','http://oss.osalien.com/dbblog/20200927/d33c397f46b145fc86679540e5be2904.png'),(61,'image.png','http://oss.osalien.com/dbblog/20200927/968ab1df98c2498d96274d66ab509f06.png'),(62,'image.png','http://oss.osalien.com/dbblog/20200927/6760c82f80f44c27828a3ba9f60c614d.png'),(63,'image.png','http://oss.osalien.com/dbblog/20200927/22650688578a4f6a93ab5ea615627c2b.png'),(64,'image.png','http://oss.osalien.com/dbblog/20200927/2963c48aa1544016b0e11e29a0aaff48.png'),(65,'image.png','http://oss.osalien.com/dbblog/20200927/3fadb753db7b4568993bb3e6344b1af4.png'),(66,'image.png','http://oss.osalien.com/dbblog/20200927/c449faf67d734bdc8ab4563e9de8d384.png'),(67,'image.png','http://oss.osalien.com/dbblog/20200927/fd00a2f8bd544565ba51d68b6d14c863.png'),(68,'image.png','http://oss.osalien.com/dbblog/20200927/23e2dc95130f44e591df06636e8e4ebb.png'),(69,'image.png','http://oss.osalien.com/dbblog/20200927/1f27ecf8dd69422596392f12fccf3105.png'),(70,'image.png','http://oss.osalien.com/dbblog/20200927/f9705cad7ea746f1a2cd9bbea9dd351f.png'),(71,'image.png','http://oss.osalien.com/dbblog/20200927/235332789b2e473ebfb1aa19880a4242.png'),(72,'image.png','http://oss.osalien.com/dbblog/20200927/4e9e0e65e2f2498baf3d4ffb58cede5e.png'),(73,'image.png','http://oss.osalien.com/dbblog/20200927/468998e2e5c9465ca6e8897309182788.png'),(74,'image.png','http://oss.osalien.com/dbblog/20200927/eb46b64979434f62b96245f4682a51c1.png'),(75,'image.png','http://oss.osalien.com/dbblog/20200927/8e4e7c787d8840949eb04d4021fd464d.png'),(76,'image.png','http://oss.osalien.com/dbblog/20200927/2c72af00da7b4aaba4099b915bfdde3b.png'),(77,'image.png','http://oss.osalien.com/dbblog/20200927/db465142011f4e1685e175d0a04db8d6.png'),(78,'image.png','http://oss.osalien.com/dbblog/20200927/47c7b39e77a0471e80262e6ade5133ed.png'),(79,'image.png','http://oss.osalien.com/dbblog/20200927/c71f1d2b672d4a64a46db2053357b973.png'),(80,'image.png','http://oss.osalien.com/dbblog/20200927/3607e378a2774679a7ff8964164d31ba.png'),(81,'image.png','http://oss.osalien.com/dbblog/20200927/e1a9f722b6234ecab47cec2cca393680.png'),(82,'image.png','http://oss.osalien.com/dbblog/20200927/c632856b2f4945f195a0bc9f958e314d.png'),(83,'image.png','http://oss.osalien.com/dbblog/20200927/4a6cf290ef724e2aa9b0f7d49efa4df6.png'),(84,'image.png','http://oss.osalien.com/dbblog/20200927/41290e8a8eba44eda50321ccbf0200ee.png'),(85,'image.png','http://oss.osalien.com/dbblog/20200927/5a5a1aacb7724a88a02a969fe47c6ddf.png'),(86,'image.png','http://oss.osalien.com/dbblog/20200927/7d33fe50bc084327a175d3349a073410.png'),(87,'image.png','http://oss.osalien.com/dbblog/20200927/199815eca3ec4628bf708b8efe94c442.png'),(88,'image.png','http://oss.osalien.com/dbblog/20200927/947a26cadcc04bc8a870144179c62c39.png'),(89,'image.png','http://oss.osalien.com/dbblog/20200927/5a70a907d7e947709d3cc8f98c3a2af5.png'),(90,'image.png','http://oss.osalien.com/dbblog/20200927/7429f7ac0a034cce958bb62d5404599d.png'),(91,'image.png','http://oss.osalien.com/dbblog/20200927/528542ca39d84222b64ee4479f373e07.png'),(92,'image.png','http://oss.osalien.com/dbblog/20200927/940bcfd015b04240bf8bc050ece98c8d.png'),(93,'image.png','http://oss.osalien.com/dbblog/20200927/7a07046d13824178980f1dcc28ff227f.png'),(94,'image.png','http://oss.osalien.com/dbblog/20200927/2e9d2d2362704767bcf15172774c2ac3.png'),(95,'image.png','http://oss.osalien.com/dbblog/20200928/9a49b16e156e459fb028c7540450093d.png'),(96,'image.png','http://oss.osalien.com/dbblog/20200928/c7f32ec7730c4e89870f84683f488a49.png'),(97,'image.png','http://oss.osalien.com/dbblog/20200928/0ff0f991a9d14bd2a1b41ba1e8395487.png'),(98,'image.png','http://oss.osalien.com/dbblog/20200928/02c9cf3fe63a4cb088c24082441e2cdc.png'),(99,'image.png','http://oss.osalien.com/dbblog/20200928/f8acc3a9e69d45fdace7b7da76388fcd.png'),(100,'image.png','http://oss.osalien.com/dbblog/20200928/d6b0a966913c41e9bd315254527c3d1f.png'),(101,'image.png','http://oss.osalien.com/dbblog/20200929/e59ad1a7eea843a19f126ed2ef87d44b.png'),(102,'image.png','http://oss.osalien.com/dbblog/20200929/7973534bff654f7fac6f503d3b4712d2.png'),(103,'image.png','http://oss.osalien.com/dbblog/20200929/9ea148ae06414383a7eec802b3528226.png'),(104,'image.png','http://oss.osalien.com/dbblog/20200929/c0711afbb09246f486804e876ee450c8.png'),(105,'image.png','http://oss.osalien.com/dbblog/20200929/5db8f7a3297645c393145c983f2e8272.png'),(106,'image.png','http://oss.osalien.com/dbblog/20200929/9b9d2e1e7a9e46c58c5a5d4f10b135b8.png'),(107,'image.png','http://oss.osalien.com/dbblog/20200929/26bb7b26e582465e9b09b7f9735348bb.png'),(108,'image.png','http://oss.osalien.com/dbblog/20200929/02ab3d266f0b43f0b9d19ed62ae53ab6.png'),(109,'image.png','http://oss.osalien.com/dbblog/20200929/00b78ce60ada41538768a09946ca15cc.png'),(110,'image.png','http://oss.osalien.com/dbblog/20200929/fd22770866c84018b4d0e33708389ea0.png'),(111,'msFvb6.gif','http://oss.osalien.com/dbblog/20200929/52be7ba2332041f1abfd7227c4324066.gif'),(112,'msFXK1.gif','http://oss.osalien.com/dbblog/20200929/3f2b63cfa9ab4b35a1c6c5a0bdbaf58f.gif'),(113,'msFzVK.gif','http://oss.osalien.com/dbblog/20200929/81d7a8d9455b4799b9c640ce1e746abd.gif'),(114,'image.png','http://oss.osalien.com/dbblog/20200929/9eadd044c4c5409dae039cbf8418f66f.png'),(115,'image.png','http://oss.osalien.com/dbblog/20200929/f60589d25ce141e08f62daddb2228e12.png'),(116,'image.png','http://oss.osalien.com/dbblog/20200929/9fe6e08842434b01bab6d7b7b3cfa604.png'),(117,'image.png','http://oss.osalien.com/dbblog/20200929/c633a03a8a6b4ed0a82b9bf2eea1242f.png'),(118,'image.png','http://oss.osalien.com/dbblog/20200929/5a2242c00c894af88b139ef3e2ff268a.png'),(119,'image.png','http://oss.osalien.com/dbblog/20200929/611b85fb037843f084de98902f434930.png'),(120,'image.png','http://oss.osalien.com/dbblog/20200929/0176cc600a554e0aad31eafe09a1c66a.png'),(121,'image.png','http://oss.osalien.com/dbblog/20200929/30ee91ee22554d39a3f125cd998d2c23.png'),(122,'image.png','http://oss.osalien.com/dbblog/20200929/576f09b3e1954019bcae81b0a5fce5e9.png'),(123,'Java核心技术卷一.jpg','http://oss.osalien.com/dbblog/20200930/8d3ff46326fb4e59ae2b916af98b45af.jpg'),(124,'image.png','http://oss.osalien.com/dbblog/20201009/67e10dd51dc74af18d439e4f65c62df3.png'),(125,'image.png','http://oss.osalien.com/dbblog/20201009/c218b80c85e54887990f58bdb350e9b5.png'),(126,'image.png','http://oss.osalien.com/dbblog/20201009/6412ab3a46b54f0eae11f5ac94956a38.png'),(127,'image.png','http://oss.osalien.com/dbblog/20201009/5167aa9ce63347448baec159e1fa148a.png'),(128,'image.png','http://oss.osalien.com/dbblog/20201009/dc15839cbd7e4130b4295b9f80f5ffe5.png'),(129,'image.png','http://oss.osalien.com/dbblog/20201009/f11f47101ba743fda59417cdefeb12c3.png'),(130,'image.png','http://oss.osalien.com/dbblog/20201009/04e7ebfb652e4092ac48f6cfafd699c0.png'),(131,'image.png','http://oss.osalien.com/dbblog/20201009/ce46094ddf10467497bdeb3df7f38ec8.png'),(132,'image.png','http://oss.osalien.com/dbblog/20201010/d3676534ff4e4e85b3d69758ba03be40.png'),(133,'image.png','http://oss.osalien.com/dbblog/20201010/47d3f78d7588432cb558f07499e0f0bb.png'),(134,'image.png','http://oss.osalien.com/dbblog/20201010/6a511922056c451e841950615e7a4bd6.png'),(135,'image.png','http://oss.osalien.com/dbblog/20201010/e947de3d3511490791e38162b14c01a2.png'),(136,'image.png','http://oss.osalien.com/dbblog/20201010/214562be36e74df69a519a613293f98a.png'),(137,'image.png','http://oss.osalien.com/dbblog/20201010/c102b28b390d4a18be805354783202a9.png'),(138,'image.png','http://oss.osalien.com/dbblog/20201010/1ec72ba3568c452885075fb0c416fded.png'),(139,'image.png','http://oss.osalien.com/dbblog/20201010/76f93e3f5a1c47f0ad7a9e5714fd11f4.png'),(140,'image.png','http://oss.osalien.com/dbblog/20201010/91e1b46d3eb148658c69cff64d8fd608.png'),(141,'image.png','http://oss.osalien.com/dbblog/20201010/520ee00e5b8a4d1cb9946b68ec88f5e9.png'),(142,'image.png','http://oss.osalien.com/dbblog/20201010/bdb6047c3cc242a883e7fecbd6f5397c.png'),(143,'image.png','http://oss.osalien.com/dbblog/20201010/2cd32b100c504d978699177868f28ca6.png'),(144,'image.png','http://oss.osalien.com/dbblog/20201010/e5a5f0dbc027429689ac538d7bc6b514.png'),(145,'image.png','http://oss.osalien.com/dbblog/20201010/1fdc6138b2fd4050bb2978983043b164.png'),(146,'image.png','http://oss.osalien.com/dbblog/20201010/77220b89ab274708b683b8fb30148eb6.png'),(147,'image.png','http://oss.osalien.com/dbblog/20201010/5c4a5cecba75473e91493dd3dfb1a3a0.png'),(148,'image.png','http://oss.osalien.com/dbblog/20201012/3e27261931c042f1a4383fcd75b38026.png'),(149,'公众号二维码.jpg','http://oss.osalien.com/dbblog/20201012/c759f97988da46f2aa3f9dd96a8e3a18.jpg'),(150,'Java学习.jpg','http://oss.osalien.com/dbblog/20201013/78f4b1ab5a4549c2abafcd1579a32a60.jpg'),(151,'Java学习路线.png','http://oss.osalien.com/dbblog/20201013/b2c54a2b633f41adbc42ae978b9cc61b.png'),(152,'Java学习路线.png','http://oss.osalien.com/dbblog/20201013/c2ffd400a7214f4eb2c276e25ceab168.png');
/*!40000 ALTER TABLE `oss_resource` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `recommend`
--

DROP TABLE IF EXISTS `recommend`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `recommend` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `link_id` int(11) DEFAULT NULL COMMENT '推荐的文章Id',
  `type` int(11) DEFAULT NULL COMMENT '推荐类型',
  `order_num` int(11) DEFAULT '0' COMMENT '顺序',
  `title` varchar(100) DEFAULT NULL COMMENT '标题',
  `top` tinyint(1) DEFAULT '0' COMMENT '置顶',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COMMENT='推荐';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `recommend`
--

LOCK TABLES `recommend` WRITE;
/*!40000 ALTER TABLE `recommend` DISABLE KEYS */;
INSERT INTO `recommend` VALUES (1,1,0,0,'本站相关',1),(3,7,0,4,'Mysql双机热备',0),(4,8,0,1,'Spring IOC 容器源码分析',0),(5,9,0,2,'JAVA 线上故障如何完整排查？',0),(6,10,0,3,'一文讲清楚互斥锁、自旋锁、读写锁、悲观锁、乐观锁',0);
/*!40000 ALTER TABLE `recommend` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_menu`
--

DROP TABLE IF EXISTS `sys_menu`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_menu` (
  `menu_id` bigint(20) DEFAULT NULL,
  `parent_id` bigint(20) DEFAULT NULL,
  `name` tinytext,
  `url` varchar(200) DEFAULT NULL,
  `perms` varchar(500) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `icon` tinytext,
  `order_num` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='菜单管理';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_menu`
--

LOCK TABLES `sys_menu` WRITE;
/*!40000 ALTER TABLE `sys_menu` DISABLE KEYS */;
INSERT INTO `sys_menu` VALUES (5,1,'SQL监控','https://osb.osalien.com/dbblog/druid/sql.html',NULL,1,'sql',5),(1,0,'系统管理',NULL,NULL,0,'config',3),(2,1,'管理员列表','sys/user',NULL,1,'admin',1),(3,1,'角色管理','sys/role',NULL,1,'role',2),(4,1,'菜单管理','sys/menu',NULL,1,'menu',3),(15,2,'查看',NULL,'sys:user:list,sys:user:info',2,NULL,0),(16,2,'新增',NULL,'sys:user:save,sys:role:select',2,NULL,0),(17,2,'修改',NULL,'sys:user:update,sys:role:select',2,NULL,0),(18,2,'删除',NULL,'sys:user:delete',2,NULL,0),(19,3,'查看',NULL,'sys:role:list,sys:role:info',2,NULL,0),(20,3,'新增',NULL,'sys:role:save,sys:menu:list',2,NULL,0),(21,3,'修改',NULL,'sys:role:update,sys:menu:list',2,NULL,0),(22,3,'删除',NULL,'sys:role:delete',2,NULL,0),(23,4,'查看',NULL,'sys:menu:list,sys:menu:info',2,NULL,0),(24,4,'新增',NULL,'sys:menu:save,sys:menu:select',2,NULL,0),(25,4,'修改',NULL,'sys:menu:update,sys:menu:select',2,NULL,0),(26,4,'删除',NULL,'sys:menu:delete',2,NULL,0),(30,0,'博文管理',NULL,NULL,0,'article',0),(31,30,'新增博文','article/article-add-or-update','article:save,article:update',1,'add',0),(32,30,'博文列表','article/article',NULL,1,'list',0),(33,32,'删除',NULL,'article:delete',2,NULL,0),(34,32,'查看',NULL,'article:list',2,NULL,0),(38,43,'分类管理','operation/category',NULL,1,'category',6),(39,38,'查看',NULL,'operation:category:list,operation:category:info',2,NULL,6),(40,38,'新增',NULL,'operation:category:save',2,NULL,6),(41,38,'修改',NULL,'operation:category:update',2,NULL,6),(42,38,'删除',NULL,'operation:category:delete',2,NULL,6),(43,0,'运营管理',NULL,NULL,0,'operation',2),(45,1,'系统参数','sys/param',NULL,1,'param',4),(46,45,'查看',NULL,'sys:param:list,sys:param:info',2,NULL,6),(47,45,'新增',NULL,'sys:param:save',2,NULL,6),(48,45,'修改',NULL,'sys:param:update',2,NULL,6),(49,45,'删除',NULL,'sys:param:delete',2,NULL,6),(50,43,'标签管理','operation/tag',NULL,1,'tag',6),(51,50,'查看',NULL,'operation:tag:list,operation:tag:info',2,NULL,6),(52,50,'新增',NULL,'operation:tag:save',2,NULL,6),(53,50,'修改',NULL,'operation:tag:update',2,NULL,6),(54,50,'删除',NULL,'operation:tag:delete',2,NULL,6),(55,60,'评论管理','https://valine.osalien.com',NULL,1,'comment',6),(56,55,'查看',NULL,'comment:list,comment:info',2,NULL,6),(57,55,'新增',NULL,'comment:save',2,NULL,6),(58,55,'修改',NULL,'comment:update',2,NULL,6),(59,55,'删除',NULL,'comment:delete',2,NULL,6),(60,0,'评论管理',NULL,NULL,0,'comment',5),(61,66,'图书管理','book/book',NULL,1,'list',3),(62,61,'查看',NULL,'book:list,book:info',2,NULL,6),(63,61,'新增',NULL,'book:save',2,NULL,6),(64,61,'修改',NULL,'book:update',2,NULL,6),(65,61,'删除',NULL,'book:delete',2,NULL,6),(66,0,'阅读管理',NULL,NULL,0,'read',1),(67,66,'新增图书','book/book-add-or-update','',1,'add',1),(68,66,'笔记管理','book/note',NULL,1,'list',2),(69,68,'查看',NULL,'book:note:list,book:note:info',2,NULL,6),(70,68,'新增',NULL,'book:note:save',2,NULL,6),(71,68,'修改',NULL,'book:note:update',2,NULL,6),(72,68,'删除',NULL,'book:note:delete',2,NULL,6),(73,66,'新增笔记','book/note-add-or-update','',1,'add',0),(74,43,'友链管理','operation/link',NULL,1,'link',6),(75,74,'查看',NULL,'operation:link:list,operation:link:info',2,NULL,6),(76,74,'新增',NULL,'operation:link:save',2,NULL,6),(77,74,'修改',NULL,'operation:link:update',2,NULL,6),(78,74,'删除',NULL,'operation:link:delete',2,NULL,6),(79,43,'推荐管理','operation/recommend',NULL,1,'recommend',6),(80,79,'查看',NULL,'operation:recommend:list,operation:recommend:info',2,NULL,6),(81,79,'新增',NULL,'operation:recommend:save',2,NULL,6),(82,79,'修改',NULL,'operation:recommend:update',2,NULL,6),(83,79,'删除',NULL,'operation:recommend:delete',2,NULL,6);
/*!40000 ALTER TABLE `sys_menu` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_param`
--

DROP TABLE IF EXISTS `sys_param`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_param` (
  `id` int(11) DEFAULT NULL,
  `par_key` int(11) DEFAULT NULL,
  `par_value` varchar(255) DEFAULT NULL,
  `menu_url` varchar(255) DEFAULT NULL,
  `type` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='系统参数';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_param`
--

LOCK TABLES `sys_param` WRITE;
/*!40000 ALTER TABLE `sys_param` DISABLE KEYS */;
INSERT INTO `sys_param` VALUES (2,0,'一级','/operation-category','CATEGORY_RANK'),(3,1,'二级','/operation-category','CATEGORY_RANK'),(4,2,'三级','/operation-category','CATEGORY_RANK'),(7,0,'小图片','/article-addOrUpdate','ARTICLE_COVER_TYPE'),(8,1,'大图片','/article-addOrUpdate','ARTICLE_COVER_TYPE'),(9,2,'无图片','/article-addOrUpdate','ARTICLE_COVER_TYPE'),(10,0,'文章',NULL,'MODULE_TYPE'),(11,1,'图书',NULL,'MODULE_TYPE'),(12,2,'笔记',NULL,'MODULE_TYPE');
/*!40000 ALTER TABLE `sys_param` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_role`
--

DROP TABLE IF EXISTS `sys_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_role` (
  `role_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `role_name` varchar(100) DEFAULT NULL COMMENT '角色名称',
  `remark` varchar(100) DEFAULT NULL COMMENT '备注',
  `create_user_id` bigint(20) DEFAULT NULL COMMENT '创建者ID',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='角色';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_role`
--

LOCK TABLES `sys_role` WRITE;
/*!40000 ALTER TABLE `sys_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `sys_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_role_menu`
--

DROP TABLE IF EXISTS `sys_role_menu`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_role_menu` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `role_id` bigint(20) DEFAULT NULL COMMENT '角色ID',
  `menu_id` bigint(20) DEFAULT NULL COMMENT '菜单ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='角色与菜单对应关系';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_role_menu`
--

LOCK TABLES `sys_role_menu` WRITE;
/*!40000 ALTER TABLE `sys_role_menu` DISABLE KEYS */;
/*!40000 ALTER TABLE `sys_role_menu` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_user`
--

DROP TABLE IF EXISTS `sys_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_user` (
  `user_id` int(11) DEFAULT NULL,
  `username` tinytext,
  `password` varchar(255) DEFAULT NULL,
  `email` tinytext,
  `salt` tinytext,
  `create_user_id` tinytext,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `status` tinyint(4) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_user`
--

LOCK TABLES `sys_user` WRITE;
/*!40000 ALTER TABLE `sys_user` DISABLE KEYS */;
INSERT INTO `sys_user` VALUES (1,'admin','72d62f4fe31281677eb30aac311049fe5a3026924c3ad91f27b1ce1bd20c5a2d','me@osalien.com','YzcmCZNvbXocrsz9dm8e','1','2020-05-15 08:06:29',1);
/*!40000 ALTER TABLE `sys_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_user_role`
--

DROP TABLE IF EXISTS `sys_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_user_role` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `role_id` bigint(20) DEFAULT NULL COMMENT '角色ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户与角色对应关系';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_user_role`
--

LOCK TABLES `sys_user_role` WRITE;
/*!40000 ALTER TABLE `sys_user_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `sys_user_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tag`
--

DROP TABLE IF EXISTS `tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL COMMENT '标签名字',
  `type` int(11) DEFAULT NULL COMMENT '所属类别：0文章，1类别',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8 COMMENT='标签';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tag`
--

LOCK TABLES `tag` WRITE;
/*!40000 ALTER TABLE `tag` DISABLE KEYS */;
INSERT INTO `tag` VALUES (1,'本站相关',0),(7,'Java',0),(11,'数据库',0),(12,'关系型数据库',0),(13,'mysql',0),(14,'开源框架',0),(15,'源码解析',0),(16,'Spring',0),(17,'LeetCode',2),(18,'初级算法',2),(19,'算法',2),(20,'数组',2),(23,'LeetCode',1),(24,'锁',0),(25,'高并发',0),(26,'事务',0),(27,'Java Web',0),(28,'验证码',0),(29,'Java',1),(30,'故障排查',0),(31,'Java集合',0),(32,'多线程',0),(33,'开发者成长路线',0);
/*!40000 ALTER TABLE `tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tag_link`
--

DROP TABLE IF EXISTS `tag_link`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tag_link` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `tag_id` int(11) DEFAULT NULL COMMENT '标签Id',
  `link_id` int(11) DEFAULT NULL COMMENT '关联Id',
  `type` int(11) DEFAULT NULL COMMENT '所属类别：0文章，1阅读',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=358 DEFAULT CHARSET=utf8 COMMENT='标签多对多维护表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tag_link`
--

LOCK TABLES `tag_link` WRITE;
/*!40000 ALTER TABLE `tag_link` DISABLE KEYS */;
INSERT INTO `tag_link` VALUES (251,7,11,0),(252,27,11,0),(253,28,11,0),(254,7,10,0),(255,11,10,0),(256,24,10,0),(257,25,10,0),(258,26,10,0),(260,11,7,0),(261,12,7,0),(262,13,7,0),(263,14,8,0),(264,15,8,0),(265,16,8,0),(267,29,2,1),(268,23,1,1),(277,17,2,2),(278,19,2,2),(279,18,2,2),(280,20,2,2),(281,17,1,2),(282,19,1,2),(283,18,1,2),(284,20,1,2),(285,7,9,0),(286,30,9,0),(295,7,12,0),(296,30,12,0),(303,7,23,0),(304,32,23,0),(305,7,24,0),(306,32,24,0),(307,7,25,0),(308,32,25,0),(309,7,26,0),(310,32,26,0),(311,7,27,0),(312,32,27,0),(313,7,28,0),(314,32,28,0),(315,7,22,0),(316,32,22,0),(321,7,16,0),(322,31,16,0),(329,7,13,0),(330,31,13,0),(331,7,14,0),(332,31,14,0),(333,7,15,0),(334,31,15,0),(335,7,17,0),(336,31,17,0),(337,7,18,0),(338,31,18,0),(339,7,19,0),(340,31,19,0),(341,7,20,0),(342,32,20,0),(343,7,21,0),(344,32,21,0),(351,7,29,0),(352,33,29,0),(355,1,1,0),(356,7,30,0),(357,33,30,0);
/*!40000 ALTER TABLE `tag_link` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-10-22  0:00:04
